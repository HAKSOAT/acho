// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/keyword_search.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/seekstorm/commit.dart';
import 'third_party/seekstorm/geo_search.dart';
import 'third_party/seekstorm/highlighter.dart';
import 'third_party/seekstorm/index.dart';
import 'third_party/seekstorm/ingest.dart';
import 'third_party/seekstorm/search.dart';
import 'third_party/seekstorm/utils.dart';
import 'third_party/tokio/io.dart';
import 'third_party/tokio/macros/support.dart';
import 'third_party/tokio/net.dart';
import 'third_party/tokio/net/tcp.dart';
import 'third_party/tokio/net/tcp/listener.dart';
import 'third_party/tokio/net/tcp/split_owned.dart';
import 'third_party/tokio/net/udp.dart';
import 'third_party/tokio/net/unix.dart';
import 'third_party/tokio/net/unix/datagram/socket.dart';
import 'third_party/tokio/net/unix/listener.dart';
import 'third_party/tokio/net/unix/pipe.dart';
import 'third_party/tokio/process.dart';
import 'third_party/tokio/process/sys.dart';
import 'third_party/tokio/runtime.dart';
import 'third_party/tokio/signal.dart';
import 'third_party/tokio/signal/unix.dart';
import 'third_party/tokio/sync.dart';
import 'third_party/tokio/sync/broadcast.dart';
import 'third_party/tokio/sync/broadcast/error.dart';
import 'third_party/tokio/sync/mpsc/bounded.dart';
import 'third_party/tokio/sync/mpsc/error.dart';
import 'third_party/tokio/sync/oneshot.dart';
import 'third_party/tokio/sync/watch.dart';
import 'third_party/tokio/task.dart';
import 'third_party/tokio/task/coop.dart';
import 'third_party/tokio/time.dart';
import 'third_party/tokio/time/error.dart';
import 'third_party/tokio/time/interval.dart';


                /// Main entrypoint of the Rust API
                class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
                  @internal
                  static final instance = RustLib._();

                  RustLib._();

                  /// Initialize flutter_rust_bridge
                  static Future<void> init({
                    RustLibApi? api,
                    BaseHandler? handler,
                    ExternalLibrary? externalLibrary,
                    bool forceSameCodegenVersion = true,
                  }) async {
                    await instance.initImpl(
                      api: api,
                      handler: handler,
                      externalLibrary: externalLibrary,
                      forceSameCodegenVersion: forceSameCodegenVersion,
                    );
                  }

                  /// Initialize flutter_rust_bridge in mock mode.
                  /// No libraries for FFI are loaded.
                  static void initMock({
                    required RustLibApi api,
                  }) {
                    instance.initMockImpl(
                      api: api,
                    );
                  }

                  /// Dispose flutter_rust_bridge
                  ///
                  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
                  /// is automatically disposed when the app stops.
                  static void dispose() => instance.disposeImpl();

                  @override
                  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

                  @override
                  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

                  @override
                  Future<void> executeRustInitializers() async {
                    await api.crateApiSimpleInitApp();

                  }

                  @override
                  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

                  @override
                  String get codegenVersion => '2.11.1';

                  @override
                  int get rustContentHash => 606630313;

                  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
                    stem: 'rust_lib_mobile_app',
                    ioDirectory: 'rust/target/release/',
                    webPrefix: 'pkg/',
                  );
                }
                

                abstract class RustLibApi extends BaseApi {
                  Future<bool> tokioSyncBarrierWaitResultIsLeader({required BarrierWaitResult that });

Future<Barrier> tokioSyncBarrierNew({required BigInt n });

Future<BarrierWaitResult> tokioSyncBarrierWait({required Barrier that });

Future<ChildStderr> tokioProcessChildStderrFromStd({required ChildStderr inner });

Future<OwnedFd> tokioProcessChildStderrIntoOwnedFd({required ChildStderr that });

Future<ChildStdin> tokioProcessChildStdinFromStd({required ChildStdin inner });

Future<OwnedFd> tokioProcessChildStdinIntoOwnedFd({required ChildStdin that });

Future<ChildStdout> tokioProcessChildStdoutFromStd({required ChildStdout inner });

Future<OwnedFd> tokioProcessChildStdoutIntoOwnedFd({required ChildStdout that });

ChildStderr? tokioProcessChildAutoAccessorGetStderr({required Child that });

ChildStdin? tokioProcessChildAutoAccessorGetStdin({required Child that });

ChildStdout? tokioProcessChildAutoAccessorGetStdout({required Child that });

void tokioProcessChildAutoAccessorSetStderr({required Child that , ChildStderr? stderr });

void tokioProcessChildAutoAccessorSetStdin({required Child that , ChildStdin? stdin });

void tokioProcessChildAutoAccessorSetStdout({required Child that , ChildStdout? stdout });

Future<int?> tokioProcessChildId({required Child that });

Future<void> tokioProcessChildKill({required Child that });

Future<void> tokioProcessChildStartKill({required Child that });

Future<ExitStatus?> tokioProcessChildTryWait({required Child that });

Future<ExitStatus> tokioProcessChildWait({required Child that });

Future<void> tokioProcessCommandAsStd({required Command that });

Future<void> tokioProcessCommandAsStdMut({required Command that });

Future<void> tokioProcessCommandEnvClear({required Command that });

Future<bool> tokioProcessCommandGetKillOnDrop({required Command that });

Future<void> tokioProcessCommandGid({required Command that , required int id });

Future<StdCommand> tokioProcessCommandIntoStd({required Command that });

Future<void> tokioProcessCommandKillOnDrop({required Command that , required bool killOnDrop });

Future<void> tokioProcessCommandProcessGroup({required Command that , required int pgroup });

Future<Child> tokioProcessCommandSpawn({required Command that });

Future<void> tokioProcessCommandUid({required Command that , required int id });

Future<Error> tokioTimeErrorErrorAtCapacity();

Future<Error> tokioTimeErrorErrorInvalid();

Future<bool> tokioTimeErrorErrorIsAtCapacity({required Error that });

Future<bool> tokioTimeErrorErrorIsInvalid({required Error that });

Future<bool> tokioTimeErrorErrorIsShutdown({required Error that });

Future<Error> tokioTimeErrorErrorShutdown();

ValueType seekstormIndexFacetFieldAutoAccessorGetMax({required FacetField that });

ValueType seekstormIndexFacetFieldAutoAccessorGetMin({required FacetField that });

String seekstormIndexFacetFieldAutoAccessorGetName({required FacetField that });

IndexMapStringVecStringUsize seekstormIndexFacetFieldAutoAccessorGetValues({required FacetField that });

void seekstormIndexFacetFieldAutoAccessorSetMax({required FacetField that , required ValueType max });

void seekstormIndexFacetFieldAutoAccessorSetMin({required FacetField that , required ValueType min });

void seekstormIndexFacetFieldAutoAccessorSetName({required FacetField that , required String name });

void seekstormIndexFacetFieldAutoAccessorSetValues({required FacetField that , required IndexMapStringVecStringUsize values });

Future<FacetField> seekstormIndexFacetFieldDefault();

Future<FrequentwordType> seekstormIndexFrequentwordTypeDefault();

Future<Handle> tokioRuntimeHandleCurrent();

Future<Handle> tokioRuntimeHandleDefault();

Future<EnterGuard> tokioRuntimeHandleEnter({required Handle that });

Future<Id> tokioRuntimeHandleId({required Handle that });

Future<RuntimeMetrics> tokioRuntimeHandleMetrics({required Handle that });

Future<RuntimeFlavor> tokioRuntimeHandleRuntimeFlavor({required Handle that });

Future<Handle> tokioRuntimeHandleTryCurrent();

AccessType seekstormIndexIndexMetaObjectAutoAccessorGetAccessType({required IndexMetaObject that });

FrequentwordType seekstormIndexIndexMetaObjectAutoAccessorGetFrequentWords({required IndexMetaObject that });

BigInt seekstormIndexIndexMetaObjectAutoAccessorGetId({required IndexMetaObject that });

String seekstormIndexIndexMetaObjectAutoAccessorGetName({required IndexMetaObject that });

int seekstormIndexIndexMetaObjectAutoAccessorGetNgramIndexing({required IndexMetaObject that });

QueryCompletion? seekstormIndexIndexMetaObjectAutoAccessorGetQueryCompletion({required IndexMetaObject that });

SimilarityType seekstormIndexIndexMetaObjectAutoAccessorGetSimilarity({required IndexMetaObject that });

SpellingCorrection? seekstormIndexIndexMetaObjectAutoAccessorGetSpellingCorrection({required IndexMetaObject that });

StemmerType seekstormIndexIndexMetaObjectAutoAccessorGetStemmer({required IndexMetaObject that });

StopwordType seekstormIndexIndexMetaObjectAutoAccessorGetStopWords({required IndexMetaObject that });

TokenizerType seekstormIndexIndexMetaObjectAutoAccessorGetTokenizer({required IndexMetaObject that });

void seekstormIndexIndexMetaObjectAutoAccessorSetAccessType({required IndexMetaObject that , required AccessType accessType });

void seekstormIndexIndexMetaObjectAutoAccessorSetFrequentWords({required IndexMetaObject that , required FrequentwordType frequentWords });

void seekstormIndexIndexMetaObjectAutoAccessorSetId({required IndexMetaObject that , required BigInt id });

void seekstormIndexIndexMetaObjectAutoAccessorSetName({required IndexMetaObject that , required String name });

void seekstormIndexIndexMetaObjectAutoAccessorSetNgramIndexing({required IndexMetaObject that , required int ngramIndexing });

void seekstormIndexIndexMetaObjectAutoAccessorSetQueryCompletion({required IndexMetaObject that , QueryCompletion? queryCompletion });

void seekstormIndexIndexMetaObjectAutoAccessorSetSimilarity({required IndexMetaObject that , required SimilarityType similarity });

void seekstormIndexIndexMetaObjectAutoAccessorSetSpellingCorrection({required IndexMetaObject that , SpellingCorrection? spellingCorrection });

void seekstormIndexIndexMetaObjectAutoAccessorSetStemmer({required IndexMetaObject that , required StemmerType stemmer });

void seekstormIndexIndexMetaObjectAutoAccessorSetStopWords({required IndexMetaObject that , required StopwordType stopWords });

void seekstormIndexIndexMetaObjectAutoAccessorSetTokenizer({required IndexMetaObject that , required TokenizerType tokenizer });

Future<BigInt> seekstormIndexIndexAddSynonyms({required Index that , required List<Synonym> synonyms });

int seekstormIndexIndexAutoAccessorGetIndexFormatVersionMajor({required Index that });

int seekstormIndexIndexAutoAccessorGetIndexFormatVersionMinor({required Index that });

IndexMetaObject seekstormIndexIndexAutoAccessorGetMeta({required Index that });

Map<String, SchemaField> seekstormIndexIndexAutoAccessorGetSchemaMap({required Index that });

List<String> seekstormIndexIndexAutoAccessorGetStoredFieldNames({required Index that });

void seekstormIndexIndexAutoAccessorSetIndexFormatVersionMajor({required Index that , required int indexFormatVersionMajor });

void seekstormIndexIndexAutoAccessorSetIndexFormatVersionMinor({required Index that , required int indexFormatVersionMinor });

void seekstormIndexIndexAutoAccessorSetMeta({required Index that , required IndexMetaObject meta });

void seekstormIndexIndexAutoAccessorSetSchemaMap({required Index that , required Map<String, SchemaField> schemaMap });

void seekstormIndexIndexAutoAccessorSetStoredFieldNames({required Index that , required List<String> storedFieldNames });

Future<void> seekstormIndexIndexClearIndex({required Index that });

Future<BigInt> seekstormIndexIndexCommittedDocCount({required Index that });

Future<BigInt> seekstormIndexIndexCurrentDocCount({required Index that });

Future<void> seekstormIndexIndexDeleteIndex({required Index that });

Future<BigInt> seekstormIndexIndexFacetsCount({required Index that });

Future<Map<String, Value>> seekstormIndexIndexGetDocument({required Index that , required BigInt docId , required bool includeUncommited , Highlighter? highlighterOption , required Set<String> fields , required List<DistanceField> distanceFields });

Future<FacetValue> seekstormIndexIndexGetFacetValue({required Index that , required String field , required BigInt docId });

Future<Uint8List> seekstormIndexIndexGetFile({required Index that , required BigInt docId });

Future<AHashMapStringFacet?> seekstormIndexIndexGetIndexStringFacets({required Index that , required List<QueryFacet> queryFacets });

Future<List<Synonym>> seekstormIndexIndexGetSynonyms({required Index that });

Future<Map<String, MinMaxFieldJson>> seekstormIndexIndexIndexFacetsMinmax({required Index that });

Future<BigInt> seekstormIndexIndexIndexedDocCount({required Index that });

Future<BigInt> seekstormIndexIndexLevelCount({required Index that });

Future<BigInt> seekstormIndexIndexSetSynonyms({required Index that , required List<Synonym> synonyms });

Future<BigInt> seekstormIndexIndexShardCount({required Index that });

Future<BigInt> seekstormIndexIndexUncommittedDocCount({required Index that });

Future<Interest> tokioIoInterestAdd({required Interest that , required Interest other });

Future<bool> tokioIoInterestIsError({required Interest that });

Future<bool> tokioIoInterestIsReadable({required Interest that });

Future<bool> tokioIoInterestIsWritable({required Interest that });

Future<Interest?> tokioIoInterestRemove({required Interest that , required Interest other });

Future<MissedTickBehavior> tokioTimeIntervalMissedTickBehavior({required Interval that });

Future<Duration> tokioTimeIntervalPeriod({required Interval that });

Future<PollInstant> tokioTimeIntervalPollTick({required Interval that , required Context cx });

Future<void> tokioTimeIntervalReset({required Interval that });

Future<void> tokioTimeIntervalResetAfter({required Interval that , required Duration after });

Future<void> tokioTimeIntervalResetAt({required Interval that , required Instant deadline });

Future<void> tokioTimeIntervalResetImmediately({required Interval that });

Future<void> tokioTimeIntervalSetMissedTickBehavior({required Interval that , required MissedTickBehavior behavior });

Future<Instant> tokioTimeIntervalTick({required Interval that });

Future<LocalSet> tokioTaskLocalSetDefault();

Future<LocalEnterGuard> tokioTaskLocalSetEnter({required LocalSet that });

Future<Id> tokioTaskLocalSetId({required LocalSet that });

Future<LocalSet> tokioTaskLocalSetNew();

Value seekstormIndexMinMaxFieldJsonAutoAccessorGetMax({required MinMaxFieldJson that });

Value seekstormIndexMinMaxFieldJsonAutoAccessorGetMin({required MinMaxFieldJson that });

void seekstormIndexMinMaxFieldJsonAutoAccessorSetMax({required MinMaxFieldJson that , required Value max });

void seekstormIndexMinMaxFieldJsonAutoAccessorSetMin({required MinMaxFieldJson that , required Value min });

Future<MinMaxFieldJson> seekstormIndexMinMaxFieldJsonDefault();

ValueType seekstormIndexMinMaxFieldAutoAccessorGetMax({required MinMaxField that });

ValueType seekstormIndexMinMaxFieldAutoAccessorGetMin({required MinMaxField that });

void seekstormIndexMinMaxFieldAutoAccessorSetMax({required MinMaxField that , required ValueType max });

void seekstormIndexMinMaxFieldAutoAccessorSetMin({required MinMaxField that , required ValueType min });

Future<MinMaxField> seekstormIndexMinMaxFieldDefault();

Future<Notify> tokioSyncNotifyConstNew();

Future<Notify> tokioSyncNotifyDefault();

Future<Notify> tokioSyncNotifyNew();

Future<Notified> tokioSyncNotifyNotified({required Notify that });

Future<OwnedNotified> tokioSyncNotifyNotifiedOwned({required Notify that });

Future<void> tokioSyncNotifyNotifyLast({required Notify that });

Future<void> tokioSyncNotifyNotifyOne({required Notify that });

Future<void> tokioSyncNotifyNotifyWaiters({required Notify that });

Future<void> tokioNetUnixPipeOpenOptionsAppend({required OpenOptions that , required bool append });

Future<void> tokioNetUnixPipeOpenOptionsCreate({required OpenOptions that , required bool create });

Future<void> tokioNetUnixPipeOpenOptionsCreateNew({required OpenOptions that , required bool createNew });

Future<void> tokioNetUnixPipeOpenOptionsCustomFlags({required OpenOptions that , required int flags });

Future<OpenOptions> tokioNetUnixPipeOpenOptionsDefault();

Future<void> tokioNetUnixPipeOpenOptionsMode({required OpenOptions that , required int mode });

Future<OpenOptions> tokioNetUnixPipeOpenOptionsNew();

Future<void> tokioNetUnixPipeOpenOptionsRead({required OpenOptions that , required bool read });

Future<void> tokioNetUnixPipeOpenOptionsTruncate({required OpenOptions that , required bool truncate });

Future<void> tokioNetUnixPipeOpenOptionsUnchecked({required OpenOptions that , required bool value });

Future<void> tokioNetUnixPipeOpenOptionsWrite({required OpenOptions that , required bool write });

Future<SocketAddr> tokioNetTcpOwnedReadHalfLocalAddr({required OwnedReadHalf that });

Future<BigInt> tokioNetTcpOwnedReadHalfPeek({required OwnedReadHalf that , required U8 buf });

Future<SocketAddr> tokioNetTcpOwnedReadHalfPeerAddr({required OwnedReadHalf that });

Future<PollResultUsize> tokioNetTcpOwnedReadHalfPollPeek({required OwnedReadHalf that , required Context cx , required ReadBuf buf });

Future<void> tokioNetTcpOwnedReadHalfReadable({required OwnedReadHalf that });

Future<Ready> tokioNetTcpOwnedReadHalfReady({required OwnedReadHalf that , required Interest interest });

Future<TcpStream> tokioNetTcpOwnedReadHalfReunite({required OwnedReadHalf that , required OwnedWriteHalf other });

Future<BigInt> tokioNetTcpOwnedReadHalfTryRead({required OwnedReadHalf that , required U8 buf });

Future<BigInt> tokioNetTcpOwnedReadHalfTryReadVectored({required OwnedReadHalf that , required IoSliceMut bufs });

Future<void> tokioSyncOwnedSemaphorePermitMerge({required OwnedSemaphorePermit that , required OwnedSemaphorePermit other });

Future<BigInt> tokioSyncOwnedSemaphorePermitNumPermits({required OwnedSemaphorePermit that });

Future<void> tokioSyncOwnedSemaphorePermitSemaphore({required OwnedSemaphorePermit that });

Future<OwnedSemaphorePermit?> tokioSyncOwnedSemaphorePermitSplit({required OwnedSemaphorePermit that , required BigInt n });

Future<SocketAddr> tokioNetTcpOwnedWriteHalfLocalAddr({required OwnedWriteHalf that });

Future<SocketAddr> tokioNetTcpOwnedWriteHalfPeerAddr({required OwnedWriteHalf that });

Future<Ready> tokioNetTcpOwnedWriteHalfReady({required OwnedWriteHalf that , required Interest interest });

Future<TcpStream> tokioNetTcpOwnedWriteHalfReunite({required OwnedWriteHalf that , required OwnedReadHalf other });

Future<BigInt> tokioNetTcpOwnedWriteHalfTryWrite({required OwnedWriteHalf that , required List<int> buf });

Future<BigInt> tokioNetTcpOwnedWriteHalfTryWriteVectored({required OwnedWriteHalf that , required List<IoSlice> bufs });

Future<void> tokioNetTcpOwnedWriteHalfWritable({required OwnedWriteHalf that });

Future<QueryFacet> seekstormSearchQueryFacetDefault();

Future<QueryRewriting> seekstormSearchQueryRewritingDefault();

Future<Ranges> seekstormSearchRangesDefault();

Future<bool> tokioIoReadyIsEmpty({required Ready that });

Future<bool> tokioIoReadyIsError({required Ready that });

Future<bool> tokioIoReadyIsReadClosed({required Ready that });

Future<bool> tokioIoReadyIsReadable({required Ready that });

Future<bool> tokioIoReadyIsWritable({required Ready that });

Future<bool> tokioIoReadyIsWriteClosed({required Ready that });

Future<T> tokioNetUnixPipeReceiverTBlockingRecv({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTBlockingRecvMany({required ReceiverT that , required VecT buffer , required BigInt limit });

Future<RefT> tokioNetUnixPipeReceiverTBorrow({required ReceiverT that });

Future<RefT> tokioNetUnixPipeReceiverTBorrowAndUpdate({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTCapacity({required ReceiverT that });

Future<void> tokioNetUnixPipeReceiverTChanged({required ReceiverT that });

Future<void> tokioNetUnixPipeReceiverTClose({required ReceiverT that });

Future<bool> tokioNetUnixPipeReceiverTHasChanged({required ReceiverT that });

Future<bool> tokioNetUnixPipeReceiverTIsClosed({required ReceiverT that });

Future<bool> tokioNetUnixPipeReceiverTIsEmpty({required ReceiverT that });

Future<bool> tokioNetUnixPipeReceiverTIsTerminated({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTLen({required ReceiverT that });

Future<void> tokioNetUnixPipeReceiverTMarkChanged({required ReceiverT that });

Future<void> tokioNetUnixPipeReceiverTMarkUnchanged({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTMaxCapacity({required ReceiverT that });

Future<PollOptionT> tokioNetUnixPipeReceiverTPollRecv({required ReceiverT that , required Context cx });

Future<PollUsize> tokioNetUnixPipeReceiverTPollRecvMany({required ReceiverT that , required Context cx , required VecT buffer , required BigInt limit });

Future<T> tokioNetUnixPipeReceiverTRecv({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTRecvMany({required ReceiverT that , required VecT buffer , required BigInt limit });

Future<ReceiverT> tokioNetUnixPipeReceiverTResubscribe({required ReceiverT that });

Future<bool> tokioNetUnixPipeReceiverTSameChannel({required ReceiverT that , required ReceiverT other });

Future<BigInt> tokioNetUnixPipeReceiverTSenderStrongCount({required ReceiverT that });

Future<BigInt> tokioNetUnixPipeReceiverTSenderWeakCount({required ReceiverT that });

Future<T> tokioNetUnixPipeReceiverTTryRecv({required ReceiverT that });

Future<Receiver> tokioNetUnixPipeReceiverFromFile({required File file });

Future<Receiver> tokioNetUnixPipeReceiverFromFileUnchecked({required File file });

Future<Receiver> tokioNetUnixPipeReceiverFromOwnedFd({required OwnedFd ownedFd });

Future<Receiver> tokioNetUnixPipeReceiverFromOwnedFdUnchecked({required OwnedFd ownedFd });

Future<OwnedFd> tokioNetUnixPipeReceiverIntoBlockingFd({required Receiver that });

Future<OwnedFd> tokioNetUnixPipeReceiverIntoNonblockingFd({required Receiver that });

Future<PollResult> tokioNetUnixPipeReceiverPollReadReady({required Receiver that , required Context cx });

Future<void> tokioNetUnixPipeReceiverReadable({required Receiver that });

Future<Ready> tokioNetUnixPipeReceiverReady({required Receiver that , required Interest interest });

Future<BigInt> tokioNetUnixPipeReceiverTryRead({required Receiver that , required U8 buf });

Future<BigInt> tokioNetUnixPipeReceiverTryReadVectored({required Receiver that , required IoSliceMut bufs });

Future<void> tokioTaskCoopRestoreOnPendingMadeProgress({required RestoreOnPending that });

AHashMapStringFacet seekstormSearchResultObjectAutoAccessorGetFacets({required ResultObject that });

String seekstormSearchResultObjectAutoAccessorGetOriginalQuery({required ResultObject that });

String seekstormSearchResultObjectAutoAccessorGetQuery({required ResultObject that });

List<String> seekstormSearchResultObjectAutoAccessorGetQueryTerms({required ResultObject that });

BigInt seekstormSearchResultObjectAutoAccessorGetResultCount({required ResultObject that });

BigInt seekstormSearchResultObjectAutoAccessorGetResultCountTotal({required ResultObject that });

List<Result> seekstormSearchResultObjectAutoAccessorGetResults({required ResultObject that });

List<String> seekstormSearchResultObjectAutoAccessorGetSuggestions({required ResultObject that });

void seekstormSearchResultObjectAutoAccessorSetFacets({required ResultObject that , required AHashMapStringFacet facets });

void seekstormSearchResultObjectAutoAccessorSetOriginalQuery({required ResultObject that , required String originalQuery });

void seekstormSearchResultObjectAutoAccessorSetQuery({required ResultObject that , required String query });

void seekstormSearchResultObjectAutoAccessorSetQueryTerms({required ResultObject that , required List<String> queryTerms });

void seekstormSearchResultObjectAutoAccessorSetResultCount({required ResultObject that , required BigInt resultCount });

void seekstormSearchResultObjectAutoAccessorSetResultCountTotal({required ResultObject that , required BigInt resultCountTotal });

void seekstormSearchResultObjectAutoAccessorSetResults({required ResultObject that , required List<Result> results });

void seekstormSearchResultObjectAutoAccessorSetSuggestions({required ResultObject that , required List<String> suggestions });

Future<ResultObject> seekstormSearchResultObjectDefault();

FacetValue seekstormSearchResultSortAutoAccessorGetBase({required ResultSort that });

String seekstormSearchResultSortAutoAccessorGetField({required ResultSort that });

SortOrder seekstormSearchResultSortAutoAccessorGetOrder({required ResultSort that });

void seekstormSearchResultSortAutoAccessorSetBase({required ResultSort that , required FacetValue base });

void seekstormSearchResultSortAutoAccessorSetField({required ResultSort that , required String field });

void seekstormSearchResultSortAutoAccessorSetOrder({required ResultSort that , required SortOrder order });

OwnedReadHalf tokioNetTcpReuniteErrorAutoAccessorGetField0({required ReuniteError that });

OwnedWriteHalf tokioNetTcpReuniteErrorAutoAccessorGetField1({required ReuniteError that });

void tokioNetTcpReuniteErrorAutoAccessorSetField0({required ReuniteError that , required OwnedReadHalf field0 });

void tokioNetTcpReuniteErrorAutoAccessorSetField1({required ReuniteError that , required OwnedWriteHalf field1 });

Future<BigInt> tokioRuntimeRuntimeMetricsGlobalQueueDepth({required RuntimeMetrics that });

Future<BigInt> tokioRuntimeRuntimeMetricsNumAliveTasks({required RuntimeMetrics that });

Future<BigInt> tokioRuntimeRuntimeMetricsNumWorkers({required RuntimeMetrics that });

Future<BigInt> tokioRuntimeRuntimeMetricsWorkerParkCount({required RuntimeMetrics that , required BigInt worker });

Future<BigInt> tokioRuntimeRuntimeMetricsWorkerParkUnparkCount({required RuntimeMetrics that , required BigInt worker });

Future<Duration> tokioRuntimeRuntimeMetricsWorkerTotalBusyDuration({required RuntimeMetrics that , required BigInt worker });

Future<EnterGuard> tokioRuntimeRuntimeEnter({required Runtime that });

Future<void> tokioRuntimeRuntimeHandle({required Runtime that });

Future<RuntimeMetrics> tokioRuntimeRuntimeMetrics({required Runtime that });

Future<Runtime> tokioRuntimeRuntimeNew();

Future<void> tokioRuntimeRuntimeShutdownBackground({required Runtime that });

double seekstormIndexSchemaFieldAutoAccessorGetBoost({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetCompletionSource({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetDictionarySource({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetFacet({required SchemaField that });

String seekstormIndexSchemaFieldAutoAccessorGetField({required SchemaField that });

FieldType seekstormIndexSchemaFieldAutoAccessorGetFieldType({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetIndexed({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetLongest({required SchemaField that });

bool seekstormIndexSchemaFieldAutoAccessorGetStored({required SchemaField that });

void seekstormIndexSchemaFieldAutoAccessorSetBoost({required SchemaField that , required double boost });

void seekstormIndexSchemaFieldAutoAccessorSetCompletionSource({required SchemaField that , required bool completionSource });

void seekstormIndexSchemaFieldAutoAccessorSetDictionarySource({required SchemaField that , required bool dictionarySource });

void seekstormIndexSchemaFieldAutoAccessorSetFacet({required SchemaField that , required bool facet });

void seekstormIndexSchemaFieldAutoAccessorSetField({required SchemaField that , required String field });

void seekstormIndexSchemaFieldAutoAccessorSetFieldType({required SchemaField that , required FieldType fieldType });

void seekstormIndexSchemaFieldAutoAccessorSetIndexed({required SchemaField that , required bool indexed });

void seekstormIndexSchemaFieldAutoAccessorSetLongest({required SchemaField that , required bool longest });

void seekstormIndexSchemaFieldAutoAccessorSetStored({required SchemaField that , required bool stored });

Future<SchemaField> seekstormIndexSchemaFieldNew({required String field , required bool stored , required bool indexed , required FieldType fieldType , required bool facet , required bool longest , required double boost , required bool dictionarySource , required bool completionSource });

Future<SemaphorePermit> tokioSyncSemaphoreAcquire({required Semaphore that });

Future<SemaphorePermit> tokioSyncSemaphoreAcquireMany({required Semaphore that , required int n });

Future<OwnedSemaphorePermit> tokioSyncSemaphoreAcquireManyOwned({required Semaphore that , required int n });

Future<OwnedSemaphorePermit> tokioSyncSemaphoreAcquireOwned({required Semaphore that });

Future<void> tokioSyncSemaphoreAddPermits({required Semaphore that , required BigInt n });

Future<BigInt> tokioSyncSemaphoreAvailablePermits({required Semaphore that });

Future<void> tokioSyncSemaphoreClose({required Semaphore that });

Future<Semaphore> tokioSyncSemaphoreConstNew({required BigInt permits });

Future<BigInt> tokioSyncSemaphoreForgetPermits({required Semaphore that , required BigInt n });

Future<bool> tokioSyncSemaphoreIsClosed({required Semaphore that });

Future<Semaphore> tokioSyncSemaphoreNew({required BigInt permits });

Future<SemaphorePermit> tokioSyncSemaphoreTryAcquire({required Semaphore that });

Future<SemaphorePermit> tokioSyncSemaphoreTryAcquireMany({required Semaphore that , required int n });

Future<OwnedSemaphorePermit> tokioSyncSemaphoreTryAcquireManyOwned({required Semaphore that , required int n });

Future<OwnedSemaphorePermit> tokioSyncSemaphoreTryAcquireOwned({required Semaphore that });

Future<void> tokioNetUnixPipeSenderTBlockingSend({required SenderT that , required T value });

Future<RefT> tokioNetUnixPipeSenderTBorrow({required SenderT that });

Future<BigInt> tokioNetUnixPipeSenderTCapacity({required SenderT that });

Future<void> tokioNetUnixPipeSenderTClosed({required SenderT that });

Future<SenderT> tokioNetUnixPipeSenderTDefault();

Future<WeakSenderT> tokioNetUnixPipeSenderTDowngrade({required SenderT that });

Future<bool> tokioNetUnixPipeSenderTIsClosed({required SenderT that });

Future<bool> tokioNetUnixPipeSenderTIsEmpty({required SenderT that });

Future<BigInt> tokioNetUnixPipeSenderTLen({required SenderT that });

Future<BigInt> tokioNetUnixPipeSenderTMaxCapacity({required SenderT that });

Future<SenderT> tokioNetUnixPipeSenderTNew({required BigInt capacity });

Future<Poll> tokioNetUnixPipeSenderTPollClosed({required SenderT that , required Context cx });

Future<BigInt> tokioNetUnixPipeSenderTReceiverCount({required SenderT that });

Future<PermitT> tokioNetUnixPipeSenderTReserve({required SenderT that });

Future<PermitIteratorT> tokioNetUnixPipeSenderTReserveMany({required SenderT that , required BigInt n });

Future<OwnedPermitT> tokioNetUnixPipeSenderTReserveOwned({required SenderT that });

Future<bool> tokioNetUnixPipeSenderTSameChannel({required SenderT that , required SenderT other });

Future<BigInt> tokioNetUnixPipeSenderTSend({required SenderT that , required T value });

Future<T> tokioNetUnixPipeSenderTSendReplace({required SenderT that , required T value });

Future<void> tokioNetUnixPipeSenderTSendTimeout({required SenderT that , required T value , required Duration timeout });

Future<BigInt> tokioNetUnixPipeSenderTSenderCount({required SenderT that });

Future<BigInt> tokioNetUnixPipeSenderTStrongCount({required SenderT that });

Future<ReceiverT> tokioNetUnixPipeSenderTSubscribe({required SenderT that });

Future<PermitT> tokioNetUnixPipeSenderTTryReserve({required SenderT that });

Future<PermitIteratorT> tokioNetUnixPipeSenderTTryReserveMany({required SenderT that , required BigInt n });

Future<OwnedPermitT> tokioNetUnixPipeSenderTTryReserveOwned({required SenderT that });

Future<void> tokioNetUnixPipeSenderTTrySend({required SenderT that , required T message });

Future<BigInt> tokioNetUnixPipeSenderTWeakCount({required SenderT that });

Future<Sender> tokioNetUnixPipeSenderFromFile({required File file });

Future<Sender> tokioNetUnixPipeSenderFromFileUnchecked({required File file });

Future<Sender> tokioNetUnixPipeSenderFromOwnedFd({required OwnedFd ownedFd });

Future<Sender> tokioNetUnixPipeSenderFromOwnedFdUnchecked({required OwnedFd ownedFd });

Future<OwnedFd> tokioNetUnixPipeSenderIntoBlockingFd({required Sender that });

Future<OwnedFd> tokioNetUnixPipeSenderIntoNonblockingFd({required Sender that });

Future<PollResult> tokioNetUnixPipeSenderPollWriteReady({required Sender that , required Context cx });

Future<Ready> tokioNetUnixPipeSenderReady({required Sender that , required Interest interest });

Future<BigInt> tokioNetUnixPipeSenderTryWrite({required Sender that , required List<int> buf });

Future<BigInt> tokioNetUnixPipeSenderTryWriteVectored({required Sender that , required List<IoSlice> buf });

Future<void> tokioNetUnixPipeSenderWritable({required Sender that });

Future<SignalKind> tokioSignalUnixSignalKindAlarm();

Future<CInt> tokioSignalUnixSignalKindAsRawValue({required SignalKind that });

Future<SignalKind> tokioSignalUnixSignalKindChild();

Future<SignalKind> tokioSignalUnixSignalKindFromRaw({required CInt signum });

Future<SignalKind> tokioSignalUnixSignalKindHangup();

Future<SignalKind> tokioSignalUnixSignalKindInfo();

Future<SignalKind> tokioSignalUnixSignalKindInterrupt();

Future<SignalKind> tokioSignalUnixSignalKindIo();

Future<SignalKind> tokioSignalUnixSignalKindPipe();

Future<SignalKind> tokioSignalUnixSignalKindQuit();

Future<SignalKind> tokioSignalUnixSignalKindTerminate();

Future<SignalKind> tokioSignalUnixSignalKindUserDefined1();

Future<SignalKind> tokioSignalUnixSignalKindUserDefined2();

Future<SignalKind> tokioSignalUnixSignalKindWindowChange();

Future<PollOption> tokioSignalUnixSignalPollRecv({required Signal that , required Context cx });

Future<void?> tokioSignalUnixSignalRecv({required Signal that });

Future<SimplexStream> tokioIoSimplexStreamNewUnsplit({required BigInt maxBufSize });

Future<Instant> tokioTimeSleepDeadline({required Sleep that });

Future<bool> tokioTimeSleepIsElapsed({required Sleep that });

Future<void> tokioTimeSleepReset({required Sleep that , required Instant deadline });

Future<Path?> tokioNetUnixSocketAddrAsPathname({required SocketAddr that });

Future<bool> tokioNetUnixSocketAddrIsUnnamed({required SocketAddr that });

Future<StopwordType> seekstormIndexStopwordTypeDefault();

Future<(TcpStream,SocketAddr)> tokioNetTcpListenerAccept({required TcpListener that });

Future<TcpListener> tokioNetTcpListenerFromStd({required TcpListener listener });

Future<TcpListener> tokioNetTcpListenerIntoStd({required TcpListener that });

Future<SocketAddr> tokioNetTcpListenerLocalAddr({required TcpListener that });

Future<PollResultTcpStreamSocketAddr> tokioNetTcpListenerPollAccept({required TcpListener that , required Context cx });

Future<void> tokioNetTcpListenerSetTtl({required TcpListener that , required int ttl });

Future<int> tokioNetTcpListenerTtl({required TcpListener that });

Future<void> tokioNetTcpSocketBind({required TcpSocket that , required SocketAddr addr });

Future<TcpStream> tokioNetTcpSocketConnect({required TcpSocket that , required SocketAddr addr });

Future<TcpSocket> tokioNetTcpSocketFromStdStream({required TcpStream stdStream });

Future<bool> tokioNetTcpSocketKeepalive({required TcpSocket that });

Future<Duration?> tokioNetTcpSocketLinger({required TcpSocket that });

Future<TcpListener> tokioNetTcpSocketListen({required TcpSocket that , required int backlog });

Future<SocketAddr> tokioNetTcpSocketLocalAddr({required TcpSocket that });

Future<TcpSocket> tokioNetTcpSocketNewV4();

Future<TcpSocket> tokioNetTcpSocketNewV6();

Future<bool> tokioNetTcpSocketNodelay({required TcpSocket that });

Future<int> tokioNetTcpSocketRecvBufferSize({required TcpSocket that });

Future<bool> tokioNetTcpSocketReuseaddr({required TcpSocket that });

Future<bool> tokioNetTcpSocketReuseport({required TcpSocket that });

Future<int> tokioNetTcpSocketSendBufferSize({required TcpSocket that });

Future<void> tokioNetTcpSocketSetKeepalive({required TcpSocket that , required bool keepalive });

Future<void> tokioNetTcpSocketSetLinger({required TcpSocket that , Duration? dur });

Future<void> tokioNetTcpSocketSetNodelay({required TcpSocket that , required bool nodelay });

Future<void> tokioNetTcpSocketSetRecvBufferSize({required TcpSocket that , required int size });

Future<void> tokioNetTcpSocketSetReuseaddr({required TcpSocket that , required bool reuseaddr });

Future<void> tokioNetTcpSocketSetReuseport({required TcpSocket that , required bool reuseport });

Future<void> tokioNetTcpSocketSetSendBufferSize({required TcpSocket that , required int size });

Future<void> tokioNetTcpSocketSetTclassV6({required TcpSocket that , required int tclass });

Future<void> tokioNetTcpSocketSetTos({required TcpSocket that , required int tos });

Future<void> tokioNetTcpSocketSetTosV4({required TcpSocket that , required int tos });

Future<Error?> tokioNetTcpSocketTakeError({required TcpSocket that });

Future<int> tokioNetTcpSocketTclassV6({required TcpSocket that });

Future<int> tokioNetTcpSocketTos({required TcpSocket that });

Future<int> tokioNetTcpSocketTosV4({required TcpSocket that });

Future<TcpStream> tokioNetTcpStreamFromStd({required TcpStream stream });

Future<(OwnedReadHalf,OwnedWriteHalf)> tokioNetTcpStreamIntoSplit({required TcpStream that });

Future<TcpStream> tokioNetTcpStreamIntoStd({required TcpStream that });

Future<Duration?> tokioNetTcpStreamLinger({required TcpStream that });

Future<SocketAddr> tokioNetTcpStreamLocalAddr({required TcpStream that });

Future<bool> tokioNetTcpStreamNodelay({required TcpStream that });

Future<BigInt> tokioNetTcpStreamPeek({required TcpStream that , required U8 buf });

Future<SocketAddr> tokioNetTcpStreamPeerAddr({required TcpStream that });

Future<PollResultUsize> tokioNetTcpStreamPollPeek({required TcpStream that , required Context cx , required ReadBuf buf });

Future<PollResult> tokioNetTcpStreamPollReadReady({required TcpStream that , required Context cx });

Future<PollResult> tokioNetTcpStreamPollWriteReady({required TcpStream that , required Context cx });

Future<void> tokioNetTcpStreamReadable({required TcpStream that });

Future<Ready> tokioNetTcpStreamReady({required TcpStream that , required Interest interest });

Future<void> tokioNetTcpStreamSetLinger({required TcpStream that , Duration? dur });

Future<void> tokioNetTcpStreamSetNodelay({required TcpStream that , required bool nodelay });

Future<void> tokioNetTcpStreamSetTtl({required TcpStream that , required int ttl });

Future<Error?> tokioNetTcpStreamTakeError({required TcpStream that });

Future<BigInt> tokioNetTcpStreamTryRead({required TcpStream that , required U8 buf });

Future<BigInt> tokioNetTcpStreamTryReadVectored({required TcpStream that , required IoSliceMut bufs });

Future<BigInt> tokioNetTcpStreamTryWrite({required TcpStream that , required List<int> buf });

Future<BigInt> tokioNetTcpStreamTryWriteVectored({required TcpStream that , required List<IoSlice> bufs });

Future<int> tokioNetTcpStreamTtl({required TcpStream that });

Future<void> tokioNetTcpStreamWritable({required TcpStream that });

Future<bool> tokioRuntimeTryCurrentErrorIsMissingContext({required TryCurrentError that });

Future<bool> tokioRuntimeTryCurrentErrorIsThreadLocalDestroyed({required TryCurrentError that });

Future<GidT> tokioNetUnixUCredGid({required UCred that });

Future<PidT?> tokioNetUnixUCredPid({required UCred that });

Future<UidT> tokioNetUnixUCredUid({required UCred that });

Future<bool> tokioNetUdpSocketBroadcast({required UdpSocket that });

Future<UdpSocket> tokioNetUdpSocketFromStd({required UdpSocket socket });

Future<UdpSocket> tokioNetUdpSocketIntoStd({required UdpSocket that });

Future<void> tokioNetUdpSocketJoinMulticastV4({required UdpSocket that , required Ipv4Addr multiaddr , required Ipv4Addr interface_ });

Future<void> tokioNetUdpSocketJoinMulticastV6({required UdpSocket that , required Ipv6Addr multiaddr , required int interface_ });

Future<void> tokioNetUdpSocketLeaveMulticastV4({required UdpSocket that , required Ipv4Addr multiaddr , required Ipv4Addr interface_ });

Future<void> tokioNetUdpSocketLeaveMulticastV6({required UdpSocket that , required Ipv6Addr multiaddr , required int interface_ });

Future<SocketAddr> tokioNetUdpSocketLocalAddr({required UdpSocket that });

Future<bool> tokioNetUdpSocketMulticastLoopV4({required UdpSocket that });

Future<bool> tokioNetUdpSocketMulticastLoopV6({required UdpSocket that });

Future<int> tokioNetUdpSocketMulticastTtlV4({required UdpSocket that });

Future<BigInt> tokioNetUdpSocketPeek({required UdpSocket that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUdpSocketPeekFrom({required UdpSocket that , required U8 buf });

Future<SocketAddr> tokioNetUdpSocketPeekSender({required UdpSocket that });

Future<SocketAddr> tokioNetUdpSocketPeerAddr({required UdpSocket that });

Future<PollResult> tokioNetUdpSocketPollPeek({required UdpSocket that , required Context cx , required ReadBuf buf });

Future<PollResultSocketAddr> tokioNetUdpSocketPollPeekFrom({required UdpSocket that , required Context cx , required ReadBuf buf });

Future<PollResultSocketAddr> tokioNetUdpSocketPollPeekSender({required UdpSocket that , required Context cx });

Future<PollResult> tokioNetUdpSocketPollRecv({required UdpSocket that , required Context cx , required ReadBuf buf });

Future<PollResultSocketAddr> tokioNetUdpSocketPollRecvFrom({required UdpSocket that , required Context cx , required ReadBuf buf });

Future<PollResult> tokioNetUdpSocketPollRecvReady({required UdpSocket that , required Context cx });

Future<PollResultUsize> tokioNetUdpSocketPollSend({required UdpSocket that , required Context cx , required List<int> buf });

Future<PollResult> tokioNetUdpSocketPollSendReady({required UdpSocket that , required Context cx });

Future<PollResultUsize> tokioNetUdpSocketPollSendTo({required UdpSocket that , required Context cx , required List<int> buf , required SocketAddr target });

Future<void> tokioNetUdpSocketReadable({required UdpSocket that });

Future<Ready> tokioNetUdpSocketReady({required UdpSocket that , required Interest interest });

Future<BigInt> tokioNetUdpSocketRecv({required UdpSocket that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUdpSocketRecvFrom({required UdpSocket that , required U8 buf });

Future<BigInt> tokioNetUdpSocketSend({required UdpSocket that , required List<int> buf });

Future<void> tokioNetUdpSocketSetBroadcast({required UdpSocket that , required bool on_ });

Future<void> tokioNetUdpSocketSetMulticastLoopV4({required UdpSocket that , required bool on_ });

Future<void> tokioNetUdpSocketSetMulticastLoopV6({required UdpSocket that , required bool on_ });

Future<void> tokioNetUdpSocketSetMulticastTtlV4({required UdpSocket that , required int ttl });

Future<void> tokioNetUdpSocketSetTclassV6({required UdpSocket that , required int tclass });

Future<void> tokioNetUdpSocketSetTos({required UdpSocket that , required int tos });

Future<void> tokioNetUdpSocketSetTosV4({required UdpSocket that , required int tos });

Future<void> tokioNetUdpSocketSetTtl({required UdpSocket that , required int ttl });

Future<Error?> tokioNetUdpSocketTakeError({required UdpSocket that });

Future<int> tokioNetUdpSocketTclassV6({required UdpSocket that });

Future<int> tokioNetUdpSocketTos({required UdpSocket that });

Future<int> tokioNetUdpSocketTosV4({required UdpSocket that });

Future<BigInt> tokioNetUdpSocketTryPeek({required UdpSocket that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUdpSocketTryPeekFrom({required UdpSocket that , required U8 buf });

Future<SocketAddr> tokioNetUdpSocketTryPeekSender({required UdpSocket that });

Future<BigInt> tokioNetUdpSocketTryRecv({required UdpSocket that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUdpSocketTryRecvFrom({required UdpSocket that , required U8 buf });

Future<BigInt> tokioNetUdpSocketTrySend({required UdpSocket that , required List<int> buf });

Future<BigInt> tokioNetUdpSocketTrySendTo({required UdpSocket that , required List<int> buf , required SocketAddr target });

Future<int> tokioNetUdpSocketTtl({required UdpSocket that });

Future<void> tokioNetUdpSocketWritable({required UdpSocket that });

Future<UnixDatagram> tokioNetUnixDatagramFromStd({required UnixDatagram datagram });

Future<UnixDatagram> tokioNetUnixDatagramIntoStd({required UnixDatagram that });

Future<SocketAddr> tokioNetUnixDatagramLocalAddr({required UnixDatagram that });

Future<(UnixDatagram,UnixDatagram)> tokioNetUnixDatagramPair();

Future<SocketAddr> tokioNetUnixDatagramPeerAddr({required UnixDatagram that });

Future<PollResult> tokioNetUnixDatagramPollRecv({required UnixDatagram that , required Context cx , required ReadBuf buf });

Future<PollResultSocketAddr> tokioNetUnixDatagramPollRecvFrom({required UnixDatagram that , required Context cx , required ReadBuf buf });

Future<PollResult> tokioNetUnixDatagramPollRecvReady({required UnixDatagram that , required Context cx });

Future<PollResultUsize> tokioNetUnixDatagramPollSend({required UnixDatagram that , required Context cx , required List<int> buf });

Future<PollResult> tokioNetUnixDatagramPollSendReady({required UnixDatagram that , required Context cx });

Future<void> tokioNetUnixDatagramReadable({required UnixDatagram that });

Future<Ready> tokioNetUnixDatagramReady({required UnixDatagram that , required Interest interest });

Future<BigInt> tokioNetUnixDatagramRecv({required UnixDatagram that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUnixDatagramRecvFrom({required UnixDatagram that , required U8 buf });

Future<BigInt> tokioNetUnixDatagramSend({required UnixDatagram that , required List<int> buf });

Future<void> tokioNetUnixDatagramShutdown({required UnixDatagram that , required Shutdown how });

Future<Error?> tokioNetUnixDatagramTakeError({required UnixDatagram that });

Future<BigInt> tokioNetUnixDatagramTryRecv({required UnixDatagram that , required U8 buf });

Future<(BigInt,SocketAddr)> tokioNetUnixDatagramTryRecvFrom({required UnixDatagram that , required U8 buf });

Future<BigInt> tokioNetUnixDatagramTrySend({required UnixDatagram that , required List<int> buf });

Future<UnixDatagram> tokioNetUnixDatagramUnbound();

Future<void> tokioNetUnixDatagramWritable({required UnixDatagram that });

Future<(UnixStream,SocketAddr)> tokioNetUnixListenerAccept({required UnixListener that });

Future<UnixListener> tokioNetUnixListenerFromStd({required UnixListener listener });

Future<UnixListener> tokioNetUnixListenerIntoStd({required UnixListener that });

Future<SocketAddr> tokioNetUnixListenerLocalAddr({required UnixListener that });

Future<PollResultUnixStreamSocketAddr> tokioNetUnixListenerPollAccept({required UnixListener that , required Context cx });

Future<Error?> tokioNetUnixListenerTakeError({required UnixListener that });

Future<UnixDatagram> tokioNetUnixSocketDatagram({required UnixSocket that });

Future<UnixListener> tokioNetUnixSocketListen({required UnixSocket that , required int backlog });

Future<UnixSocket> tokioNetUnixSocketNewDatagram();

Future<UnixSocket> tokioNetUnixSocketNewStream();

Future<UnixStream> tokioNetUnixStreamFromStd({required UnixStream stream });

Future<(OwnedReadHalf,OwnedWriteHalf)> tokioNetUnixStreamIntoSplit({required UnixStream that });

Future<UnixStream> tokioNetUnixStreamIntoStd({required UnixStream that });

Future<SocketAddr> tokioNetUnixStreamLocalAddr({required UnixStream that });

Future<(UnixStream,UnixStream)> tokioNetUnixStreamPair();

Future<SocketAddr> tokioNetUnixStreamPeerAddr({required UnixStream that });

Future<UCred> tokioNetUnixStreamPeerCred({required UnixStream that });

Future<PollResult> tokioNetUnixStreamPollReadReady({required UnixStream that , required Context cx });

Future<PollResult> tokioNetUnixStreamPollWriteReady({required UnixStream that , required Context cx });

Future<void> tokioNetUnixStreamReadable({required UnixStream that });

Future<Ready> tokioNetUnixStreamReady({required UnixStream that , required Interest interest });

Future<Error?> tokioNetUnixStreamTakeError({required UnixStream that });

Future<BigInt> tokioNetUnixStreamTryRead({required UnixStream that , required U8 buf });

Future<BigInt> tokioNetUnixStreamTryReadVectored({required UnixStream that , required IoSliceMut bufs });

Future<BigInt> tokioNetUnixStreamTryWrite({required UnixStream that , required List<int> buf });

Future<BigInt> tokioNetUnixStreamTryWriteVectored({required UnixStream that , required List<IoSlice> buf });

Future<void> tokioNetUnixStreamWritable({required UnixStream that });

Future<ValueType> seekstormIndexValueTypeDefault();

Future<void> tokioTimeAdvance({required Duration duration });

Future<CompressionType> seekstormIndexCompressionTypeDefault();

Future<void> tokioTaskCoopConsumeBudget();

Future<ArcIndex> seekstormIndexCreateIndex({required Path indexPath , required IndexMetaObject meta , required List<SchemaField> schema , required List<Synonym> synonyms , required BigInt segmentNumberBits1 , required bool mute , BigInt? forceShardNumber });

Future<void> tokioSignalCtrlC();

Future<Float64List> seekstormGeoSearchDecodeMorton2D({required BigInt code });

Future<DistanceField> seekstormIndexDistanceFieldDefault();

Future<(DuplexStream,DuplexStream)> tokioIoDuplex({required BigInt maxBufSize });

Future<Empty> tokioIoEmpty();

Future<BigInt> seekstormGeoSearchEncodeMorton2D({required List<double> point });

Future<double> seekstormGeoSearchEuclidianDistance({required List<double> point1 , required List<double> point2 , required DistanceUnit unit });

Future<FieldType> seekstormIndexFieldTypeDefault();

String crateApiSimpleGreet({required String name });

Future<bool> tokioTaskCoopHasBudgetRemaining();

Future<Highlight> seekstormHighlighterHighlightDefault();

Future<Highlighter> seekstormHighlighterHighlighter({required ArcIndex indexArc , required List<Highlight> highlights , required List<String> queryTermsVec });

Future<void> crateApiSimpleInitApp();

Future<Interval> tokioTimeInterval({required Duration period });

Future<Interval> tokioTimeIntervalAt({required Instant start , required Duration period });

Future<MissedTickBehavior> tokioTimeMissedTickBehaviorDefault();

Future<Ordering> seekstormGeoSearchMortonOrdering({required BigInt morton1 , required BigInt morton2 , required List<double> basePoint , required SortOrder order });

Future<NgramType> seekstormIndexNgramTypeDefault();

Future<ArcIndex> seekstormIndexOpenIndex({required Path indexPath , required bool mute });

Future<void> tokioTimePause();

Future<(Sender,Receiver)> tokioNetUnixPipePipe();

Future<RangeU64> seekstormGeoSearchPointDistanceToMortonRange({required List<double> point , required double distance , required DistanceUnit unit });

Future<Poll> tokioMacrosSupportPollBudgetAvailable({required Context cx });

Future<PollRestoreOnPending> tokioTaskCoopPollProceed({required Context cx });

Future<QueryType> seekstormSearchQueryTypeDefault();

Future<RangeType> seekstormSearchRangeTypeDefault();

Future<Repeat> tokioIoRepeat({required int byte });

Future<ResultType> seekstormSearchResultTypeDefault();

Future<void> tokioTimeResume();

Future<void> crateApiKeywordSearchSearchFnDeleteIndex({required SearchFn that });

Future<void> crateApiKeywordSearchSearchFnIngestPdfDir({required SearchFn that , required Path dirPath });

Future<SearchFn> crateApiKeywordSearchSearchFnNew({required SearchFn that });

Future<Signal> tokioSignalUnixSignal({required SignalKind kind });

Future<SimilarityType> seekstormIndexSimilarityTypeDefault();

Future<(ReadHalfSimplexStream,WriteHalfSimplexStream)> tokioIoSimplex({required BigInt maxBufSize });

Future<Sink> tokioIoSink();

Future<Sleep> tokioTimeSleep({required Duration duration });

Future<Sleep> tokioTimeSleepUntil({required Instant deadline });

Future<Stderr> tokioIoStderr();

Future<Stdin> tokioIoStdin();

Future<Stdout> tokioIoStdout();

Future<StemmerType> seekstormIndexStemmerTypeDefault();

Future<String> seekstormUtilsSubstring({required String source , required BigInt start , required BigInt length });

Future<int> tokioMacrosSupportThreadRngN({required int n });

Future<TokenizerType> seekstormIndexTokenizerTypeDefault();

Future<void> seekstormUtilsTruncate({required String source , required BigInt maxChars });

Future<void> seekstormIndexVersion();

Future<void> tokioTaskYieldNow();

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_AHashMapStringFacet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_AHashMapStringFacet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AHashMapStringFacetPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_AcquireError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_AcquireError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AcquireErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ArcIndex;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ArcIndex;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ArcIndexPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Barrier;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Barrier;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BarrierPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BarrierWaitResult;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BarrierWaitResult;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BarrierWaitResultPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Child;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Child;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ChildPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStderr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStderr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ChildStderrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStdin;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStdin;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ChildStdinPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStdout;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStdout;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ChildStdoutPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Command;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Command;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CommandPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Context;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Context;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ContextPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_DocumentItem;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_DocumentItem;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DocumentItemPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_DuplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_DuplexStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DuplexStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Empty;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Empty;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EmptyPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_EnterGuard;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_EnterGuard;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EnterGuardPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Error;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Error;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExitStatus;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExitStatus;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ExitStatusPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetField;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FacetFieldPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetFilter;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetFilter;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FacetFilterPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetValue;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetValue;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FacetValuePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_File;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_File;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FilePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FileType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FileType;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FileTypePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FillBufSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FillBufSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FillBufSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FlushSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FlushSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FlushSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FrequentwordType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FrequentwordType;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FrequentwordTypePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Handle;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Handle;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_HandlePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Highlighter;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Highlighter;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_HighlighterPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Id;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Id;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IdPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Index;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Index;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IndexPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IndexMapStringVecStringUsize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IndexMapStringVecStringUsize;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IndexMapStringVecStringUsizePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IndexMetaObject;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IndexMetaObject;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IndexMetaObjectPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Instant;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Instant;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_InstantPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Interest;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Interest;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_InterestPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Interval;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Interval;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IntervalPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IoSliceMut;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IoSliceMut;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IoSliceMutPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IoSlice;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IoSlice;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_IoSlicePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ipv4Addr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ipv4Addr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Ipv4AddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ipv6Addr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ipv6Addr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Ipv6AddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LinesSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LinesSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_LinesSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LocalEnterGuard;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LocalEnterGuard;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_LocalEnterGuardPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LocalSet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LocalSet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_LocalSetPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MinMaxField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MinMaxField;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MinMaxFieldPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MinMaxFieldJson;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MinMaxFieldJson;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MinMaxFieldJsonPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Notified;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Notified;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NotifiedPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Notify;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Notify;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NotifyPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OpenOptions;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OpenOptions;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OpenOptionsPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ordering;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ordering;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OrderingPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedFd;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedFd;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedFdPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedNotified;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedNotified;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedNotifiedPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedPermitT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedPermitT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedPermitTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedReadHalf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedReadHalf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedReadHalfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedSemaphorePermit;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedSemaphorePermit;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedSemaphorePermitPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedWriteHalf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedWriteHalf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OwnedWriteHalfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Path;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Path;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PathPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PdfDocument;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PdfDocument;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PdfDocumentPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PermitIteratorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PermitIteratorT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PermitIteratorTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PermitT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PermitT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PermitTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Poll;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Poll;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollInstant;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollInstant;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollInstantPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollOption;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollOption;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollOptionPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollOptionT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollOptionT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollOptionTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollRestoreOnPending;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollRestoreOnPending;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollRestoreOnPendingPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResult;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResult;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollResultPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultSocketAddr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollResultSocketAddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultTcpStreamSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultTcpStreamSocketAddr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollResultTcpStreamSocketAddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultUnixStreamSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultUnixStreamSocketAddr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollResultUnixStreamSocketAddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultUsize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultUsize;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollResultUsizePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollUsize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollUsize;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PollUsizePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_QueryFacet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_QueryFacet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_QueryFacetPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_QueryRewriting;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_QueryRewriting;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_QueryRewritingPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ranges;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ranges;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RangesPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RangeU64;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RangeU64;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RangeU64Ptr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadBuf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadBuf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadBufPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadF32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadF32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadF64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadF64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadHalfSimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadHalfSimplexStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadHalfSimplexStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI128LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI128LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI128LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI128MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI128MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI128MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI16LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI16LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI16LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI16MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI16MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI16MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI8MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI8MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadI8MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU128LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU128LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU128LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU128MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU128MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU128MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU16LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU16LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU16LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU16MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU16MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU16MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU8MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU8MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadU8MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ready;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ready;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReadyPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Receiver;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Receiver;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReceiverPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReceiverT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReceiverT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReceiverTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RecvError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RecvError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RecvErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RefT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RefT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RefTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Repeat;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Repeat;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RepeatPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RestoreOnPending;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RestoreOnPending;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RestoreOnPendingPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Result;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Result;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ResultPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ResultObject;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ResultObject;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ResultObjectPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ResultSort;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ResultSort;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ResultSortPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReuniteError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReuniteError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ReuniteErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Runtime;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Runtime;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RuntimePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RuntimeMetrics;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RuntimeMetrics;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RuntimeMetricsPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SchemaField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SchemaField;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SchemaFieldPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SeekFrom;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SeekFrom;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SeekFromPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SeekSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SeekSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SeekSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Semaphore;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Semaphore;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SemaphorePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SemaphorePermit;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SemaphorePermit;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SemaphorePermitPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SendErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendErrorT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SendErrorTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendTimeoutErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendTimeoutErrorT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SendTimeoutErrorTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sender;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sender;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SenderPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SenderT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SenderT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SenderTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Shutdown;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Shutdown;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ShutdownPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ShutdownSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ShutdownSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ShutdownSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Signal;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Signal;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SignalPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SignalKind;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SignalKind;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SignalKindPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SimplexStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SimplexStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sink;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sink;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SinkPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sleep;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sleep;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SleepPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SocketAddr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SocketAddrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SplitSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SplitSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SplitSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_StdCommand;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_StdCommand;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StdCommandPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stderr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stderr;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StderrPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stdin;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stdin;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StdinPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stdout;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stdout;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StdoutPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_StopwordType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_StopwordType;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StopwordTypePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TakeSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TakeSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TakeSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpListener;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpListener;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TcpListenerPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpSocket;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TcpSocketPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TcpStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TryCurrentError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TryCurrentError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TryCurrentErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TryRecvError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TryRecvError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TryRecvErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendError;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TrySendErrorPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendErrorSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendErrorSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TrySendErrorSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendErrorT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TrySendErrorTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UCred;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UCred;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UCredPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UdpSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UdpSocket;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UdpSocketPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixDatagram;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixDatagram;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UnixDatagramPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixListener;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixListener;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UnixListenerPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixSocket;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UnixSocketPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UnixStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ValuePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ValueType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ValueType;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ValueTypePtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_VecT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_VecT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_VecTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WeakSenderT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WeakSenderT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WeakSenderTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteF32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteF32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteF64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteF64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteHalfSimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteHalfSimplexStream;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteHalfSimplexStreamPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI128LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI128LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI128LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI128MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI128MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI128MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI16LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI16LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI16LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI16MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI16MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI16MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI8MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI8MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteI8MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU128LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU128LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU128LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU128MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU128MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU128MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU16LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU16LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU16LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU16MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU16MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU16MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU32LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU32LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU32LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU32MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU32MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU32MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU64LeMutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU64LeMutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU64LeMutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU64MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU64MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU64MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU8MutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU8MutSelf;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WriteU8MutSelfPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_CInt;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_CInt;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CIntPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_GidT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_GidT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GidTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PidT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PidT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PidTPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_U8;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_U8;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_U8Ptr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UidT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UidT;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UidTPtr;


                }
                

                class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
                  RustLibApiImpl({
                    required super.handler,
                    required super.wire,
                    required super.generalizedFrbRustBinding,
                    required super.portManager,
                  });

                  @override Future<bool> tokioSyncBarrierWaitResultIsLeader({required BarrierWaitResult that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncBarrierWaitResultIsLeaderConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncBarrierWaitResultIsLeaderConstMeta => const TaskConstMeta(
            debugName: "BarrierWaitResult_is_leader",
            argNames: ["that"],
        );
        

@override Future<Barrier> tokioSyncBarrierNew({required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncBarrierNewConstMeta,
            argValues: [n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncBarrierNewConstMeta => const TaskConstMeta(
            debugName: "Barrier_new",
            argNames: ["n"],
        );
        

@override Future<BarrierWaitResult> tokioSyncBarrierWait({required Barrier that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncBarrierWaitConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncBarrierWaitConstMeta => const TaskConstMeta(
            debugName: "Barrier_wait",
            argNames: ["that"],
        );
        

@override Future<ChildStderr> tokioProcessChildStderrFromStd({required ChildStderr inner })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(inner, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStderrFromStdConstMeta,
            argValues: [inner],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStderrFromStdConstMeta => const TaskConstMeta(
            debugName: "ChildStderr_from_std",
            argNames: ["inner"],
        );
        

@override Future<OwnedFd> tokioProcessChildStderrIntoOwnedFd({required ChildStderr that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStderrIntoOwnedFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStderrIntoOwnedFdConstMeta => const TaskConstMeta(
            debugName: "ChildStderr_into_owned_fd",
            argNames: ["that"],
        );
        

@override Future<ChildStdin> tokioProcessChildStdinFromStd({required ChildStdin inner })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(inner, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStdinFromStdConstMeta,
            argValues: [inner],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStdinFromStdConstMeta => const TaskConstMeta(
            debugName: "ChildStdin_from_std",
            argNames: ["inner"],
        );
        

@override Future<OwnedFd> tokioProcessChildStdinIntoOwnedFd({required ChildStdin that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStdinIntoOwnedFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStdinIntoOwnedFdConstMeta => const TaskConstMeta(
            debugName: "ChildStdin_into_owned_fd",
            argNames: ["that"],
        );
        

@override Future<ChildStdout> tokioProcessChildStdoutFromStd({required ChildStdout inner })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(inner, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStdoutFromStdConstMeta,
            argValues: [inner],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStdoutFromStdConstMeta => const TaskConstMeta(
            debugName: "ChildStdout_from_std",
            argNames: ["inner"],
        );
        

@override Future<OwnedFd> tokioProcessChildStdoutIntoOwnedFd({required ChildStdout that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStdoutIntoOwnedFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStdoutIntoOwnedFdConstMeta => const TaskConstMeta(
            debugName: "ChildStdout_into_owned_fd",
            argNames: ["that"],
        );
        

@override ChildStderr? tokioProcessChildAutoAccessorGetStderr({required Child that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorGetStderrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorGetStderrConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_get_stderr",
            argNames: ["that"],
        );
        

@override ChildStdin? tokioProcessChildAutoAccessorGetStdin({required Child that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorGetStdinConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorGetStdinConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_get_stdin",
            argNames: ["that"],
        );
        

@override ChildStdout? tokioProcessChildAutoAccessorGetStdout({required Child that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorGetStdoutConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorGetStdoutConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_get_stdout",
            argNames: ["that"],
        );
        

@override void tokioProcessChildAutoAccessorSetStderr({required Child that , ChildStderr? stderr })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(stderr, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorSetStderrConstMeta,
            argValues: [that, stderr],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorSetStderrConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_set_stderr",
            argNames: ["that", "stderr"],
        );
        

@override void tokioProcessChildAutoAccessorSetStdin({required Child that , ChildStdin? stdin })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(stdin, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorSetStdinConstMeta,
            argValues: [that, stdin],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorSetStdinConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_set_stdin",
            argNames: ["that", "stdin"],
        );
        

@override void tokioProcessChildAutoAccessorSetStdout({required Child that , ChildStdout? stdout })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(stdout, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildAutoAccessorSetStdoutConstMeta,
            argValues: [that, stdout],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildAutoAccessorSetStdoutConstMeta => const TaskConstMeta(
            debugName: "Child_auto_accessor_set_stdout",
            argNames: ["that", "stdout"],
        );
        

@override Future<int?> tokioProcessChildId({required Child that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessChildIdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildIdConstMeta => const TaskConstMeta(
            debugName: "Child_id",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessChildKill({required Child that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildKillConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildKillConstMeta => const TaskConstMeta(
            debugName: "Child_kill",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessChildStartKill({required Child that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildStartKillConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildStartKillConstMeta => const TaskConstMeta(
            debugName: "Child_start_kill",
            argNames: ["that"],
        );
        

@override Future<ExitStatus?> tokioProcessChildTryWait({required Child that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildTryWaitConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildTryWaitConstMeta => const TaskConstMeta(
            debugName: "Child_try_wait",
            argNames: ["that"],
        );
        

@override Future<ExitStatus> tokioProcessChildWait({required Child that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessChildWaitConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessChildWaitConstMeta => const TaskConstMeta(
            debugName: "Child_wait",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandAsStd({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandAsStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandAsStdConstMeta => const TaskConstMeta(
            debugName: "Command_as_std",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandAsStdMut({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandAsStdMutConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandAsStdMutConstMeta => const TaskConstMeta(
            debugName: "Command_as_std_mut",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandEnvClear({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandEnvClearConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandEnvClearConstMeta => const TaskConstMeta(
            debugName: "Command_env_clear",
            argNames: ["that"],
        );
        

@override Future<bool> tokioProcessCommandGetKillOnDrop({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandGetKillOnDropConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandGetKillOnDropConstMeta => const TaskConstMeta(
            debugName: "Command_get_kill_on_drop",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandGid({required Command that , required int id })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
sse_encode_u_32(id, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandGidConstMeta,
            argValues: [that, id],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandGidConstMeta => const TaskConstMeta(
            debugName: "Command_gid",
            argNames: ["that", "id"],
        );
        

@override Future<StdCommand> tokioProcessCommandIntoStd({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandIntoStdConstMeta => const TaskConstMeta(
            debugName: "Command_into_std",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandKillOnDrop({required Command that , required bool killOnDrop })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
sse_encode_bool(killOnDrop, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandKillOnDropConstMeta,
            argValues: [that, killOnDrop],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandKillOnDropConstMeta => const TaskConstMeta(
            debugName: "Command_kill_on_drop",
            argNames: ["that", "killOnDrop"],
        );
        

@override Future<void> tokioProcessCommandProcessGroup({required Command that , required int pgroup })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
sse_encode_i_32(pgroup, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandProcessGroupConstMeta,
            argValues: [that, pgroup],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandProcessGroupConstMeta => const TaskConstMeta(
            debugName: "Command_process_group",
            argNames: ["that", "pgroup"],
        );
        

@override Future<Child> tokioProcessCommandSpawn({required Command that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioProcessCommandSpawnConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandSpawnConstMeta => const TaskConstMeta(
            debugName: "Command_spawn",
            argNames: ["that"],
        );
        

@override Future<void> tokioProcessCommandUid({required Command that , required int id })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(that, serializer);
sse_encode_u_32(id, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioProcessCommandUidConstMeta,
            argValues: [that, id],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioProcessCommandUidConstMeta => const TaskConstMeta(
            debugName: "Command_uid",
            argNames: ["that", "id"],
        );
        

@override Future<Error> tokioTimeErrorErrorAtCapacity()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorAtCapacityConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorAtCapacityConstMeta => const TaskConstMeta(
            debugName: "Error_at_capacity",
            argNames: [],
        );
        

@override Future<Error> tokioTimeErrorErrorInvalid()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorInvalidConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorInvalidConstMeta => const TaskConstMeta(
            debugName: "Error_invalid",
            argNames: [],
        );
        

@override Future<bool> tokioTimeErrorErrorIsAtCapacity({required Error that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorIsAtCapacityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorIsAtCapacityConstMeta => const TaskConstMeta(
            debugName: "Error_is_at_capacity",
            argNames: ["that"],
        );
        

@override Future<bool> tokioTimeErrorErrorIsInvalid({required Error that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorIsInvalidConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorIsInvalidConstMeta => const TaskConstMeta(
            debugName: "Error_is_invalid",
            argNames: ["that"],
        );
        

@override Future<bool> tokioTimeErrorErrorIsShutdown({required Error that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorIsShutdownConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorIsShutdownConstMeta => const TaskConstMeta(
            debugName: "Error_is_shutdown",
            argNames: ["that"],
        );
        

@override Future<Error> tokioTimeErrorErrorShutdown()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeErrorErrorShutdownConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeErrorErrorShutdownConstMeta => const TaskConstMeta(
            debugName: "Error_shutdown",
            argNames: [],
        );
        

@override ValueType seekstormIndexFacetFieldAutoAccessorGetMax({required FacetField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorGetMaxConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorGetMaxConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_get_max",
            argNames: ["that"],
        );
        

@override ValueType seekstormIndexFacetFieldAutoAccessorGetMin({required FacetField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorGetMinConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorGetMinConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_get_min",
            argNames: ["that"],
        );
        

@override String seekstormIndexFacetFieldAutoAccessorGetName({required FacetField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorGetNameConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorGetNameConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_get_name",
            argNames: ["that"],
        );
        

@override IndexMapStringVecStringUsize seekstormIndexFacetFieldAutoAccessorGetValues({required FacetField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorGetValuesConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorGetValuesConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_get_values",
            argNames: ["that"],
        );
        

@override void seekstormIndexFacetFieldAutoAccessorSetMax({required FacetField that , required ValueType max })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(max, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorSetMaxConstMeta,
            argValues: [that, max],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorSetMaxConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_set_max",
            argNames: ["that", "max"],
        );
        

@override void seekstormIndexFacetFieldAutoAccessorSetMin({required FacetField that , required ValueType min })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(min, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorSetMinConstMeta,
            argValues: [that, min],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorSetMinConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_set_min",
            argNames: ["that", "min"],
        );
        

@override void seekstormIndexFacetFieldAutoAccessorSetName({required FacetField that , required String name })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
sse_encode_String(name, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorSetNameConstMeta,
            argValues: [that, name],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorSetNameConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_set_name",
            argNames: ["that", "name"],
        );
        

@override void seekstormIndexFacetFieldAutoAccessorSetValues({required FacetField that , required IndexMapStringVecStringUsize values })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(values, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldAutoAccessorSetValuesConstMeta,
            argValues: [that, values],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldAutoAccessorSetValuesConstMeta => const TaskConstMeta(
            debugName: "FacetField_auto_accessor_set_values",
            argNames: ["that", "values"],
        );
        

@override Future<FacetField> seekstormIndexFacetFieldDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFacetFieldDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFacetFieldDefaultConstMeta => const TaskConstMeta(
            debugName: "FacetField_default",
            argNames: [],
        );
        

@override Future<FrequentwordType> seekstormIndexFrequentwordTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFrequentwordTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFrequentwordTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "FrequentwordType_default",
            argNames: [],
        );
        

@override Future<Handle> tokioRuntimeHandleCurrent()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleCurrentConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleCurrentConstMeta => const TaskConstMeta(
            debugName: "Handle_current",
            argNames: [],
        );
        

@override Future<Handle> tokioRuntimeHandleDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleDefaultConstMeta => const TaskConstMeta(
            debugName: "Handle_default",
            argNames: [],
        );
        

@override Future<EnterGuard> tokioRuntimeHandleEnter({required Handle that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleEnterConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleEnterConstMeta => const TaskConstMeta(
            debugName: "Handle_enter",
            argNames: ["that"],
        );
        

@override Future<Id> tokioRuntimeHandleId({required Handle that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleIdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleIdConstMeta => const TaskConstMeta(
            debugName: "Handle_id",
            argNames: ["that"],
        );
        

@override Future<RuntimeMetrics> tokioRuntimeHandleMetrics({required Handle that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleMetricsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleMetricsConstMeta => const TaskConstMeta(
            debugName: "Handle_metrics",
            argNames: ["that"],
        );
        

@override Future<RuntimeFlavor> tokioRuntimeHandleRuntimeFlavor({required Handle that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_runtime_flavor,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeHandleRuntimeFlavorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleRuntimeFlavorConstMeta => const TaskConstMeta(
            debugName: "Handle_runtime_flavor",
            argNames: ["that"],
        );
        

@override Future<Handle> tokioRuntimeHandleTryCurrent()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError,
        )
        ,
            constMeta: kTokioRuntimeHandleTryCurrentConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeHandleTryCurrentConstMeta => const TaskConstMeta(
            debugName: "Handle_try_current",
            argNames: [],
        );
        

@override AccessType seekstormIndexIndexMetaObjectAutoAccessorGetAccessType({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_access_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetAccessTypeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetAccessTypeConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_access_type",
            argNames: ["that"],
        );
        

@override FrequentwordType seekstormIndexIndexMetaObjectAutoAccessorGetFrequentWords({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetFrequentWordsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetFrequentWordsConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_frequent_words",
            argNames: ["that"],
        );
        

@override BigInt seekstormIndexIndexMetaObjectAutoAccessorGetId({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetIdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetIdConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_id",
            argNames: ["that"],
        );
        

@override String seekstormIndexIndexMetaObjectAutoAccessorGetName({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetNameConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetNameConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_name",
            argNames: ["that"],
        );
        

@override int seekstormIndexIndexMetaObjectAutoAccessorGetNgramIndexing({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_8,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetNgramIndexingConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetNgramIndexingConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_ngram_indexing",
            argNames: ["that"],
        );
        

@override QueryCompletion? seekstormIndexIndexMetaObjectAutoAccessorGetQueryCompletion({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_query_completion,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetQueryCompletionConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetQueryCompletionConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_query_completion",
            argNames: ["that"],
        );
        

@override SimilarityType seekstormIndexIndexMetaObjectAutoAccessorGetSimilarity({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_similarity_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetSimilarityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetSimilarityConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_similarity",
            argNames: ["that"],
        );
        

@override SpellingCorrection? seekstormIndexIndexMetaObjectAutoAccessorGetSpellingCorrection({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_spelling_correction,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetSpellingCorrectionConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetSpellingCorrectionConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_spelling_correction",
            argNames: ["that"],
        );
        

@override StemmerType seekstormIndexIndexMetaObjectAutoAccessorGetStemmer({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_stemmer_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetStemmerConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetStemmerConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_stemmer",
            argNames: ["that"],
        );
        

@override StopwordType seekstormIndexIndexMetaObjectAutoAccessorGetStopWords({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetStopWordsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetStopWordsConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_stop_words",
            argNames: ["that"],
        );
        

@override TokenizerType seekstormIndexIndexMetaObjectAutoAccessorGetTokenizer({required IndexMetaObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_tokenizer_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorGetTokenizerConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorGetTokenizerConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_get_tokenizer",
            argNames: ["that"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetAccessType({required IndexMetaObject that , required AccessType accessType })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_access_type(accessType, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetAccessTypeConstMeta,
            argValues: [that, accessType],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetAccessTypeConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_access_type",
            argNames: ["that", "accessType"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetFrequentWords({required IndexMetaObject that , required FrequentwordType frequentWords })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(frequentWords, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetFrequentWordsConstMeta,
            argValues: [that, frequentWords],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetFrequentWordsConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_frequent_words",
            argNames: ["that", "frequentWords"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetId({required IndexMetaObject that , required BigInt id })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_u_64(id, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetIdConstMeta,
            argValues: [that, id],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetIdConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_id",
            argNames: ["that", "id"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetName({required IndexMetaObject that , required String name })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_String(name, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetNameConstMeta,
            argValues: [that, name],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetNameConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_name",
            argNames: ["that", "name"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetNgramIndexing({required IndexMetaObject that , required int ngramIndexing })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_u_8(ngramIndexing, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetNgramIndexingConstMeta,
            argValues: [that, ngramIndexing],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetNgramIndexingConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_ngram_indexing",
            argNames: ["that", "ngramIndexing"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetQueryCompletion({required IndexMetaObject that , QueryCompletion? queryCompletion })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_opt_box_autoadd_query_completion(queryCompletion, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetQueryCompletionConstMeta,
            argValues: [that, queryCompletion],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetQueryCompletionConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_query_completion",
            argNames: ["that", "queryCompletion"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetSimilarity({required IndexMetaObject that , required SimilarityType similarity })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_similarity_type(similarity, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetSimilarityConstMeta,
            argValues: [that, similarity],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetSimilarityConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_similarity",
            argNames: ["that", "similarity"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetSpellingCorrection({required IndexMetaObject that , SpellingCorrection? spellingCorrection })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_opt_box_autoadd_spelling_correction(spellingCorrection, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetSpellingCorrectionConstMeta,
            argValues: [that, spellingCorrection],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetSpellingCorrectionConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_spelling_correction",
            argNames: ["that", "spellingCorrection"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetStemmer({required IndexMetaObject that , required StemmerType stemmer })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_stemmer_type(stemmer, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetStemmerConstMeta,
            argValues: [that, stemmer],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetStemmerConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_stemmer",
            argNames: ["that", "stemmer"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetStopWords({required IndexMetaObject that , required StopwordType stopWords })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(stopWords, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetStopWordsConstMeta,
            argValues: [that, stopWords],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetStopWordsConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_stop_words",
            argNames: ["that", "stopWords"],
        );
        

@override void seekstormIndexIndexMetaObjectAutoAccessorSetTokenizer({required IndexMetaObject that , required TokenizerType tokenizer })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(that, serializer);
sse_encode_tokenizer_type(tokenizer, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexMetaObjectAutoAccessorSetTokenizerConstMeta,
            argValues: [that, tokenizer],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexMetaObjectAutoAccessorSetTokenizerConstMeta => const TaskConstMeta(
            debugName: "IndexMetaObject_auto_accessor_set_tokenizer",
            argNames: ["that", "tokenizer"],
        );
        

@override Future<BigInt> seekstormIndexIndexAddSynonyms({required Index that , required List<Synonym> synonyms })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_list_synonym(synonyms, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexIndexAddSynonymsConstMeta,
            argValues: [that, synonyms],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAddSynonymsConstMeta => const TaskConstMeta(
            debugName: "Index_add_synonyms",
            argNames: ["that", "synonyms"],
        );
        

@override int seekstormIndexIndexAutoAccessorGetIndexFormatVersionMajor({required Index that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_16,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorGetIndexFormatVersionMajorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorGetIndexFormatVersionMajorConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_get_index_format_version_major",
            argNames: ["that"],
        );
        

@override int seekstormIndexIndexAutoAccessorGetIndexFormatVersionMinor({required Index that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_16,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorGetIndexFormatVersionMinorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorGetIndexFormatVersionMinorConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_get_index_format_version_minor",
            argNames: ["that"],
        );
        

@override IndexMetaObject seekstormIndexIndexAutoAccessorGetMeta({required Index that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorGetMetaConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorGetMetaConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_get_meta",
            argNames: ["that"],
        );
        

@override Map<String, SchemaField> seekstormIndexIndexAutoAccessorGetSchemaMap({required Index that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField_None,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorGetSchemaMapConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorGetSchemaMapConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_get_schema_map",
            argNames: ["that"],
        );
        

@override List<String> seekstormIndexIndexAutoAccessorGetStoredFieldNames({required Index that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorGetStoredFieldNamesConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorGetStoredFieldNamesConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_get_stored_field_names",
            argNames: ["that"],
        );
        

@override void seekstormIndexIndexAutoAccessorSetIndexFormatVersionMajor({required Index that , required int indexFormatVersionMajor })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_u_16(indexFormatVersionMajor, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorSetIndexFormatVersionMajorConstMeta,
            argValues: [that, indexFormatVersionMajor],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorSetIndexFormatVersionMajorConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_set_index_format_version_major",
            argNames: ["that", "indexFormatVersionMajor"],
        );
        

@override void seekstormIndexIndexAutoAccessorSetIndexFormatVersionMinor({required Index that , required int indexFormatVersionMinor })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_u_16(indexFormatVersionMinor, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorSetIndexFormatVersionMinorConstMeta,
            argValues: [that, indexFormatVersionMinor],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorSetIndexFormatVersionMinorConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_set_index_format_version_minor",
            argNames: ["that", "indexFormatVersionMinor"],
        );
        

@override void seekstormIndexIndexAutoAccessorSetMeta({required Index that , required IndexMetaObject meta })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(meta, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 84)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorSetMetaConstMeta,
            argValues: [that, meta],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorSetMetaConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_set_meta",
            argNames: ["that", "meta"],
        );
        

@override void seekstormIndexIndexAutoAccessorSetSchemaMap({required Index that , required Map<String, SchemaField> schemaMap })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField_None(schemaMap, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 85)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorSetSchemaMapConstMeta,
            argValues: [that, schemaMap],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorSetSchemaMapConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_set_schema_map",
            argNames: ["that", "schemaMap"],
        );
        

@override void seekstormIndexIndexAutoAccessorSetStoredFieldNames({required Index that , required List<String> storedFieldNames })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_list_String(storedFieldNames, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 86)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexAutoAccessorSetStoredFieldNamesConstMeta,
            argValues: [that, storedFieldNames],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexAutoAccessorSetStoredFieldNamesConstMeta => const TaskConstMeta(
            debugName: "Index_auto_accessor_set_stored_field_names",
            argNames: ["that", "storedFieldNames"],
        );
        

@override Future<void> seekstormIndexIndexClearIndex({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 87, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexClearIndexConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexClearIndexConstMeta => const TaskConstMeta(
            debugName: "Index_clear_index",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexCommittedDocCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 88, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexCommittedDocCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexCommittedDocCountConstMeta => const TaskConstMeta(
            debugName: "Index_committed_doc_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexCurrentDocCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 89, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexCurrentDocCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexCurrentDocCountConstMeta => const TaskConstMeta(
            debugName: "Index_current_doc_count",
            argNames: ["that"],
        );
        

@override Future<void> seekstormIndexIndexDeleteIndex({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 90, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexDeleteIndexConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexDeleteIndexConstMeta => const TaskConstMeta(
            debugName: "Index_delete_index",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexFacetsCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 91, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexFacetsCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexFacetsCountConstMeta => const TaskConstMeta(
            debugName: "Index_facets_count",
            argNames: ["that"],
        );
        

@override Future<Map<String, Value>> seekstormIndexIndexGetDocument({required Index that , required BigInt docId , required bool includeUncommited , Highlighter? highlighterOption , required Set<String> fields , required List<DistanceField> distanceFields })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_usize(docId, serializer);
sse_encode_bool(includeUncommited, serializer);
sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(highlighterOption, serializer);
sse_encode_Set_String_None(fields, serializer);
sse_encode_list_distance_field(distanceFields, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 92, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexIndexGetDocumentConstMeta,
            argValues: [that, docId, includeUncommited, highlighterOption, fields, distanceFields],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexGetDocumentConstMeta => const TaskConstMeta(
            debugName: "Index_get_document",
            argNames: ["that", "docId", "includeUncommited", "highlighterOption", "fields", "distanceFields"],
        );
        

@override Future<FacetValue> seekstormIndexIndexGetFacetValue({required Index that , required String field , required BigInt docId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_String(field, serializer);
sse_encode_usize(docId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 93, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexGetFacetValueConstMeta,
            argValues: [that, field, docId],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexGetFacetValueConstMeta => const TaskConstMeta(
            debugName: "Index_get_facet_value",
            argNames: ["that", "field", "docId"],
        );
        

@override Future<Uint8List> seekstormIndexIndexGetFile({required Index that , required BigInt docId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_usize(docId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 94, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexIndexGetFileConstMeta,
            argValues: [that, docId],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexGetFileConstMeta => const TaskConstMeta(
            debugName: "Index_get_file",
            argNames: ["that", "docId"],
        );
        

@override Future<AHashMapStringFacet?> seekstormIndexIndexGetIndexStringFacets({required Index that , required List<QueryFacet> queryFacets })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(queryFacets, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 95, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexGetIndexStringFacetsConstMeta,
            argValues: [that, queryFacets],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexGetIndexStringFacetsConstMeta => const TaskConstMeta(
            debugName: "Index_get_index_string_facets",
            argNames: ["that", "queryFacets"],
        );
        

@override Future<List<Synonym>> seekstormIndexIndexGetSynonyms({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 96, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_synonym,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexIndexGetSynonymsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexGetSynonymsConstMeta => const TaskConstMeta(
            debugName: "Index_get_synonyms",
            argNames: ["that"],
        );
        

@override Future<Map<String, MinMaxFieldJson>> seekstormIndexIndexIndexFacetsMinmax({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson_None,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexIndexFacetsMinmaxConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexIndexFacetsMinmaxConstMeta => const TaskConstMeta(
            debugName: "Index_index_facets_minmax",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexIndexedDocCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexIndexedDocCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexIndexedDocCountConstMeta => const TaskConstMeta(
            debugName: "Index_indexed_doc_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexLevelCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 99, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexLevelCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexLevelCountConstMeta => const TaskConstMeta(
            debugName: "Index_level_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexSetSynonyms({required Index that , required List<Synonym> synonyms })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
sse_encode_list_synonym(synonyms, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 100, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexIndexSetSynonymsConstMeta,
            argValues: [that, synonyms],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexSetSynonymsConstMeta => const TaskConstMeta(
            debugName: "Index_set_synonyms",
            argNames: ["that", "synonyms"],
        );
        

@override Future<BigInt> seekstormIndexIndexShardCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 101, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexShardCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexShardCountConstMeta => const TaskConstMeta(
            debugName: "Index_shard_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> seekstormIndexIndexUncommittedDocCount({required Index that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 102, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexIndexUncommittedDocCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexIndexUncommittedDocCountConstMeta => const TaskConstMeta(
            debugName: "Index_uncommitted_doc_count",
            argNames: ["that"],
        );
        

@override Future<Interest> tokioIoInterestAdd({required Interest that , required Interest other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 103, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoInterestAddConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoInterestAddConstMeta => const TaskConstMeta(
            debugName: "Interest_add",
            argNames: ["that", "other"],
        );
        

@override Future<bool> tokioIoInterestIsError({required Interest that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 104, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoInterestIsErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoInterestIsErrorConstMeta => const TaskConstMeta(
            debugName: "Interest_is_error",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoInterestIsReadable({required Interest that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 105, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoInterestIsReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoInterestIsReadableConstMeta => const TaskConstMeta(
            debugName: "Interest_is_readable",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoInterestIsWritable({required Interest that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 106, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoInterestIsWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoInterestIsWritableConstMeta => const TaskConstMeta(
            debugName: "Interest_is_writable",
            argNames: ["that"],
        );
        

@override Future<Interest?> tokioIoInterestRemove({required Interest that , required Interest other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 107, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoInterestRemoveConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoInterestRemoveConstMeta => const TaskConstMeta(
            debugName: "Interest_remove",
            argNames: ["that", "other"],
        );
        

@override Future<MissedTickBehavior> tokioTimeIntervalMissedTickBehavior({required Interval that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 108, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_missed_tick_behavior,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalMissedTickBehaviorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalMissedTickBehaviorConstMeta => const TaskConstMeta(
            debugName: "Interval_missed_tick_behavior",
            argNames: ["that"],
        );
        

@override Future<Duration> tokioTimeIntervalPeriod({required Interval that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 109, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Chrono_Duration,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalPeriodConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalPeriodConstMeta => const TaskConstMeta(
            debugName: "Interval_period",
            argNames: ["that"],
        );
        

@override Future<PollInstant> tokioTimeIntervalPollTick({required Interval that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 110, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalPollTickConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalPollTickConstMeta => const TaskConstMeta(
            debugName: "Interval_poll_tick",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioTimeIntervalReset({required Interval that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 111, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalResetConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalResetConstMeta => const TaskConstMeta(
            debugName: "Interval_reset",
            argNames: ["that"],
        );
        

@override Future<void> tokioTimeIntervalResetAfter({required Interval that , required Duration after })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
sse_encode_Chrono_Duration(after, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 112, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalResetAfterConstMeta,
            argValues: [that, after],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalResetAfterConstMeta => const TaskConstMeta(
            debugName: "Interval_reset_after",
            argNames: ["that", "after"],
        );
        

@override Future<void> tokioTimeIntervalResetAt({required Interval that , required Instant deadline })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(deadline, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 113, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalResetAtConstMeta,
            argValues: [that, deadline],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalResetAtConstMeta => const TaskConstMeta(
            debugName: "Interval_reset_at",
            argNames: ["that", "deadline"],
        );
        

@override Future<void> tokioTimeIntervalResetImmediately({required Interval that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 114, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalResetImmediatelyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalResetImmediatelyConstMeta => const TaskConstMeta(
            debugName: "Interval_reset_immediately",
            argNames: ["that"],
        );
        

@override Future<void> tokioTimeIntervalSetMissedTickBehavior({required Interval that , required MissedTickBehavior behavior })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
sse_encode_missed_tick_behavior(behavior, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 115, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalSetMissedTickBehaviorConstMeta,
            argValues: [that, behavior],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalSetMissedTickBehaviorConstMeta => const TaskConstMeta(
            debugName: "Interval_set_missed_tick_behavior",
            argNames: ["that", "behavior"],
        );
        

@override Future<Instant> tokioTimeIntervalTick({required Interval that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 116, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalTickConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalTickConstMeta => const TaskConstMeta(
            debugName: "Interval_tick",
            argNames: ["that"],
        );
        

@override Future<LocalSet> tokioTaskLocalSetDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 117, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskLocalSetDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskLocalSetDefaultConstMeta => const TaskConstMeta(
            debugName: "LocalSet_default",
            argNames: [],
        );
        

@override Future<LocalEnterGuard> tokioTaskLocalSetEnter({required LocalSet that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 118, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskLocalSetEnterConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskLocalSetEnterConstMeta => const TaskConstMeta(
            debugName: "LocalSet_enter",
            argNames: ["that"],
        );
        

@override Future<Id> tokioTaskLocalSetId({required LocalSet that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 119, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskLocalSetIdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskLocalSetIdConstMeta => const TaskConstMeta(
            debugName: "LocalSet_id",
            argNames: ["that"],
        );
        

@override Future<LocalSet> tokioTaskLocalSetNew()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 120, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskLocalSetNewConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskLocalSetNewConstMeta => const TaskConstMeta(
            debugName: "LocalSet_new",
            argNames: [],
        );
        

@override Value seekstormIndexMinMaxFieldJsonAutoAccessorGetMax({required MinMaxFieldJson that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 121)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldJsonAutoAccessorGetMaxConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldJsonAutoAccessorGetMaxConstMeta => const TaskConstMeta(
            debugName: "MinMaxFieldJson_auto_accessor_get_max",
            argNames: ["that"],
        );
        

@override Value seekstormIndexMinMaxFieldJsonAutoAccessorGetMin({required MinMaxFieldJson that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 122)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldJsonAutoAccessorGetMinConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldJsonAutoAccessorGetMinConstMeta => const TaskConstMeta(
            debugName: "MinMaxFieldJson_auto_accessor_get_min",
            argNames: ["that"],
        );
        

@override void seekstormIndexMinMaxFieldJsonAutoAccessorSetMax({required MinMaxFieldJson that , required Value max })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(max, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 123)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldJsonAutoAccessorSetMaxConstMeta,
            argValues: [that, max],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldJsonAutoAccessorSetMaxConstMeta => const TaskConstMeta(
            debugName: "MinMaxFieldJson_auto_accessor_set_max",
            argNames: ["that", "max"],
        );
        

@override void seekstormIndexMinMaxFieldJsonAutoAccessorSetMin({required MinMaxFieldJson that , required Value min })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(min, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 124)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldJsonAutoAccessorSetMinConstMeta,
            argValues: [that, min],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldJsonAutoAccessorSetMinConstMeta => const TaskConstMeta(
            debugName: "MinMaxFieldJson_auto_accessor_set_min",
            argNames: ["that", "min"],
        );
        

@override Future<MinMaxFieldJson> seekstormIndexMinMaxFieldJsonDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 125, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldJsonDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldJsonDefaultConstMeta => const TaskConstMeta(
            debugName: "MinMaxFieldJson_default",
            argNames: [],
        );
        

@override ValueType seekstormIndexMinMaxFieldAutoAccessorGetMax({required MinMaxField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 126)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldAutoAccessorGetMaxConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldAutoAccessorGetMaxConstMeta => const TaskConstMeta(
            debugName: "MinMaxField_auto_accessor_get_max",
            argNames: ["that"],
        );
        

@override ValueType seekstormIndexMinMaxFieldAutoAccessorGetMin({required MinMaxField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 127)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldAutoAccessorGetMinConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldAutoAccessorGetMinConstMeta => const TaskConstMeta(
            debugName: "MinMaxField_auto_accessor_get_min",
            argNames: ["that"],
        );
        

@override void seekstormIndexMinMaxFieldAutoAccessorSetMax({required MinMaxField that , required ValueType max })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(max, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 128)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldAutoAccessorSetMaxConstMeta,
            argValues: [that, max],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldAutoAccessorSetMaxConstMeta => const TaskConstMeta(
            debugName: "MinMaxField_auto_accessor_set_max",
            argNames: ["that", "max"],
        );
        

@override void seekstormIndexMinMaxFieldAutoAccessorSetMin({required MinMaxField that , required ValueType min })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(min, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 129)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldAutoAccessorSetMinConstMeta,
            argValues: [that, min],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldAutoAccessorSetMinConstMeta => const TaskConstMeta(
            debugName: "MinMaxField_auto_accessor_set_min",
            argNames: ["that", "min"],
        );
        

@override Future<MinMaxField> seekstormIndexMinMaxFieldDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 130, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexMinMaxFieldDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexMinMaxFieldDefaultConstMeta => const TaskConstMeta(
            debugName: "MinMaxField_default",
            argNames: [],
        );
        

@override Future<Notify> tokioSyncNotifyConstNew()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 131, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyConstNewConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyConstNewConstMeta => const TaskConstMeta(
            debugName: "Notify_const_new",
            argNames: [],
        );
        

@override Future<Notify> tokioSyncNotifyDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 132, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyDefaultConstMeta => const TaskConstMeta(
            debugName: "Notify_default",
            argNames: [],
        );
        

@override Future<Notify> tokioSyncNotifyNew()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 133, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNewConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNewConstMeta => const TaskConstMeta(
            debugName: "Notify_new",
            argNames: [],
        );
        

@override Future<Notified> tokioSyncNotifyNotified({required Notify that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 134, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNotifiedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNotifiedConstMeta => const TaskConstMeta(
            debugName: "Notify_notified",
            argNames: ["that"],
        );
        

@override Future<OwnedNotified> tokioSyncNotifyNotifiedOwned({required Notify that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 135, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNotifiedOwnedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNotifiedOwnedConstMeta => const TaskConstMeta(
            debugName: "Notify_notified_owned",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncNotifyNotifyLast({required Notify that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 136, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNotifyLastConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNotifyLastConstMeta => const TaskConstMeta(
            debugName: "Notify_notify_last",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncNotifyNotifyOne({required Notify that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 137, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNotifyOneConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNotifyOneConstMeta => const TaskConstMeta(
            debugName: "Notify_notify_one",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncNotifyNotifyWaiters({required Notify that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 138, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncNotifyNotifyWaitersConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncNotifyNotifyWaitersConstMeta => const TaskConstMeta(
            debugName: "Notify_notify_waiters",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsAppend({required OpenOptions that , required bool append })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(append, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 139, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsAppendConstMeta,
            argValues: [that, append],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsAppendConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_append",
            argNames: ["that", "append"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsCreate({required OpenOptions that , required bool create })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(create, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 140, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsCreateConstMeta,
            argValues: [that, create],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsCreateConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_create",
            argNames: ["that", "create"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsCreateNew({required OpenOptions that , required bool createNew })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(createNew, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 141, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsCreateNewConstMeta,
            argValues: [that, createNew],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsCreateNewConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_create_new",
            argNames: ["that", "createNew"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsCustomFlags({required OpenOptions that , required int flags })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_i_32(flags, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 142, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsCustomFlagsConstMeta,
            argValues: [that, flags],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsCustomFlagsConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_custom_flags",
            argNames: ["that", "flags"],
        );
        

@override Future<OpenOptions> tokioNetUnixPipeOpenOptionsDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 143, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsDefaultConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_default",
            argNames: [],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsMode({required OpenOptions that , required int mode })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_u_32(mode, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 144, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsModeConstMeta,
            argValues: [that, mode],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsModeConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_mode",
            argNames: ["that", "mode"],
        );
        

@override Future<OpenOptions> tokioNetUnixPipeOpenOptionsNew()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 145, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsNewConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsNewConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_new",
            argNames: [],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsRead({required OpenOptions that , required bool read })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(read, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 146, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsReadConstMeta,
            argValues: [that, read],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsReadConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_read",
            argNames: ["that", "read"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsTruncate({required OpenOptions that , required bool truncate })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(truncate, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 147, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsTruncateConstMeta,
            argValues: [that, truncate],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsTruncateConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_truncate",
            argNames: ["that", "truncate"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsUnchecked({required OpenOptions that , required bool value })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(value, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 148, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsUncheckedConstMeta,
            argValues: [that, value],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsUncheckedConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_unchecked",
            argNames: ["that", "value"],
        );
        

@override Future<void> tokioNetUnixPipeOpenOptionsWrite({required OpenOptions that , required bool write })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(that, serializer);
sse_encode_bool(write, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 149, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeOpenOptionsWriteConstMeta,
            argValues: [that, write],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeOpenOptionsWriteConstMeta => const TaskConstMeta(
            debugName: "OpenOptions_write",
            argNames: ["that", "write"],
        );
        

@override Future<SocketAddr> tokioNetTcpOwnedReadHalfLocalAddr({required OwnedReadHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 150, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfLocalAddrConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_local_addr",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetTcpOwnedReadHalfPeek({required OwnedReadHalf that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 151, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfPeekConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfPeekConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_peek",
            argNames: ["that", "buf"],
        );
        

@override Future<SocketAddr> tokioNetTcpOwnedReadHalfPeerAddr({required OwnedReadHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 152, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfPeerAddrConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_peer_addr",
            argNames: ["that"],
        );
        

@override Future<PollResultUsize> tokioNetTcpOwnedReadHalfPollPeek({required OwnedReadHalf that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 153, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfPollPeekConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfPollPeekConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_poll_peek",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<void> tokioNetTcpOwnedReadHalfReadable({required OwnedReadHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 154, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfReadableConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetTcpOwnedReadHalfReady({required OwnedReadHalf that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 155, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfReadyConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<TcpStream> tokioNetTcpOwnedReadHalfReunite({required OwnedReadHalf that , required OwnedWriteHalf other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 156, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfReuniteConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfReuniteConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_reunite",
            argNames: ["that", "other"],
        );
        

@override Future<BigInt> tokioNetTcpOwnedReadHalfTryRead({required OwnedReadHalf that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 157, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfTryReadConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfTryReadConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_try_read",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetTcpOwnedReadHalfTryReadVectored({required OwnedReadHalf that , required IoSliceMut bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 158, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedReadHalfTryReadVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedReadHalfTryReadVectoredConstMeta => const TaskConstMeta(
            debugName: "OwnedReadHalf_try_read_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<void> tokioSyncOwnedSemaphorePermitMerge({required OwnedSemaphorePermit that , required OwnedSemaphorePermit other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 159, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncOwnedSemaphorePermitMergeConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncOwnedSemaphorePermitMergeConstMeta => const TaskConstMeta(
            debugName: "OwnedSemaphorePermit_merge",
            argNames: ["that", "other"],
        );
        

@override Future<BigInt> tokioSyncOwnedSemaphorePermitNumPermits({required OwnedSemaphorePermit that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 160, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncOwnedSemaphorePermitNumPermitsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncOwnedSemaphorePermitNumPermitsConstMeta => const TaskConstMeta(
            debugName: "OwnedSemaphorePermit_num_permits",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncOwnedSemaphorePermitSemaphore({required OwnedSemaphorePermit that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 161, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncOwnedSemaphorePermitSemaphoreConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncOwnedSemaphorePermitSemaphoreConstMeta => const TaskConstMeta(
            debugName: "OwnedSemaphorePermit_semaphore",
            argNames: ["that"],
        );
        

@override Future<OwnedSemaphorePermit?> tokioSyncOwnedSemaphorePermitSplit({required OwnedSemaphorePermit that , required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(that, serializer);
sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 162, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncOwnedSemaphorePermitSplitConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncOwnedSemaphorePermitSplitConstMeta => const TaskConstMeta(
            debugName: "OwnedSemaphorePermit_split",
            argNames: ["that", "n"],
        );
        

@override Future<SocketAddr> tokioNetTcpOwnedWriteHalfLocalAddr({required OwnedWriteHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 163, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfLocalAddrConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_local_addr",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetTcpOwnedWriteHalfPeerAddr({required OwnedWriteHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 164, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfPeerAddrConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_peer_addr",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetTcpOwnedWriteHalfReady({required OwnedWriteHalf that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 165, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfReadyConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<TcpStream> tokioNetTcpOwnedWriteHalfReunite({required OwnedWriteHalf that , required OwnedReadHalf other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 166, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfReuniteConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfReuniteConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_reunite",
            argNames: ["that", "other"],
        );
        

@override Future<BigInt> tokioNetTcpOwnedWriteHalfTryWrite({required OwnedWriteHalf that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 167, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfTryWriteConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfTryWriteConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_try_write",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetTcpOwnedWriteHalfTryWriteVectored({required OwnedWriteHalf that , required List<IoSlice> bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 168, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfTryWriteVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfTryWriteVectoredConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_try_write_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<void> tokioNetTcpOwnedWriteHalfWritable({required OwnedWriteHalf that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 169, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpOwnedWriteHalfWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpOwnedWriteHalfWritableConstMeta => const TaskConstMeta(
            debugName: "OwnedWriteHalf_writable",
            argNames: ["that"],
        );
        

@override Future<QueryFacet> seekstormSearchQueryFacetDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 170, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchQueryFacetDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchQueryFacetDefaultConstMeta => const TaskConstMeta(
            debugName: "QueryFacet_default",
            argNames: [],
        );
        

@override Future<QueryRewriting> seekstormSearchQueryRewritingDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 171, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchQueryRewritingDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchQueryRewritingDefaultConstMeta => const TaskConstMeta(
            debugName: "QueryRewriting_default",
            argNames: [],
        );
        

@override Future<Ranges> seekstormSearchRangesDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 172, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchRangesDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchRangesDefaultConstMeta => const TaskConstMeta(
            debugName: "Ranges_default",
            argNames: [],
        );
        

@override Future<bool> tokioIoReadyIsEmpty({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 173, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsEmptyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsEmptyConstMeta => const TaskConstMeta(
            debugName: "Ready_is_empty",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoReadyIsError({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 174, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsErrorConstMeta => const TaskConstMeta(
            debugName: "Ready_is_error",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoReadyIsReadClosed({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 175, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsReadClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsReadClosedConstMeta => const TaskConstMeta(
            debugName: "Ready_is_read_closed",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoReadyIsReadable({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 176, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsReadableConstMeta => const TaskConstMeta(
            debugName: "Ready_is_readable",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoReadyIsWritable({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 177, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsWritableConstMeta => const TaskConstMeta(
            debugName: "Ready_is_writable",
            argNames: ["that"],
        );
        

@override Future<bool> tokioIoReadyIsWriteClosed({required Ready that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 178, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoReadyIsWriteClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoReadyIsWriteClosedConstMeta => const TaskConstMeta(
            debugName: "Ready_is_write_closed",
            argNames: ["that"],
        );
        

@override Future<T> tokioNetUnixPipeReceiverTBlockingRecv({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 179, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTBlockingRecvConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTBlockingRecvConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_blocking_recv",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTBlockingRecvMany({required ReceiverT that , required VecT buffer , required BigInt limit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(buffer, serializer);
sse_encode_usize(limit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 180, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTBlockingRecvManyConstMeta,
            argValues: [that, buffer, limit],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTBlockingRecvManyConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_blocking_recv_many",
            argNames: ["that", "buffer", "limit"],
        );
        

@override Future<RefT> tokioNetUnixPipeReceiverTBorrow({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 181, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTBorrowConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTBorrowConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_borrow",
            argNames: ["that"],
        );
        

@override Future<RefT> tokioNetUnixPipeReceiverTBorrowAndUpdate({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 182, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTBorrowAndUpdateConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTBorrowAndUpdateConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_borrow_and_update",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTCapacity({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 183, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTCapacityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTCapacityConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_capacity",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeReceiverTChanged({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 184, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTChangedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTChangedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_changed",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeReceiverTClose({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 185, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTCloseConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTCloseConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_close",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeReceiverTHasChanged({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 186, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTHasChangedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTHasChangedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_has_changed",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeReceiverTIsClosed({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 187, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTIsClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTIsClosedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_is_closed",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeReceiverTIsEmpty({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 188, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTIsEmptyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTIsEmptyConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_is_empty",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeReceiverTIsTerminated({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 189, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTIsTerminatedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTIsTerminatedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_is_terminated",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTLen({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 190, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTLenConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTLenConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_len",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeReceiverTMarkChanged({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 191, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTMarkChangedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTMarkChangedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_mark_changed",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeReceiverTMarkUnchanged({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 192, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTMarkUnchangedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTMarkUnchangedConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_mark_unchanged",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTMaxCapacity({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 193, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTMaxCapacityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTMaxCapacityConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_max_capacity",
            argNames: ["that"],
        );
        

@override Future<PollOptionT> tokioNetUnixPipeReceiverTPollRecv({required ReceiverT that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 194, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTPollRecvConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTPollRecvConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_poll_recv",
            argNames: ["that", "cx"],
        );
        

@override Future<PollUsize> tokioNetUnixPipeReceiverTPollRecvMany({required ReceiverT that , required Context cx , required VecT buffer , required BigInt limit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(buffer, serializer);
sse_encode_usize(limit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 195, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTPollRecvManyConstMeta,
            argValues: [that, cx, buffer, limit],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTPollRecvManyConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_poll_recv_many",
            argNames: ["that", "cx", "buffer", "limit"],
        );
        

@override Future<T> tokioNetUnixPipeReceiverTRecv({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 196, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTRecvConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTRecvConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_recv",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTRecvMany({required ReceiverT that , required VecT buffer , required BigInt limit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(buffer, serializer);
sse_encode_usize(limit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 197, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTRecvManyConstMeta,
            argValues: [that, buffer, limit],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTRecvManyConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_recv_many",
            argNames: ["that", "buffer", "limit"],
        );
        

@override Future<ReceiverT> tokioNetUnixPipeReceiverTResubscribe({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 198, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTResubscribeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTResubscribeConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_resubscribe",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeReceiverTSameChannel({required ReceiverT that , required ReceiverT other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 199, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTSameChannelConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTSameChannelConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_same_channel",
            argNames: ["that", "other"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTSenderStrongCount({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 200, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTSenderStrongCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTSenderStrongCountConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_sender_strong_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTSenderWeakCount({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 201, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTSenderWeakCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTSenderWeakCountConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_sender_weak_count",
            argNames: ["that"],
        );
        

@override Future<T> tokioNetUnixPipeReceiverTTryRecv({required ReceiverT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 202, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTTryRecvConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTTryRecvConstMeta => const TaskConstMeta(
            debugName: "ReceiverT_try_recv",
            argNames: ["that"],
        );
        

@override Future<Receiver> tokioNetUnixPipeReceiverFromFile({required File file })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(file, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 203, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverFromFileConstMeta,
            argValues: [file],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverFromFileConstMeta => const TaskConstMeta(
            debugName: "Receiver_from_file",
            argNames: ["file"],
        );
        

@override Future<Receiver> tokioNetUnixPipeReceiverFromFileUnchecked({required File file })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(file, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 204, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverFromFileUncheckedConstMeta,
            argValues: [file],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverFromFileUncheckedConstMeta => const TaskConstMeta(
            debugName: "Receiver_from_file_unchecked",
            argNames: ["file"],
        );
        

@override Future<Receiver> tokioNetUnixPipeReceiverFromOwnedFd({required OwnedFd ownedFd })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(ownedFd, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 205, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverFromOwnedFdConstMeta,
            argValues: [ownedFd],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverFromOwnedFdConstMeta => const TaskConstMeta(
            debugName: "Receiver_from_owned_fd",
            argNames: ["ownedFd"],
        );
        

@override Future<Receiver> tokioNetUnixPipeReceiverFromOwnedFdUnchecked({required OwnedFd ownedFd })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(ownedFd, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 206, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverFromOwnedFdUncheckedConstMeta,
            argValues: [ownedFd],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverFromOwnedFdUncheckedConstMeta => const TaskConstMeta(
            debugName: "Receiver_from_owned_fd_unchecked",
            argNames: ["ownedFd"],
        );
        

@override Future<OwnedFd> tokioNetUnixPipeReceiverIntoBlockingFd({required Receiver that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 207, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverIntoBlockingFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverIntoBlockingFdConstMeta => const TaskConstMeta(
            debugName: "Receiver_into_blocking_fd",
            argNames: ["that"],
        );
        

@override Future<OwnedFd> tokioNetUnixPipeReceiverIntoNonblockingFd({required Receiver that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 208, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverIntoNonblockingFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverIntoNonblockingFdConstMeta => const TaskConstMeta(
            debugName: "Receiver_into_nonblocking_fd",
            argNames: ["that"],
        );
        

@override Future<PollResult> tokioNetUnixPipeReceiverPollReadReady({required Receiver that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 209, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverPollReadReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverPollReadReadyConstMeta => const TaskConstMeta(
            debugName: "Receiver_poll_read_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioNetUnixPipeReceiverReadable({required Receiver that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 210, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverReadableConstMeta => const TaskConstMeta(
            debugName: "Receiver_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetUnixPipeReceiverReady({required Receiver that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 211, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverReadyConstMeta => const TaskConstMeta(
            debugName: "Receiver_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTryRead({required Receiver that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 212, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTryReadConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTryReadConstMeta => const TaskConstMeta(
            debugName: "Receiver_try_read",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixPipeReceiverTryReadVectored({required Receiver that , required IoSliceMut bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 213, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeReceiverTryReadVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeReceiverTryReadVectoredConstMeta => const TaskConstMeta(
            debugName: "Receiver_try_read_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<void> tokioTaskCoopRestoreOnPendingMadeProgress({required RestoreOnPending that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 214, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskCoopRestoreOnPendingMadeProgressConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskCoopRestoreOnPendingMadeProgressConstMeta => const TaskConstMeta(
            debugName: "RestoreOnPending_made_progress",
            argNames: ["that"],
        );
        

@override AHashMapStringFacet seekstormSearchResultObjectAutoAccessorGetFacets({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 215)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetFacetsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetFacetsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_facets",
            argNames: ["that"],
        );
        

@override String seekstormSearchResultObjectAutoAccessorGetOriginalQuery({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 216)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetOriginalQueryConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetOriginalQueryConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_original_query",
            argNames: ["that"],
        );
        

@override String seekstormSearchResultObjectAutoAccessorGetQuery({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 217)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetQueryConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetQueryConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_query",
            argNames: ["that"],
        );
        

@override List<String> seekstormSearchResultObjectAutoAccessorGetQueryTerms({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 218)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetQueryTermsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetQueryTermsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_query_terms",
            argNames: ["that"],
        );
        

@override BigInt seekstormSearchResultObjectAutoAccessorGetResultCount({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 219)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetResultCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetResultCountConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_result_count",
            argNames: ["that"],
        );
        

@override BigInt seekstormSearchResultObjectAutoAccessorGetResultCountTotal({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 220)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetResultCountTotalConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetResultCountTotalConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_result_count_total",
            argNames: ["that"],
        );
        

@override List<Result> seekstormSearchResultObjectAutoAccessorGetResults({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 221)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetResultsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetResultsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_results",
            argNames: ["that"],
        );
        

@override List<String> seekstormSearchResultObjectAutoAccessorGetSuggestions({required ResultObject that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 222)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorGetSuggestionsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorGetSuggestionsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_get_suggestions",
            argNames: ["that"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetFacets({required ResultObject that , required AHashMapStringFacet facets })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(facets, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 223)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetFacetsConstMeta,
            argValues: [that, facets],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetFacetsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_facets",
            argNames: ["that", "facets"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetOriginalQuery({required ResultObject that , required String originalQuery })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_String(originalQuery, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 224)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetOriginalQueryConstMeta,
            argValues: [that, originalQuery],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetOriginalQueryConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_original_query",
            argNames: ["that", "originalQuery"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetQuery({required ResultObject that , required String query })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_String(query, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 225)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetQueryConstMeta,
            argValues: [that, query],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetQueryConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_query",
            argNames: ["that", "query"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetQueryTerms({required ResultObject that , required List<String> queryTerms })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_list_String(queryTerms, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 226)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetQueryTermsConstMeta,
            argValues: [that, queryTerms],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetQueryTermsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_query_terms",
            argNames: ["that", "queryTerms"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetResultCount({required ResultObject that , required BigInt resultCount })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_usize(resultCount, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 227)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetResultCountConstMeta,
            argValues: [that, resultCount],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetResultCountConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_result_count",
            argNames: ["that", "resultCount"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetResultCountTotal({required ResultObject that , required BigInt resultCountTotal })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_usize(resultCountTotal, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 228)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetResultCountTotalConstMeta,
            argValues: [that, resultCountTotal],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetResultCountTotalConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_result_count_total",
            argNames: ["that", "resultCountTotal"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetResults({required ResultObject that , required List<Result> results })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(results, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 229)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetResultsConstMeta,
            argValues: [that, results],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetResultsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_results",
            argNames: ["that", "results"],
        );
        

@override void seekstormSearchResultObjectAutoAccessorSetSuggestions({required ResultObject that , required List<String> suggestions })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(that, serializer);
sse_encode_list_String(suggestions, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 230)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectAutoAccessorSetSuggestionsConstMeta,
            argValues: [that, suggestions],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectAutoAccessorSetSuggestionsConstMeta => const TaskConstMeta(
            debugName: "ResultObject_auto_accessor_set_suggestions",
            argNames: ["that", "suggestions"],
        );
        

@override Future<ResultObject> seekstormSearchResultObjectDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 231, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultObjectDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultObjectDefaultConstMeta => const TaskConstMeta(
            debugName: "ResultObject_default",
            argNames: [],
        );
        

@override FacetValue seekstormSearchResultSortAutoAccessorGetBase({required ResultSort that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 232)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorGetBaseConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorGetBaseConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_get_base",
            argNames: ["that"],
        );
        

@override String seekstormSearchResultSortAutoAccessorGetField({required ResultSort that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 233)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorGetFieldConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorGetFieldConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_get_field",
            argNames: ["that"],
        );
        

@override SortOrder seekstormSearchResultSortAutoAccessorGetOrder({required ResultSort that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 234)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_sort_order,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorGetOrderConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorGetOrderConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_get_order",
            argNames: ["that"],
        );
        

@override void seekstormSearchResultSortAutoAccessorSetBase({required ResultSort that , required FacetValue base })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(base, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 235)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorSetBaseConstMeta,
            argValues: [that, base],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorSetBaseConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_set_base",
            argNames: ["that", "base"],
        );
        

@override void seekstormSearchResultSortAutoAccessorSetField({required ResultSort that , required String field })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
sse_encode_String(field, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 236)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorSetFieldConstMeta,
            argValues: [that, field],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorSetFieldConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_set_field",
            argNames: ["that", "field"],
        );
        

@override void seekstormSearchResultSortAutoAccessorSetOrder({required ResultSort that , required SortOrder order })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(that, serializer);
sse_encode_sort_order(order, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 237)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultSortAutoAccessorSetOrderConstMeta,
            argValues: [that, order],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultSortAutoAccessorSetOrderConstMeta => const TaskConstMeta(
            debugName: "ResultSort_auto_accessor_set_order",
            argNames: ["that", "order"],
        );
        

@override OwnedReadHalf tokioNetTcpReuniteErrorAutoAccessorGetField0({required ReuniteError that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 238)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpReuniteErrorAutoAccessorGetField0ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpReuniteErrorAutoAccessorGetField0ConstMeta => const TaskConstMeta(
            debugName: "ReuniteError_auto_accessor_get_field0",
            argNames: ["that"],
        );
        

@override OwnedWriteHalf tokioNetTcpReuniteErrorAutoAccessorGetField1({required ReuniteError that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 239)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpReuniteErrorAutoAccessorGetField1ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpReuniteErrorAutoAccessorGetField1ConstMeta => const TaskConstMeta(
            debugName: "ReuniteError_auto_accessor_get_field1",
            argNames: ["that"],
        );
        

@override void tokioNetTcpReuniteErrorAutoAccessorSetField0({required ReuniteError that , required OwnedReadHalf field0 })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(field0, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 240)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpReuniteErrorAutoAccessorSetField0ConstMeta,
            argValues: [that, field0],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpReuniteErrorAutoAccessorSetField0ConstMeta => const TaskConstMeta(
            debugName: "ReuniteError_auto_accessor_set_field0",
            argNames: ["that", "field0"],
        );
        

@override void tokioNetTcpReuniteErrorAutoAccessorSetField1({required ReuniteError that , required OwnedWriteHalf field1 })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(field1, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 241)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpReuniteErrorAutoAccessorSetField1ConstMeta,
            argValues: [that, field1],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpReuniteErrorAutoAccessorSetField1ConstMeta => const TaskConstMeta(
            debugName: "ReuniteError_auto_accessor_set_field1",
            argNames: ["that", "field1"],
        );
        

@override Future<BigInt> tokioRuntimeRuntimeMetricsGlobalQueueDepth({required RuntimeMetrics that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 242, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsGlobalQueueDepthConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsGlobalQueueDepthConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_global_queue_depth",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioRuntimeRuntimeMetricsNumAliveTasks({required RuntimeMetrics that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 243, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsNumAliveTasksConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsNumAliveTasksConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_num_alive_tasks",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioRuntimeRuntimeMetricsNumWorkers({required RuntimeMetrics that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 244, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsNumWorkersConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsNumWorkersConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_num_workers",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioRuntimeRuntimeMetricsWorkerParkCount({required RuntimeMetrics that , required BigInt worker })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
sse_encode_usize(worker, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 245, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsWorkerParkCountConstMeta,
            argValues: [that, worker],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsWorkerParkCountConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_worker_park_count",
            argNames: ["that", "worker"],
        );
        

@override Future<BigInt> tokioRuntimeRuntimeMetricsWorkerParkUnparkCount({required RuntimeMetrics that , required BigInt worker })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
sse_encode_usize(worker, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 246, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsWorkerParkUnparkCountConstMeta,
            argValues: [that, worker],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsWorkerParkUnparkCountConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_worker_park_unpark_count",
            argNames: ["that", "worker"],
        );
        

@override Future<Duration> tokioRuntimeRuntimeMetricsWorkerTotalBusyDuration({required RuntimeMetrics that , required BigInt worker })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(that, serializer);
sse_encode_usize(worker, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 247, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Chrono_Duration,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsWorkerTotalBusyDurationConstMeta,
            argValues: [that, worker],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsWorkerTotalBusyDurationConstMeta => const TaskConstMeta(
            debugName: "RuntimeMetrics_worker_total_busy_duration",
            argNames: ["that", "worker"],
        );
        

@override Future<EnterGuard> tokioRuntimeRuntimeEnter({required Runtime that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 248, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeEnterConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeEnterConstMeta => const TaskConstMeta(
            debugName: "Runtime_enter",
            argNames: ["that"],
        );
        

@override Future<void> tokioRuntimeRuntimeHandle({required Runtime that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 249, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeHandleConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeHandleConstMeta => const TaskConstMeta(
            debugName: "Runtime_handle",
            argNames: ["that"],
        );
        

@override Future<RuntimeMetrics> tokioRuntimeRuntimeMetrics({required Runtime that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 250, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeMetricsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeMetricsConstMeta => const TaskConstMeta(
            debugName: "Runtime_metrics",
            argNames: ["that"],
        );
        

@override Future<Runtime> tokioRuntimeRuntimeNew()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 251, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioRuntimeRuntimeNewConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeNewConstMeta => const TaskConstMeta(
            debugName: "Runtime_new",
            argNames: [],
        );
        

@override Future<void> tokioRuntimeRuntimeShutdownBackground({required Runtime that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 252, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeRuntimeShutdownBackgroundConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeRuntimeShutdownBackgroundConstMeta => const TaskConstMeta(
            debugName: "Runtime_shutdown_background",
            argNames: ["that"],
        );
        

@override double seekstormIndexSchemaFieldAutoAccessorGetBoost({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 253)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_f_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetBoostConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetBoostConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_boost",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetCompletionSource({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 254)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetCompletionSourceConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetCompletionSourceConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_completion_source",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetDictionarySource({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 255)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetDictionarySourceConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetDictionarySourceConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_dictionary_source",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetFacet({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 256)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetFacetConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetFacetConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_facet",
            argNames: ["that"],
        );
        

@override String seekstormIndexSchemaFieldAutoAccessorGetField({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 257)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetFieldConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetFieldConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_field",
            argNames: ["that"],
        );
        

@override FieldType seekstormIndexSchemaFieldAutoAccessorGetFieldType({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 258)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_field_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetFieldTypeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetFieldTypeConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_field_type",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetIndexed({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 259)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetIndexedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetIndexedConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_indexed",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetLongest({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 260)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetLongestConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetLongestConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_longest",
            argNames: ["that"],
        );
        

@override bool seekstormIndexSchemaFieldAutoAccessorGetStored({required SchemaField that })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 261)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorGetStoredConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorGetStoredConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_get_stored",
            argNames: ["that"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetBoost({required SchemaField that , required double boost })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_f_32(boost, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 262)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetBoostConstMeta,
            argValues: [that, boost],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetBoostConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_boost",
            argNames: ["that", "boost"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetCompletionSource({required SchemaField that , required bool completionSource })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(completionSource, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 263)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetCompletionSourceConstMeta,
            argValues: [that, completionSource],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetCompletionSourceConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_completion_source",
            argNames: ["that", "completionSource"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetDictionarySource({required SchemaField that , required bool dictionarySource })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(dictionarySource, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 264)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetDictionarySourceConstMeta,
            argValues: [that, dictionarySource],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetDictionarySourceConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_dictionary_source",
            argNames: ["that", "dictionarySource"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetFacet({required SchemaField that , required bool facet })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(facet, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 265)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetFacetConstMeta,
            argValues: [that, facet],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetFacetConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_facet",
            argNames: ["that", "facet"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetField({required SchemaField that , required String field })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_String(field, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 266)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetFieldConstMeta,
            argValues: [that, field],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetFieldConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_field",
            argNames: ["that", "field"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetFieldType({required SchemaField that , required FieldType fieldType })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_field_type(fieldType, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 267)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetFieldTypeConstMeta,
            argValues: [that, fieldType],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetFieldTypeConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_field_type",
            argNames: ["that", "fieldType"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetIndexed({required SchemaField that , required bool indexed })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(indexed, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 268)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetIndexedConstMeta,
            argValues: [that, indexed],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetIndexedConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_indexed",
            argNames: ["that", "indexed"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetLongest({required SchemaField that , required bool longest })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(longest, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 269)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetLongestConstMeta,
            argValues: [that, longest],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetLongestConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_longest",
            argNames: ["that", "longest"],
        );
        

@override void seekstormIndexSchemaFieldAutoAccessorSetStored({required SchemaField that , required bool stored })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(that, serializer);
sse_encode_bool(stored, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 270)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldAutoAccessorSetStoredConstMeta,
            argValues: [that, stored],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldAutoAccessorSetStoredConstMeta => const TaskConstMeta(
            debugName: "SchemaField_auto_accessor_set_stored",
            argNames: ["that", "stored"],
        );
        

@override Future<SchemaField> seekstormIndexSchemaFieldNew({required String field , required bool stored , required bool indexed , required FieldType fieldType , required bool facet , required bool longest , required double boost , required bool dictionarySource , required bool completionSource })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(field, serializer);
sse_encode_bool(stored, serializer);
sse_encode_bool(indexed, serializer);
sse_encode_field_type(fieldType, serializer);
sse_encode_bool(facet, serializer);
sse_encode_bool(longest, serializer);
sse_encode_f_32(boost, serializer);
sse_encode_bool(dictionarySource, serializer);
sse_encode_bool(completionSource, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 271, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSchemaFieldNewConstMeta,
            argValues: [field, stored, indexed, fieldType, facet, longest, boost, dictionarySource, completionSource],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSchemaFieldNewConstMeta => const TaskConstMeta(
            debugName: "SchemaField_new",
            argNames: ["field", "stored", "indexed", "fieldType", "facet", "longest", "boost", "dictionarySource", "completionSource"],
        );
        

@override Future<SemaphorePermit> tokioSyncSemaphoreAcquire({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 272, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError,
        )
        ,
            constMeta: kTokioSyncSemaphoreAcquireConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAcquireConstMeta => const TaskConstMeta(
            debugName: "Semaphore_acquire",
            argNames: ["that"],
        );
        

@override Future<SemaphorePermit> tokioSyncSemaphoreAcquireMany({required Semaphore that , required int n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_u_32(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 273, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError,
        )
        ,
            constMeta: kTokioSyncSemaphoreAcquireManyConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAcquireManyConstMeta => const TaskConstMeta(
            debugName: "Semaphore_acquire_many",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedSemaphorePermit> tokioSyncSemaphoreAcquireManyOwned({required Semaphore that , required int n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_u_32(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 274, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError,
        )
        ,
            constMeta: kTokioSyncSemaphoreAcquireManyOwnedConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAcquireManyOwnedConstMeta => const TaskConstMeta(
            debugName: "Semaphore_acquire_many_owned",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedSemaphorePermit> tokioSyncSemaphoreAcquireOwned({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 275, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError,
        )
        ,
            constMeta: kTokioSyncSemaphoreAcquireOwnedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAcquireOwnedConstMeta => const TaskConstMeta(
            debugName: "Semaphore_acquire_owned",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncSemaphoreAddPermits({required Semaphore that , required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 276, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreAddPermitsConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAddPermitsConstMeta => const TaskConstMeta(
            debugName: "Semaphore_add_permits",
            argNames: ["that", "n"],
        );
        

@override Future<BigInt> tokioSyncSemaphoreAvailablePermits({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 277, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreAvailablePermitsConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreAvailablePermitsConstMeta => const TaskConstMeta(
            debugName: "Semaphore_available_permits",
            argNames: ["that"],
        );
        

@override Future<void> tokioSyncSemaphoreClose({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 278, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreCloseConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreCloseConstMeta => const TaskConstMeta(
            debugName: "Semaphore_close",
            argNames: ["that"],
        );
        

@override Future<Semaphore> tokioSyncSemaphoreConstNew({required BigInt permits })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(permits, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 279, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreConstNewConstMeta,
            argValues: [permits],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreConstNewConstMeta => const TaskConstMeta(
            debugName: "Semaphore_const_new",
            argNames: ["permits"],
        );
        

@override Future<BigInt> tokioSyncSemaphoreForgetPermits({required Semaphore that , required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 280, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreForgetPermitsConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreForgetPermitsConstMeta => const TaskConstMeta(
            debugName: "Semaphore_forget_permits",
            argNames: ["that", "n"],
        );
        

@override Future<bool> tokioSyncSemaphoreIsClosed({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 281, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreIsClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreIsClosedConstMeta => const TaskConstMeta(
            debugName: "Semaphore_is_closed",
            argNames: ["that"],
        );
        

@override Future<Semaphore> tokioSyncSemaphoreNew({required BigInt permits })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(permits, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 282, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSyncSemaphoreNewConstMeta,
            argValues: [permits],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreNewConstMeta => const TaskConstMeta(
            debugName: "Semaphore_new",
            argNames: ["permits"],
        );
        

@override Future<SemaphorePermit> tokioSyncSemaphoreTryAcquire({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 283, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic,
          decodeErrorData: sse_decode_try_acquire_error,
        )
        ,
            constMeta: kTokioSyncSemaphoreTryAcquireConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreTryAcquireConstMeta => const TaskConstMeta(
            debugName: "Semaphore_try_acquire",
            argNames: ["that"],
        );
        

@override Future<SemaphorePermit> tokioSyncSemaphoreTryAcquireMany({required Semaphore that , required int n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_u_32(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 284, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic,
          decodeErrorData: sse_decode_try_acquire_error,
        )
        ,
            constMeta: kTokioSyncSemaphoreTryAcquireManyConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreTryAcquireManyConstMeta => const TaskConstMeta(
            debugName: "Semaphore_try_acquire_many",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedSemaphorePermit> tokioSyncSemaphoreTryAcquireManyOwned({required Semaphore that , required int n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
sse_encode_u_32(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 285, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit,
          decodeErrorData: sse_decode_try_acquire_error,
        )
        ,
            constMeta: kTokioSyncSemaphoreTryAcquireManyOwnedConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreTryAcquireManyOwnedConstMeta => const TaskConstMeta(
            debugName: "Semaphore_try_acquire_many_owned",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedSemaphorePermit> tokioSyncSemaphoreTryAcquireOwned({required Semaphore that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 286, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit,
          decodeErrorData: sse_decode_try_acquire_error,
        )
        ,
            constMeta: kTokioSyncSemaphoreTryAcquireOwnedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSyncSemaphoreTryAcquireOwnedConstMeta => const TaskConstMeta(
            debugName: "Semaphore_try_acquire_owned",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeSenderTBlockingSend({required SenderT that , required T value })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(value, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 287, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTBlockingSendConstMeta,
            argValues: [that, value],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTBlockingSendConstMeta => const TaskConstMeta(
            debugName: "SenderT_blocking_send",
            argNames: ["that", "value"],
        );
        

@override Future<RefT> tokioNetUnixPipeSenderTBorrow({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 288, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTBorrowConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTBorrowConstMeta => const TaskConstMeta(
            debugName: "SenderT_borrow",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTCapacity({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 289, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTCapacityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTCapacityConstMeta => const TaskConstMeta(
            debugName: "SenderT_capacity",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeSenderTClosed({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 290, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTClosedConstMeta => const TaskConstMeta(
            debugName: "SenderT_closed",
            argNames: ["that"],
        );
        

@override Future<SenderT> tokioNetUnixPipeSenderTDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 291, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTDefaultConstMeta => const TaskConstMeta(
            debugName: "SenderT_default",
            argNames: [],
        );
        

@override Future<WeakSenderT> tokioNetUnixPipeSenderTDowngrade({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 292, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTDowngradeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTDowngradeConstMeta => const TaskConstMeta(
            debugName: "SenderT_downgrade",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeSenderTIsClosed({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 293, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTIsClosedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTIsClosedConstMeta => const TaskConstMeta(
            debugName: "SenderT_is_closed",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeSenderTIsEmpty({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 294, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTIsEmptyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTIsEmptyConstMeta => const TaskConstMeta(
            debugName: "SenderT_is_empty",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTLen({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 295, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTLenConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTLenConstMeta => const TaskConstMeta(
            debugName: "SenderT_len",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTMaxCapacity({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 296, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTMaxCapacityConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTMaxCapacityConstMeta => const TaskConstMeta(
            debugName: "SenderT_max_capacity",
            argNames: ["that"],
        );
        

@override Future<SenderT> tokioNetUnixPipeSenderTNew({required BigInt capacity })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(capacity, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 297, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTNewConstMeta,
            argValues: [capacity],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTNewConstMeta => const TaskConstMeta(
            debugName: "SenderT_new",
            argNames: ["capacity"],
        );
        

@override Future<Poll> tokioNetUnixPipeSenderTPollClosed({required SenderT that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 298, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTPollClosedConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTPollClosedConstMeta => const TaskConstMeta(
            debugName: "SenderT_poll_closed",
            argNames: ["that", "cx"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTReceiverCount({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 299, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTReceiverCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTReceiverCountConstMeta => const TaskConstMeta(
            debugName: "SenderT_receiver_count",
            argNames: ["that"],
        );
        

@override Future<PermitT> tokioNetUnixPipeSenderTReserve({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 300, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTReserveConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTReserveConstMeta => const TaskConstMeta(
            debugName: "SenderT_reserve",
            argNames: ["that"],
        );
        

@override Future<PermitIteratorT> tokioNetUnixPipeSenderTReserveMany({required SenderT that , required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 301, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTReserveManyConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTReserveManyConstMeta => const TaskConstMeta(
            debugName: "SenderT_reserve_many",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedPermitT> tokioNetUnixPipeSenderTReserveOwned({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 302, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTReserveOwnedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTReserveOwnedConstMeta => const TaskConstMeta(
            debugName: "SenderT_reserve_owned",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixPipeSenderTSameChannel({required SenderT that , required SenderT other })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(other, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 303, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSameChannelConstMeta,
            argValues: [that, other],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSameChannelConstMeta => const TaskConstMeta(
            debugName: "SenderT_same_channel",
            argNames: ["that", "other"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTSend({required SenderT that , required T value })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(value, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 304, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSendConstMeta,
            argValues: [that, value],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSendConstMeta => const TaskConstMeta(
            debugName: "SenderT_send",
            argNames: ["that", "value"],
        );
        

@override Future<T> tokioNetUnixPipeSenderTSendReplace({required SenderT that , required T value })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(value, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 305, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSendReplaceConstMeta,
            argValues: [that, value],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSendReplaceConstMeta => const TaskConstMeta(
            debugName: "SenderT_send_replace",
            argNames: ["that", "value"],
        );
        

@override Future<void> tokioNetUnixPipeSenderTSendTimeout({required SenderT that , required T value , required Duration timeout })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(value, serializer);
sse_encode_Chrono_Duration(timeout, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 306, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSendTimeoutConstMeta,
            argValues: [that, value, timeout],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSendTimeoutConstMeta => const TaskConstMeta(
            debugName: "SenderT_send_timeout",
            argNames: ["that", "value", "timeout"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTSenderCount({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 307, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSenderCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSenderCountConstMeta => const TaskConstMeta(
            debugName: "SenderT_sender_count",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTStrongCount({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 308, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTStrongCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTStrongCountConstMeta => const TaskConstMeta(
            debugName: "SenderT_strong_count",
            argNames: ["that"],
        );
        

@override Future<ReceiverT> tokioNetUnixPipeSenderTSubscribe({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 309, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTSubscribeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTSubscribeConstMeta => const TaskConstMeta(
            debugName: "SenderT_subscribe",
            argNames: ["that"],
        );
        

@override Future<PermitT> tokioNetUnixPipeSenderTTryReserve({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 310, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTTryReserveConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTTryReserveConstMeta => const TaskConstMeta(
            debugName: "SenderT_try_reserve",
            argNames: ["that"],
        );
        

@override Future<PermitIteratorT> tokioNetUnixPipeSenderTTryReserveMany({required SenderT that , required BigInt n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_usize(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 311, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTTryReserveManyConstMeta,
            argValues: [that, n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTTryReserveManyConstMeta => const TaskConstMeta(
            debugName: "SenderT_try_reserve_many",
            argNames: ["that", "n"],
        );
        

@override Future<OwnedPermitT> tokioNetUnixPipeSenderTTryReserveOwned({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 312, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTTryReserveOwnedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTTryReserveOwnedConstMeta => const TaskConstMeta(
            debugName: "SenderT_try_reserve_owned",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUnixPipeSenderTTrySend({required SenderT that , required T message })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(message, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 313, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTTrySendConstMeta,
            argValues: [that, message],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTTrySendConstMeta => const TaskConstMeta(
            debugName: "SenderT_try_send",
            argNames: ["that", "message"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTWeakCount({required SenderT that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 314, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTWeakCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTWeakCountConstMeta => const TaskConstMeta(
            debugName: "SenderT_weak_count",
            argNames: ["that"],
        );
        

@override Future<Sender> tokioNetUnixPipeSenderFromFile({required File file })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(file, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 315, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderFromFileConstMeta,
            argValues: [file],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderFromFileConstMeta => const TaskConstMeta(
            debugName: "Sender_from_file",
            argNames: ["file"],
        );
        

@override Future<Sender> tokioNetUnixPipeSenderFromFileUnchecked({required File file })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(file, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 316, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderFromFileUncheckedConstMeta,
            argValues: [file],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderFromFileUncheckedConstMeta => const TaskConstMeta(
            debugName: "Sender_from_file_unchecked",
            argNames: ["file"],
        );
        

@override Future<Sender> tokioNetUnixPipeSenderFromOwnedFd({required OwnedFd ownedFd })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(ownedFd, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 317, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderFromOwnedFdConstMeta,
            argValues: [ownedFd],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderFromOwnedFdConstMeta => const TaskConstMeta(
            debugName: "Sender_from_owned_fd",
            argNames: ["ownedFd"],
        );
        

@override Future<Sender> tokioNetUnixPipeSenderFromOwnedFdUnchecked({required OwnedFd ownedFd })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(ownedFd, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 318, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderFromOwnedFdUncheckedConstMeta,
            argValues: [ownedFd],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderFromOwnedFdUncheckedConstMeta => const TaskConstMeta(
            debugName: "Sender_from_owned_fd_unchecked",
            argNames: ["ownedFd"],
        );
        

@override Future<OwnedFd> tokioNetUnixPipeSenderIntoBlockingFd({required Sender that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 319, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderIntoBlockingFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderIntoBlockingFdConstMeta => const TaskConstMeta(
            debugName: "Sender_into_blocking_fd",
            argNames: ["that"],
        );
        

@override Future<OwnedFd> tokioNetUnixPipeSenderIntoNonblockingFd({required Sender that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 320, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderIntoNonblockingFdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderIntoNonblockingFdConstMeta => const TaskConstMeta(
            debugName: "Sender_into_nonblocking_fd",
            argNames: ["that"],
        );
        

@override Future<PollResult> tokioNetUnixPipeSenderPollWriteReady({required Sender that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 321, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderPollWriteReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderPollWriteReadyConstMeta => const TaskConstMeta(
            debugName: "Sender_poll_write_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<Ready> tokioNetUnixPipeSenderReady({required Sender that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 322, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderReadyConstMeta => const TaskConstMeta(
            debugName: "Sender_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTryWrite({required Sender that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 323, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTryWriteConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTryWriteConstMeta => const TaskConstMeta(
            debugName: "Sender_try_write",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixPipeSenderTryWriteVectored({required Sender that , required List<IoSlice> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 324, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderTryWriteVectoredConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderTryWriteVectoredConstMeta => const TaskConstMeta(
            debugName: "Sender_try_write_vectored",
            argNames: ["that", "buf"],
        );
        

@override Future<void> tokioNetUnixPipeSenderWritable({required Sender that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 325, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipeSenderWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipeSenderWritableConstMeta => const TaskConstMeta(
            debugName: "Sender_writable",
            argNames: ["that"],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindAlarm()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 326, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindAlarmConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindAlarmConstMeta => const TaskConstMeta(
            debugName: "SignalKind_alarm",
            argNames: [],
        );
        

@override Future<CInt> tokioSignalUnixSignalKindAsRawValue({required SignalKind that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 327, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindAsRawValueConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindAsRawValueConstMeta => const TaskConstMeta(
            debugName: "SignalKind_as_raw_value",
            argNames: ["that"],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindChild()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 328, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindChildConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindChildConstMeta => const TaskConstMeta(
            debugName: "SignalKind_child",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindFromRaw({required CInt signum })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(signum, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 329, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindFromRawConstMeta,
            argValues: [signum],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindFromRawConstMeta => const TaskConstMeta(
            debugName: "SignalKind_from_raw",
            argNames: ["signum"],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindHangup()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 330, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindHangupConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindHangupConstMeta => const TaskConstMeta(
            debugName: "SignalKind_hangup",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindInfo()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 331, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindInfoConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindInfoConstMeta => const TaskConstMeta(
            debugName: "SignalKind_info",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindInterrupt()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 332, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindInterruptConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindInterruptConstMeta => const TaskConstMeta(
            debugName: "SignalKind_interrupt",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindIo()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 333, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindIoConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindIoConstMeta => const TaskConstMeta(
            debugName: "SignalKind_io",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindPipe()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 334, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindPipeConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindPipeConstMeta => const TaskConstMeta(
            debugName: "SignalKind_pipe",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindQuit()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 335, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindQuitConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindQuitConstMeta => const TaskConstMeta(
            debugName: "SignalKind_quit",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindTerminate()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 336, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindTerminateConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindTerminateConstMeta => const TaskConstMeta(
            debugName: "SignalKind_terminate",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindUserDefined1()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 337, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindUserDefined1ConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindUserDefined1ConstMeta => const TaskConstMeta(
            debugName: "SignalKind_user_defined1",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindUserDefined2()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 338, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindUserDefined2ConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindUserDefined2ConstMeta => const TaskConstMeta(
            debugName: "SignalKind_user_defined2",
            argNames: [],
        );
        

@override Future<SignalKind> tokioSignalUnixSignalKindWindowChange()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 339, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalKindWindowChangeConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalKindWindowChangeConstMeta => const TaskConstMeta(
            debugName: "SignalKind_window_change",
            argNames: [],
        );
        

@override Future<PollOption> tokioSignalUnixSignalPollRecv({required Signal that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 340, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalPollRecvConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalPollRecvConstMeta => const TaskConstMeta(
            debugName: "Signal_poll_recv",
            argNames: ["that", "cx"],
        );
        

@override Future<void?> tokioSignalUnixSignalRecv({required Signal that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 341, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioSignalUnixSignalRecvConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalRecvConstMeta => const TaskConstMeta(
            debugName: "Signal_recv",
            argNames: ["that"],
        );
        

@override Future<SimplexStream> tokioIoSimplexStreamNewUnsplit({required BigInt maxBufSize })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(maxBufSize, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 342, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoSimplexStreamNewUnsplitConstMeta,
            argValues: [maxBufSize],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoSimplexStreamNewUnsplitConstMeta => const TaskConstMeta(
            debugName: "SimplexStream_new_unsplit",
            argNames: ["maxBufSize"],
        );
        

@override Future<Instant> tokioTimeSleepDeadline({required Sleep that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 343, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeSleepDeadlineConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeSleepDeadlineConstMeta => const TaskConstMeta(
            debugName: "Sleep_deadline",
            argNames: ["that"],
        );
        

@override Future<bool> tokioTimeSleepIsElapsed({required Sleep that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 344, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeSleepIsElapsedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeSleepIsElapsedConstMeta => const TaskConstMeta(
            debugName: "Sleep_is_elapsed",
            argNames: ["that"],
        );
        

@override Future<void> tokioTimeSleepReset({required Sleep that , required Instant deadline })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(deadline, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 345, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeSleepResetConstMeta,
            argValues: [that, deadline],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeSleepResetConstMeta => const TaskConstMeta(
            debugName: "Sleep_reset",
            argNames: ["that", "deadline"],
        );
        

@override Future<Path?> tokioNetUnixSocketAddrAsPathname({required SocketAddr that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 346, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixSocketAddrAsPathnameConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketAddrAsPathnameConstMeta => const TaskConstMeta(
            debugName: "SocketAddr_as_pathname",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUnixSocketAddrIsUnnamed({required SocketAddr that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 347, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixSocketAddrIsUnnamedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketAddrIsUnnamedConstMeta => const TaskConstMeta(
            debugName: "SocketAddr_is_unnamed",
            argNames: ["that"],
        );
        

@override Future<StopwordType> seekstormIndexStopwordTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 348, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexStopwordTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexStopwordTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "StopwordType_default",
            argNames: [],
        );
        

@override Future<(TcpStream,SocketAddr)> tokioNetTcpListenerAccept({required TcpListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 349, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_tcp_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerAcceptConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerAcceptConstMeta => const TaskConstMeta(
            debugName: "TcpListener_accept",
            argNames: ["that"],
        );
        

@override Future<TcpListener> tokioNetTcpListenerFromStd({required TcpListener listener })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(listener, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 350, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerFromStdConstMeta,
            argValues: [listener],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerFromStdConstMeta => const TaskConstMeta(
            debugName: "TcpListener_from_std",
            argNames: ["listener"],
        );
        

@override Future<TcpListener> tokioNetTcpListenerIntoStd({required TcpListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 351, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerIntoStdConstMeta => const TaskConstMeta(
            debugName: "TcpListener_into_std",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetTcpListenerLocalAddr({required TcpListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 352, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerLocalAddrConstMeta => const TaskConstMeta(
            debugName: "TcpListener_local_addr",
            argNames: ["that"],
        );
        

@override Future<PollResultTcpStreamSocketAddr> tokioNetTcpListenerPollAccept({required TcpListener that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 353, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpListenerPollAcceptConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerPollAcceptConstMeta => const TaskConstMeta(
            debugName: "TcpListener_poll_accept",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioNetTcpListenerSetTtl({required TcpListener that , required int ttl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
sse_encode_u_32(ttl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 354, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerSetTtlConstMeta,
            argValues: [that, ttl],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerSetTtlConstMeta => const TaskConstMeta(
            debugName: "TcpListener_set_ttl",
            argNames: ["that", "ttl"],
        );
        

@override Future<int> tokioNetTcpListenerTtl({required TcpListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 355, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpListenerTtlConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpListenerTtlConstMeta => const TaskConstMeta(
            debugName: "TcpListener_ttl",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetTcpSocketBind({required TcpSocket that , required SocketAddr addr })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(addr, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 356, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketBindConstMeta,
            argValues: [that, addr],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketBindConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_bind",
            argNames: ["that", "addr"],
        );
        

@override Future<TcpStream> tokioNetTcpSocketConnect({required TcpSocket that , required SocketAddr addr })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(addr, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 357, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketConnectConstMeta,
            argValues: [that, addr],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketConnectConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_connect",
            argNames: ["that", "addr"],
        );
        

@override Future<TcpSocket> tokioNetTcpSocketFromStdStream({required TcpStream stdStream })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(stdStream, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 358, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpSocketFromStdStreamConstMeta,
            argValues: [stdStream],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketFromStdStreamConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_from_std_stream",
            argNames: ["stdStream"],
        );
        

@override Future<bool> tokioNetTcpSocketKeepalive({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 359, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketKeepaliveConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketKeepaliveConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_keepalive",
            argNames: ["that"],
        );
        

@override Future<Duration?> tokioNetTcpSocketLinger({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 360, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Chrono_Duration,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketLingerConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketLingerConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_linger",
            argNames: ["that"],
        );
        

@override Future<TcpListener> tokioNetTcpSocketListen({required TcpSocket that , required int backlog })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(backlog, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 361, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketListenConstMeta,
            argValues: [that, backlog],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketListenConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_listen",
            argNames: ["that", "backlog"],
        );
        

@override Future<SocketAddr> tokioNetTcpSocketLocalAddr({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 362, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketLocalAddrConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_local_addr",
            argNames: ["that"],
        );
        

@override Future<TcpSocket> tokioNetTcpSocketNewV4()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 363, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketNewV4ConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketNewV4ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_new_v4",
            argNames: [],
        );
        

@override Future<TcpSocket> tokioNetTcpSocketNewV6()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 364, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketNewV6ConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketNewV6ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_new_v6",
            argNames: [],
        );
        

@override Future<bool> tokioNetTcpSocketNodelay({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 365, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketNodelayConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketNodelayConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_nodelay",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetTcpSocketRecvBufferSize({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 366, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketRecvBufferSizeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketRecvBufferSizeConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_recv_buffer_size",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetTcpSocketReuseaddr({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 367, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketReuseaddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketReuseaddrConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_reuseaddr",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetTcpSocketReuseport({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 368, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketReuseportConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketReuseportConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_reuseport",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetTcpSocketSendBufferSize({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 369, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSendBufferSizeConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSendBufferSizeConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_send_buffer_size",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetTcpSocketSetKeepalive({required TcpSocket that , required bool keepalive })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_bool(keepalive, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 370, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetKeepaliveConstMeta,
            argValues: [that, keepalive],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetKeepaliveConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_keepalive",
            argNames: ["that", "keepalive"],
        );
        

@override Future<void> tokioNetTcpSocketSetLinger({required TcpSocket that , Duration? dur })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_opt_box_autoadd_Chrono_Duration(dur, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 371, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetLingerConstMeta,
            argValues: [that, dur],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetLingerConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_linger",
            argNames: ["that", "dur"],
        );
        

@override Future<void> tokioNetTcpSocketSetNodelay({required TcpSocket that , required bool nodelay })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_bool(nodelay, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 372, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetNodelayConstMeta,
            argValues: [that, nodelay],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetNodelayConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_nodelay",
            argNames: ["that", "nodelay"],
        );
        

@override Future<void> tokioNetTcpSocketSetRecvBufferSize({required TcpSocket that , required int size })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(size, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 373, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetRecvBufferSizeConstMeta,
            argValues: [that, size],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetRecvBufferSizeConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_recv_buffer_size",
            argNames: ["that", "size"],
        );
        

@override Future<void> tokioNetTcpSocketSetReuseaddr({required TcpSocket that , required bool reuseaddr })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_bool(reuseaddr, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 374, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetReuseaddrConstMeta,
            argValues: [that, reuseaddr],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetReuseaddrConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_reuseaddr",
            argNames: ["that", "reuseaddr"],
        );
        

@override Future<void> tokioNetTcpSocketSetReuseport({required TcpSocket that , required bool reuseport })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_bool(reuseport, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 375, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetReuseportConstMeta,
            argValues: [that, reuseport],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetReuseportConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_reuseport",
            argNames: ["that", "reuseport"],
        );
        

@override Future<void> tokioNetTcpSocketSetSendBufferSize({required TcpSocket that , required int size })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(size, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 376, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetSendBufferSizeConstMeta,
            argValues: [that, size],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetSendBufferSizeConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_send_buffer_size",
            argNames: ["that", "size"],
        );
        

@override Future<void> tokioNetTcpSocketSetTclassV6({required TcpSocket that , required int tclass })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(tclass, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 377, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetTclassV6ConstMeta,
            argValues: [that, tclass],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetTclassV6ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_tclass_v6",
            argNames: ["that", "tclass"],
        );
        

@override Future<void> tokioNetTcpSocketSetTos({required TcpSocket that , required int tos })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(tos, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 378, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetTosConstMeta,
            argValues: [that, tos],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetTosConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_tos",
            argNames: ["that", "tos"],
        );
        

@override Future<void> tokioNetTcpSocketSetTosV4({required TcpSocket that , required int tos })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
sse_encode_u_32(tos, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 379, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketSetTosV4ConstMeta,
            argValues: [that, tos],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketSetTosV4ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_set_tos_v4",
            argNames: ["that", "tos"],
        );
        

@override Future<Error?> tokioNetTcpSocketTakeError({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 380, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketTakeErrorConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_take_error",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetTcpSocketTclassV6({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 381, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketTclassV6ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketTclassV6ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_tclass_v6",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetTcpSocketTos({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 382, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketTosConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketTosConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_tos",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetTcpSocketTosV4({required TcpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 383, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpSocketTosV4ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpSocketTosV4ConstMeta => const TaskConstMeta(
            debugName: "TcpSocket_tos_v4",
            argNames: ["that"],
        );
        

@override Future<TcpStream> tokioNetTcpStreamFromStd({required TcpStream stream })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(stream, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 384, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamFromStdConstMeta,
            argValues: [stream],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamFromStdConstMeta => const TaskConstMeta(
            debugName: "TcpStream_from_std",
            argNames: ["stream"],
        );
        

@override Future<(OwnedReadHalf,OwnedWriteHalf)> tokioNetTcpStreamIntoSplit({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 385, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_read_half_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_write_half,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpStreamIntoSplitConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamIntoSplitConstMeta => const TaskConstMeta(
            debugName: "TcpStream_into_split",
            argNames: ["that"],
        );
        

@override Future<TcpStream> tokioNetTcpStreamIntoStd({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 386, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamIntoStdConstMeta => const TaskConstMeta(
            debugName: "TcpStream_into_std",
            argNames: ["that"],
        );
        

@override Future<Duration?> tokioNetTcpStreamLinger({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 387, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Chrono_Duration,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamLingerConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamLingerConstMeta => const TaskConstMeta(
            debugName: "TcpStream_linger",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetTcpStreamLocalAddr({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 388, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamLocalAddrConstMeta => const TaskConstMeta(
            debugName: "TcpStream_local_addr",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetTcpStreamNodelay({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 389, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamNodelayConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamNodelayConstMeta => const TaskConstMeta(
            debugName: "TcpStream_nodelay",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetTcpStreamPeek({required TcpStream that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 390, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamPeekConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamPeekConstMeta => const TaskConstMeta(
            debugName: "TcpStream_peek",
            argNames: ["that", "buf"],
        );
        

@override Future<SocketAddr> tokioNetTcpStreamPeerAddr({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 391, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamPeerAddrConstMeta => const TaskConstMeta(
            debugName: "TcpStream_peer_addr",
            argNames: ["that"],
        );
        

@override Future<PollResultUsize> tokioNetTcpStreamPollPeek({required TcpStream that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 392, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpStreamPollPeekConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamPollPeekConstMeta => const TaskConstMeta(
            debugName: "TcpStream_poll_peek",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResult> tokioNetTcpStreamPollReadReady({required TcpStream that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 393, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpStreamPollReadReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamPollReadReadyConstMeta => const TaskConstMeta(
            debugName: "TcpStream_poll_read_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResult> tokioNetTcpStreamPollWriteReady({required TcpStream that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 394, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetTcpStreamPollWriteReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamPollWriteReadyConstMeta => const TaskConstMeta(
            debugName: "TcpStream_poll_write_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioNetTcpStreamReadable({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 395, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamReadableConstMeta => const TaskConstMeta(
            debugName: "TcpStream_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetTcpStreamReady({required TcpStream that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 396, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamReadyConstMeta => const TaskConstMeta(
            debugName: "TcpStream_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<void> tokioNetTcpStreamSetLinger({required TcpStream that , Duration? dur })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_opt_box_autoadd_Chrono_Duration(dur, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 397, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamSetLingerConstMeta,
            argValues: [that, dur],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamSetLingerConstMeta => const TaskConstMeta(
            debugName: "TcpStream_set_linger",
            argNames: ["that", "dur"],
        );
        

@override Future<void> tokioNetTcpStreamSetNodelay({required TcpStream that , required bool nodelay })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_bool(nodelay, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 398, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamSetNodelayConstMeta,
            argValues: [that, nodelay],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamSetNodelayConstMeta => const TaskConstMeta(
            debugName: "TcpStream_set_nodelay",
            argNames: ["that", "nodelay"],
        );
        

@override Future<void> tokioNetTcpStreamSetTtl({required TcpStream that , required int ttl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_u_32(ttl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 399, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamSetTtlConstMeta,
            argValues: [that, ttl],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamSetTtlConstMeta => const TaskConstMeta(
            debugName: "TcpStream_set_ttl",
            argNames: ["that", "ttl"],
        );
        

@override Future<Error?> tokioNetTcpStreamTakeError({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 400, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTakeErrorConstMeta => const TaskConstMeta(
            debugName: "TcpStream_take_error",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetTcpStreamTryRead({required TcpStream that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 401, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTryReadConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTryReadConstMeta => const TaskConstMeta(
            debugName: "TcpStream_try_read",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetTcpStreamTryReadVectored({required TcpStream that , required IoSliceMut bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 402, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTryReadVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTryReadVectoredConstMeta => const TaskConstMeta(
            debugName: "TcpStream_try_read_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<BigInt> tokioNetTcpStreamTryWrite({required TcpStream that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 403, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTryWriteConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTryWriteConstMeta => const TaskConstMeta(
            debugName: "TcpStream_try_write",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetTcpStreamTryWriteVectored({required TcpStream that , required List<IoSlice> bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 404, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTryWriteVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTryWriteVectoredConstMeta => const TaskConstMeta(
            debugName: "TcpStream_try_write_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<int> tokioNetTcpStreamTtl({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 405, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamTtlConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamTtlConstMeta => const TaskConstMeta(
            debugName: "TcpStream_ttl",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetTcpStreamWritable({required TcpStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 406, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetTcpStreamWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetTcpStreamWritableConstMeta => const TaskConstMeta(
            debugName: "TcpStream_writable",
            argNames: ["that"],
        );
        

@override Future<bool> tokioRuntimeTryCurrentErrorIsMissingContext({required TryCurrentError that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 481, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeTryCurrentErrorIsMissingContextConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeTryCurrentErrorIsMissingContextConstMeta => const TaskConstMeta(
            debugName: "TryCurrentError_is_missing_context",
            argNames: ["that"],
        );
        

@override Future<bool> tokioRuntimeTryCurrentErrorIsThreadLocalDestroyed({required TryCurrentError that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 482, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioRuntimeTryCurrentErrorIsThreadLocalDestroyedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioRuntimeTryCurrentErrorIsThreadLocalDestroyedConstMeta => const TaskConstMeta(
            debugName: "TryCurrentError_is_thread_local_destroyed",
            argNames: ["that"],
        );
        

@override Future<GidT> tokioNetUnixUCredGid({required UCred that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 483, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixUCredGidConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixUCredGidConstMeta => const TaskConstMeta(
            debugName: "UCred_gid",
            argNames: ["that"],
        );
        

@override Future<PidT?> tokioNetUnixUCredPid({required UCred that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 484, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixUCredPidConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixUCredPidConstMeta => const TaskConstMeta(
            debugName: "UCred_pid",
            argNames: ["that"],
        );
        

@override Future<UidT> tokioNetUnixUCredUid({required UCred that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 485, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixUCredUidConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixUCredUidConstMeta => const TaskConstMeta(
            debugName: "UCred_uid",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUdpSocketBroadcast({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 486, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketBroadcastConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketBroadcastConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_broadcast",
            argNames: ["that"],
        );
        

@override Future<UdpSocket> tokioNetUdpSocketFromStd({required UdpSocket socket })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(socket, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 487, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketFromStdConstMeta,
            argValues: [socket],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketFromStdConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_from_std",
            argNames: ["socket"],
        );
        

@override Future<UdpSocket> tokioNetUdpSocketIntoStd({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 488, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketIntoStdConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_into_std",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUdpSocketJoinMulticastV4({required UdpSocket that , required Ipv4Addr multiaddr , required Ipv4Addr interface_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(multiaddr, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(interface_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 489, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketJoinMulticastV4ConstMeta,
            argValues: [that, multiaddr, interface_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketJoinMulticastV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_join_multicast_v4",
            argNames: ["that", "multiaddr", "interface_"],
        );
        

@override Future<void> tokioNetUdpSocketJoinMulticastV6({required UdpSocket that , required Ipv6Addr multiaddr , required int interface_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(multiaddr, serializer);
sse_encode_u_32(interface_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 490, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketJoinMulticastV6ConstMeta,
            argValues: [that, multiaddr, interface_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketJoinMulticastV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_join_multicast_v6",
            argNames: ["that", "multiaddr", "interface_"],
        );
        

@override Future<void> tokioNetUdpSocketLeaveMulticastV4({required UdpSocket that , required Ipv4Addr multiaddr , required Ipv4Addr interface_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(multiaddr, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(interface_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 491, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketLeaveMulticastV4ConstMeta,
            argValues: [that, multiaddr, interface_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketLeaveMulticastV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_leave_multicast_v4",
            argNames: ["that", "multiaddr", "interface_"],
        );
        

@override Future<void> tokioNetUdpSocketLeaveMulticastV6({required UdpSocket that , required Ipv6Addr multiaddr , required int interface_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(multiaddr, serializer);
sse_encode_u_32(interface_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 492, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketLeaveMulticastV6ConstMeta,
            argValues: [that, multiaddr, interface_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketLeaveMulticastV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_leave_multicast_v6",
            argNames: ["that", "multiaddr", "interface_"],
        );
        

@override Future<SocketAddr> tokioNetUdpSocketLocalAddr({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 493, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketLocalAddrConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_local_addr",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUdpSocketMulticastLoopV4({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 494, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketMulticastLoopV4ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketMulticastLoopV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_multicast_loop_v4",
            argNames: ["that"],
        );
        

@override Future<bool> tokioNetUdpSocketMulticastLoopV6({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 495, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketMulticastLoopV6ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketMulticastLoopV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_multicast_loop_v6",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetUdpSocketMulticastTtlV4({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 496, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketMulticastTtlV4ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketMulticastTtlV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_multicast_ttl_v4",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUdpSocketPeek({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 497, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketPeekConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPeekConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_peek",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUdpSocketPeekFrom({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 498, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketPeekFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPeekFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_peek_from",
            argNames: ["that", "buf"],
        );
        

@override Future<SocketAddr> tokioNetUdpSocketPeekSender({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 499, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketPeekSenderConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPeekSenderConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_peek_sender",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetUdpSocketPeerAddr({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 500, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPeerAddrConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_peer_addr",
            argNames: ["that"],
        );
        

@override Future<PollResult> tokioNetUdpSocketPollPeek({required UdpSocket that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 501, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollPeekConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollPeekConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_peek",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResultSocketAddr> tokioNetUdpSocketPollPeekFrom({required UdpSocket that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 502, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollPeekFromConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollPeekFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_peek_from",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResultSocketAddr> tokioNetUdpSocketPollPeekSender({required UdpSocket that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 503, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollPeekSenderConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollPeekSenderConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_peek_sender",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResult> tokioNetUdpSocketPollRecv({required UdpSocket that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 504, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollRecvConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollRecvConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_recv",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResultSocketAddr> tokioNetUdpSocketPollRecvFrom({required UdpSocket that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 505, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollRecvFromConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollRecvFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_recv_from",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResult> tokioNetUdpSocketPollRecvReady({required UdpSocket that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 506, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollRecvReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollRecvReadyConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_recv_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResultUsize> tokioNetUdpSocketPollSend({required UdpSocket that , required Context cx , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 507, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollSendConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollSendConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_send",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResult> tokioNetUdpSocketPollSendReady({required UdpSocket that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 508, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollSendReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollSendReadyConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_send_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResultUsize> tokioNetUdpSocketPollSendTo({required UdpSocket that , required Context cx , required List<int> buf , required SocketAddr target })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(target, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 509, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUdpSocketPollSendToConstMeta,
            argValues: [that, cx, buf, target],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketPollSendToConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_poll_send_to",
            argNames: ["that", "cx", "buf", "target"],
        );
        

@override Future<void> tokioNetUdpSocketReadable({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 510, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketReadableConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetUdpSocketReady({required UdpSocket that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 511, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketReadyConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<BigInt> tokioNetUdpSocketRecv({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 512, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketRecvConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketRecvConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_recv",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUdpSocketRecvFrom({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 513, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketRecvFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketRecvFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_recv_from",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUdpSocketSend({required UdpSocket that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 514, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSendConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSendConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_send",
            argNames: ["that", "buf"],
        );
        

@override Future<void> tokioNetUdpSocketSetBroadcast({required UdpSocket that , required bool on_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_bool(on_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 515, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetBroadcastConstMeta,
            argValues: [that, on_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetBroadcastConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_broadcast",
            argNames: ["that", "on_"],
        );
        

@override Future<void> tokioNetUdpSocketSetMulticastLoopV4({required UdpSocket that , required bool on_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_bool(on_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 516, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetMulticastLoopV4ConstMeta,
            argValues: [that, on_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetMulticastLoopV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_multicast_loop_v4",
            argNames: ["that", "on_"],
        );
        

@override Future<void> tokioNetUdpSocketSetMulticastLoopV6({required UdpSocket that , required bool on_ })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_bool(on_, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 517, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetMulticastLoopV6ConstMeta,
            argValues: [that, on_],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetMulticastLoopV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_multicast_loop_v6",
            argNames: ["that", "on_"],
        );
        

@override Future<void> tokioNetUdpSocketSetMulticastTtlV4({required UdpSocket that , required int ttl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_u_32(ttl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 518, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetMulticastTtlV4ConstMeta,
            argValues: [that, ttl],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetMulticastTtlV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_multicast_ttl_v4",
            argNames: ["that", "ttl"],
        );
        

@override Future<void> tokioNetUdpSocketSetTclassV6({required UdpSocket that , required int tclass })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_u_32(tclass, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 519, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetTclassV6ConstMeta,
            argValues: [that, tclass],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetTclassV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_tclass_v6",
            argNames: ["that", "tclass"],
        );
        

@override Future<void> tokioNetUdpSocketSetTos({required UdpSocket that , required int tos })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_u_32(tos, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 520, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetTosConstMeta,
            argValues: [that, tos],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetTosConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_tos",
            argNames: ["that", "tos"],
        );
        

@override Future<void> tokioNetUdpSocketSetTosV4({required UdpSocket that , required int tos })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_u_32(tos, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 521, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetTosV4ConstMeta,
            argValues: [that, tos],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetTosV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_tos_v4",
            argNames: ["that", "tos"],
        );
        

@override Future<void> tokioNetUdpSocketSetTtl({required UdpSocket that , required int ttl })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_u_32(ttl, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 522, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketSetTtlConstMeta,
            argValues: [that, ttl],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketSetTtlConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_set_ttl",
            argNames: ["that", "ttl"],
        );
        

@override Future<Error?> tokioNetUdpSocketTakeError({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 523, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTakeErrorConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_take_error",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetUdpSocketTclassV6({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 524, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTclassV6ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTclassV6ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_tclass_v6",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetUdpSocketTos({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 525, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTosConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTosConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_tos",
            argNames: ["that"],
        );
        

@override Future<int> tokioNetUdpSocketTosV4({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 526, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTosV4ConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTosV4ConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_tos_v4",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUdpSocketTryPeek({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 527, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTryPeekConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTryPeekConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_peek",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUdpSocketTryPeekFrom({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 528, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTryPeekFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTryPeekFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_peek_from",
            argNames: ["that", "buf"],
        );
        

@override Future<SocketAddr> tokioNetUdpSocketTryPeekSender({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 529, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTryPeekSenderConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTryPeekSenderConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_peek_sender",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUdpSocketTryRecv({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 530, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTryRecvConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTryRecvConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_recv",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUdpSocketTryRecvFrom({required UdpSocket that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 531, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTryRecvFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTryRecvFromConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_recv_from",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUdpSocketTrySend({required UdpSocket that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 532, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTrySendConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTrySendConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_send",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUdpSocketTrySendTo({required UdpSocket that , required List<int> buf , required SocketAddr target })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(target, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 533, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTrySendToConstMeta,
            argValues: [that, buf, target],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTrySendToConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_try_send_to",
            argNames: ["that", "buf", "target"],
        );
        

@override Future<int> tokioNetUdpSocketTtl({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 534, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketTtlConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketTtlConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_ttl",
            argNames: ["that"],
        );
        

@override Future<void> tokioNetUdpSocketWritable({required UdpSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 535, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUdpSocketWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUdpSocketWritableConstMeta => const TaskConstMeta(
            debugName: "UdpSocket_writable",
            argNames: ["that"],
        );
        

@override Future<UnixDatagram> tokioNetUnixDatagramFromStd({required UnixDatagram datagram })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(datagram, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 536, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramFromStdConstMeta,
            argValues: [datagram],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramFromStdConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_from_std",
            argNames: ["datagram"],
        );
        

@override Future<UnixDatagram> tokioNetUnixDatagramIntoStd({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 537, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramIntoStdConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_into_std",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetUnixDatagramLocalAddr({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 538, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramLocalAddrConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_local_addr",
            argNames: ["that"],
        );
        

@override Future<(UnixDatagram,UnixDatagram)> tokioNetUnixDatagramPair()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 539, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramPairConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPairConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_pair",
            argNames: [],
        );
        

@override Future<SocketAddr> tokioNetUnixDatagramPeerAddr({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 540, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPeerAddrConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_peer_addr",
            argNames: ["that"],
        );
        

@override Future<PollResult> tokioNetUnixDatagramPollRecv({required UnixDatagram that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 541, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixDatagramPollRecvConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPollRecvConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_poll_recv",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResultSocketAddr> tokioNetUnixDatagramPollRecvFrom({required UnixDatagram that , required Context cx , required ReadBuf buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 542, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixDatagramPollRecvFromConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPollRecvFromConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_poll_recv_from",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResult> tokioNetUnixDatagramPollRecvReady({required UnixDatagram that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 543, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixDatagramPollRecvReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPollRecvReadyConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_poll_recv_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResultUsize> tokioNetUnixDatagramPollSend({required UnixDatagram that , required Context cx , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 544, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixDatagramPollSendConstMeta,
            argValues: [that, cx, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPollSendConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_poll_send",
            argNames: ["that", "cx", "buf"],
        );
        

@override Future<PollResult> tokioNetUnixDatagramPollSendReady({required UnixDatagram that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 545, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixDatagramPollSendReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramPollSendReadyConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_poll_send_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioNetUnixDatagramReadable({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 546, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramReadableConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetUnixDatagramReady({required UnixDatagram that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 547, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramReadyConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<BigInt> tokioNetUnixDatagramRecv({required UnixDatagram that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 548, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramRecvConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramRecvConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_recv",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUnixDatagramRecvFrom({required UnixDatagram that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 549, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramRecvFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramRecvFromConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_recv_from",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixDatagramSend({required UnixDatagram that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 550, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramSendConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramSendConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_send",
            argNames: ["that", "buf"],
        );
        

@override Future<void> tokioNetUnixDatagramShutdown({required UnixDatagram that , required Shutdown how })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(how, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 551, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramShutdownConstMeta,
            argValues: [that, how],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramShutdownConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_shutdown",
            argNames: ["that", "how"],
        );
        

@override Future<Error?> tokioNetUnixDatagramTakeError({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 552, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramTakeErrorConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_take_error",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixDatagramTryRecv({required UnixDatagram that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 553, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramTryRecvConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramTryRecvConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_try_recv",
            argNames: ["that", "buf"],
        );
        

@override Future<(BigInt,SocketAddr)> tokioNetUnixDatagramTryRecvFrom({required UnixDatagram that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 554, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramTryRecvFromConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramTryRecvFromConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_try_recv_from",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixDatagramTrySend({required UnixDatagram that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 555, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramTrySendConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramTrySendConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_try_send",
            argNames: ["that", "buf"],
        );
        

@override Future<UnixDatagram> tokioNetUnixDatagramUnbound()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 556, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramUnboundConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramUnboundConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_unbound",
            argNames: [],
        );
        

@override Future<void> tokioNetUnixDatagramWritable({required UnixDatagram that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 557, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixDatagramWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixDatagramWritableConstMeta => const TaskConstMeta(
            debugName: "UnixDatagram_writable",
            argNames: ["that"],
        );
        

@override Future<(UnixStream,SocketAddr)> tokioNetUnixListenerAccept({required UnixListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 558, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixListenerAcceptConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerAcceptConstMeta => const TaskConstMeta(
            debugName: "UnixListener_accept",
            argNames: ["that"],
        );
        

@override Future<UnixListener> tokioNetUnixListenerFromStd({required UnixListener listener })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(listener, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 559, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixListenerFromStdConstMeta,
            argValues: [listener],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerFromStdConstMeta => const TaskConstMeta(
            debugName: "UnixListener_from_std",
            argNames: ["listener"],
        );
        

@override Future<UnixListener> tokioNetUnixListenerIntoStd({required UnixListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 560, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixListenerIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerIntoStdConstMeta => const TaskConstMeta(
            debugName: "UnixListener_into_std",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetUnixListenerLocalAddr({required UnixListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 561, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixListenerLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerLocalAddrConstMeta => const TaskConstMeta(
            debugName: "UnixListener_local_addr",
            argNames: ["that"],
        );
        

@override Future<PollResultUnixStreamSocketAddr> tokioNetUnixListenerPollAccept({required UnixListener that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 562, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixListenerPollAcceptConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerPollAcceptConstMeta => const TaskConstMeta(
            debugName: "UnixListener_poll_accept",
            argNames: ["that", "cx"],
        );
        

@override Future<Error?> tokioNetUnixListenerTakeError({required UnixListener that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 563, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixListenerTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixListenerTakeErrorConstMeta => const TaskConstMeta(
            debugName: "UnixListener_take_error",
            argNames: ["that"],
        );
        

@override Future<UnixDatagram> tokioNetUnixSocketDatagram({required UnixSocket that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 564, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixSocketDatagramConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketDatagramConstMeta => const TaskConstMeta(
            debugName: "UnixSocket_datagram",
            argNames: ["that"],
        );
        

@override Future<UnixListener> tokioNetUnixSocketListen({required UnixSocket that , required int backlog })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(that, serializer);
sse_encode_u_32(backlog, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 565, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixSocketListenConstMeta,
            argValues: [that, backlog],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketListenConstMeta => const TaskConstMeta(
            debugName: "UnixSocket_listen",
            argNames: ["that", "backlog"],
        );
        

@override Future<UnixSocket> tokioNetUnixSocketNewDatagram()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 566, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixSocketNewDatagramConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketNewDatagramConstMeta => const TaskConstMeta(
            debugName: "UnixSocket_new_datagram",
            argNames: [],
        );
        

@override Future<UnixSocket> tokioNetUnixSocketNewStream()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 567, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixSocketNewStreamConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixSocketNewStreamConstMeta => const TaskConstMeta(
            debugName: "UnixSocket_new_stream",
            argNames: [],
        );
        

@override Future<UnixStream> tokioNetUnixStreamFromStd({required UnixStream stream })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(stream, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 568, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamFromStdConstMeta,
            argValues: [stream],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamFromStdConstMeta => const TaskConstMeta(
            debugName: "UnixStream_from_std",
            argNames: ["stream"],
        );
        

@override Future<(OwnedReadHalf,OwnedWriteHalf)> tokioNetUnixStreamIntoSplit({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 569, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_read_half_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_write_half,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixStreamIntoSplitConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamIntoSplitConstMeta => const TaskConstMeta(
            debugName: "UnixStream_into_split",
            argNames: ["that"],
        );
        

@override Future<UnixStream> tokioNetUnixStreamIntoStd({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 570, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamIntoStdConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamIntoStdConstMeta => const TaskConstMeta(
            debugName: "UnixStream_into_std",
            argNames: ["that"],
        );
        

@override Future<SocketAddr> tokioNetUnixStreamLocalAddr({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 571, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamLocalAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamLocalAddrConstMeta => const TaskConstMeta(
            debugName: "UnixStream_local_addr",
            argNames: ["that"],
        );
        

@override Future<(UnixStream,UnixStream)> tokioNetUnixStreamPair()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 572, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamPairConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamPairConstMeta => const TaskConstMeta(
            debugName: "UnixStream_pair",
            argNames: [],
        );
        

@override Future<SocketAddr> tokioNetUnixStreamPeerAddr({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 573, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamPeerAddrConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamPeerAddrConstMeta => const TaskConstMeta(
            debugName: "UnixStream_peer_addr",
            argNames: ["that"],
        );
        

@override Future<UCred> tokioNetUnixStreamPeerCred({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 574, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamPeerCredConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamPeerCredConstMeta => const TaskConstMeta(
            debugName: "UnixStream_peer_cred",
            argNames: ["that"],
        );
        

@override Future<PollResult> tokioNetUnixStreamPollReadReady({required UnixStream that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 575, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixStreamPollReadReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamPollReadReadyConstMeta => const TaskConstMeta(
            debugName: "UnixStream_poll_read_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<PollResult> tokioNetUnixStreamPollWriteReady({required UnixStream that , required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 576, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioNetUnixStreamPollWriteReadyConstMeta,
            argValues: [that, cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamPollWriteReadyConstMeta => const TaskConstMeta(
            debugName: "UnixStream_poll_write_ready",
            argNames: ["that", "cx"],
        );
        

@override Future<void> tokioNetUnixStreamReadable({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 577, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamReadableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamReadableConstMeta => const TaskConstMeta(
            debugName: "UnixStream_readable",
            argNames: ["that"],
        );
        

@override Future<Ready> tokioNetUnixStreamReady({required UnixStream that , required Interest interest })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(interest, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 578, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamReadyConstMeta,
            argValues: [that, interest],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamReadyConstMeta => const TaskConstMeta(
            debugName: "UnixStream_ready",
            argNames: ["that", "interest"],
        );
        

@override Future<Error?> tokioNetUnixStreamTakeError({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 579, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamTakeErrorConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamTakeErrorConstMeta => const TaskConstMeta(
            debugName: "UnixStream_take_error",
            argNames: ["that"],
        );
        

@override Future<BigInt> tokioNetUnixStreamTryRead({required UnixStream that , required U8 buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 580, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamTryReadConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamTryReadConstMeta => const TaskConstMeta(
            debugName: "UnixStream_try_read",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixStreamTryReadVectored({required UnixStream that , required IoSliceMut bufs })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(bufs, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 581, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamTryReadVectoredConstMeta,
            argValues: [that, bufs],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamTryReadVectoredConstMeta => const TaskConstMeta(
            debugName: "UnixStream_try_read_vectored",
            argNames: ["that", "bufs"],
        );
        

@override Future<BigInt> tokioNetUnixStreamTryWrite({required UnixStream that , required List<int> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_list_prim_u_8_loose(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 582, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamTryWriteConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamTryWriteConstMeta => const TaskConstMeta(
            debugName: "UnixStream_try_write",
            argNames: ["that", "buf"],
        );
        

@override Future<BigInt> tokioNetUnixStreamTryWriteVectored({required UnixStream that , required List<IoSlice> buf })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(buf, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 583, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamTryWriteVectoredConstMeta,
            argValues: [that, buf],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamTryWriteVectoredConstMeta => const TaskConstMeta(
            debugName: "UnixStream_try_write_vectored",
            argNames: ["that", "buf"],
        );
        

@override Future<void> tokioNetUnixStreamWritable({required UnixStream that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 584, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixStreamWritableConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixStreamWritableConstMeta => const TaskConstMeta(
            debugName: "UnixStream_writable",
            argNames: ["that"],
        );
        

@override Future<ValueType> seekstormIndexValueTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 585, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexValueTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexValueTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "ValueType_default",
            argNames: [],
        );
        

@override Future<void> tokioTimeAdvance({required Duration duration })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Chrono_Duration(duration, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 586, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeAdvanceConstMeta,
            argValues: [duration],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeAdvanceConstMeta => const TaskConstMeta(
            debugName: "advance",
            argNames: ["duration"],
        );
        

@override Future<CompressionType> seekstormIndexCompressionTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 587, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_compression_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexCompressionTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexCompressionTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "compression_type_default",
            argNames: [],
        );
        

@override Future<void> tokioTaskCoopConsumeBudget()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 588, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskCoopConsumeBudgetConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskCoopConsumeBudgetConstMeta => const TaskConstMeta(
            debugName: "consume_budget",
            argNames: [],
        );
        

@override Future<ArcIndex> seekstormIndexCreateIndex({required Path indexPath , required IndexMetaObject meta , required List<SchemaField> schema , required List<Synonym> synonyms , required BigInt segmentNumberBits1 , required bool mute , BigInt? forceShardNumber })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(indexPath, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(meta, serializer);
sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(schema, serializer);
sse_encode_list_synonym(synonyms, serializer);
sse_encode_usize(segmentNumberBits1, serializer);
sse_encode_bool(mute, serializer);
sse_encode_opt_box_autoadd_usize(forceShardNumber, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 589, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexCreateIndexConstMeta,
            argValues: [indexPath, meta, schema, synonyms, segmentNumberBits1, mute, forceShardNumber],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexCreateIndexConstMeta => const TaskConstMeta(
            debugName: "create_index",
            argNames: ["indexPath", "meta", "schema", "synonyms", "segmentNumberBits1", "mute", "forceShardNumber"],
        );
        

@override Future<void> tokioSignalCtrlC()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 590, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioSignalCtrlCConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalCtrlCConstMeta => const TaskConstMeta(
            debugName: "ctrl_c",
            argNames: [],
        );
        

@override Future<Float64List> seekstormGeoSearchDecodeMorton2D({required BigInt code })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(code, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 591, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_f_64_strict,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormGeoSearchDecodeMorton2DConstMeta,
            argValues: [code],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormGeoSearchDecodeMorton2DConstMeta => const TaskConstMeta(
            debugName: "decode_morton_2_d",
            argNames: ["code"],
        );
        

@override Future<DistanceField> seekstormIndexDistanceFieldDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 592, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_distance_field,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexDistanceFieldDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexDistanceFieldDefaultConstMeta => const TaskConstMeta(
            debugName: "distance_field_default",
            argNames: [],
        );
        

@override Future<(DuplexStream,DuplexStream)> tokioIoDuplex({required BigInt maxBufSize })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(maxBufSize, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 593, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoDuplexConstMeta,
            argValues: [maxBufSize],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoDuplexConstMeta => const TaskConstMeta(
            debugName: "duplex",
            argNames: ["maxBufSize"],
        );
        

@override Future<Empty> tokioIoEmpty()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 594, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoEmptyConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoEmptyConstMeta => const TaskConstMeta(
            debugName: "empty",
            argNames: [],
        );
        

@override Future<BigInt> seekstormGeoSearchEncodeMorton2D({required List<double> point })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_f_64_loose(point, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 595, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormGeoSearchEncodeMorton2DConstMeta,
            argValues: [point],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormGeoSearchEncodeMorton2DConstMeta => const TaskConstMeta(
            debugName: "encode_morton_2_d",
            argNames: ["point"],
        );
        

@override Future<double> seekstormGeoSearchEuclidianDistance({required List<double> point1 , required List<double> point2 , required DistanceUnit unit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_f_64_loose(point1, serializer);
sse_encode_list_prim_f_64_loose(point2, serializer);
sse_encode_distance_unit(unit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 596, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_f_64,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormGeoSearchEuclidianDistanceConstMeta,
            argValues: [point1, point2, unit],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormGeoSearchEuclidianDistanceConstMeta => const TaskConstMeta(
            debugName: "euclidian_distance",
            argNames: ["point1", "point2", "unit"],
        );
        

@override Future<FieldType> seekstormIndexFieldTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 597, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_field_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexFieldTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexFieldTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "field_type_default",
            argNames: [],
        );
        

@override String crateApiSimpleGreet({required String name })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(name, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 598)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiSimpleGreetConstMeta,
            argValues: [name],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
            debugName: "greet",
            argNames: ["name"],
        );
        

@override Future<bool> tokioTaskCoopHasBudgetRemaining()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 599, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskCoopHasBudgetRemainingConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskCoopHasBudgetRemainingConstMeta => const TaskConstMeta(
            debugName: "has_budget_remaining",
            argNames: [],
        );
        

@override Future<Highlight> seekstormHighlighterHighlightDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 600, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_highlight,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormHighlighterHighlightDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormHighlighterHighlightDefaultConstMeta => const TaskConstMeta(
            debugName: "highlight_default",
            argNames: [],
        );
        

@override Future<Highlighter> seekstormHighlighterHighlighter({required ArcIndex indexArc , required List<Highlight> highlights , required List<String> queryTermsVec })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(indexArc, serializer);
sse_encode_list_highlight(highlights, serializer);
sse_encode_list_String(queryTermsVec, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 601, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormHighlighterHighlighterConstMeta,
            argValues: [indexArc, highlights, queryTermsVec],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormHighlighterHighlighterConstMeta => const TaskConstMeta(
            debugName: "highlighter",
            argNames: ["indexArc", "highlights", "queryTermsVec"],
        );
        

@override Future<void> crateApiSimpleInitApp()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 602, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiSimpleInitAppConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
            debugName: "init_app",
            argNames: [],
        );
        

@override Future<Interval> tokioTimeInterval({required Duration period })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Chrono_Duration(period, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 603, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalConstMeta,
            argValues: [period],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalConstMeta => const TaskConstMeta(
            debugName: "interval",
            argNames: ["period"],
        );
        

@override Future<Interval> tokioTimeIntervalAt({required Instant start , required Duration period })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(start, serializer);
sse_encode_Chrono_Duration(period, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 604, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeIntervalAtConstMeta,
            argValues: [start, period],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeIntervalAtConstMeta => const TaskConstMeta(
            debugName: "interval_at",
            argNames: ["start", "period"],
        );
        

@override Future<MissedTickBehavior> tokioTimeMissedTickBehaviorDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 605, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_missed_tick_behavior,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeMissedTickBehaviorDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeMissedTickBehaviorDefaultConstMeta => const TaskConstMeta(
            debugName: "missed_tick_behavior_default",
            argNames: [],
        );
        

@override Future<Ordering> seekstormGeoSearchMortonOrdering({required BigInt morton1 , required BigInt morton2 , required List<double> basePoint , required SortOrder order })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(morton1, serializer);
sse_encode_u_64(morton2, serializer);
sse_encode_list_prim_f_64_loose(basePoint, serializer);
sse_encode_sort_order(order, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 606, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormGeoSearchMortonOrderingConstMeta,
            argValues: [morton1, morton2, basePoint, order],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormGeoSearchMortonOrderingConstMeta => const TaskConstMeta(
            debugName: "morton_ordering",
            argNames: ["morton1", "morton2", "basePoint", "order"],
        );
        

@override Future<NgramType> seekstormIndexNgramTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 607, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_ngram_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexNgramTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexNgramTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "ngram_type_default",
            argNames: [],
        );
        

@override Future<ArcIndex> seekstormIndexOpenIndex({required Path indexPath , required bool mute })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(indexPath, serializer);
sse_encode_bool(mute, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 608, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kSeekstormIndexOpenIndexConstMeta,
            argValues: [indexPath, mute],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexOpenIndexConstMeta => const TaskConstMeta(
            debugName: "open_index",
            argNames: ["indexPath", "mute"],
        );
        

@override Future<void> tokioTimePause()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 609, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimePauseConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimePauseConstMeta => const TaskConstMeta(
            debugName: "pause",
            argNames: [],
        );
        

@override Future<(Sender,Receiver)> tokioNetUnixPipePipe()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 610, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_sender_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_receiver,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioNetUnixPipePipeConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioNetUnixPipePipeConstMeta => const TaskConstMeta(
            debugName: "pipe",
            argNames: [],
        );
        

@override Future<RangeU64> seekstormGeoSearchPointDistanceToMortonRange({required List<double> point , required double distance , required DistanceUnit unit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_f_64_loose(point, serializer);
sse_encode_f_64(distance, serializer);
sse_encode_distance_unit(unit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 611, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormGeoSearchPointDistanceToMortonRangeConstMeta,
            argValues: [point, distance, unit],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormGeoSearchPointDistanceToMortonRangeConstMeta => const TaskConstMeta(
            debugName: "point_distance_to_morton_range",
            argNames: ["point", "distance", "unit"],
        );
        

@override Future<Poll> tokioMacrosSupportPollBudgetAvailable({required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 612, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioMacrosSupportPollBudgetAvailableConstMeta,
            argValues: [cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioMacrosSupportPollBudgetAvailableConstMeta => const TaskConstMeta(
            debugName: "poll_budget_available",
            argNames: ["cx"],
        );
        

@override Future<PollRestoreOnPending> tokioTaskCoopPollProceed({required Context cx })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(cx, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 613, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskCoopPollProceedConstMeta,
            argValues: [cx],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskCoopPollProceedConstMeta => const TaskConstMeta(
            debugName: "poll_proceed",
            argNames: ["cx"],
        );
        

@override Future<QueryType> seekstormSearchQueryTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 614, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_query_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchQueryTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchQueryTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "query_type_default",
            argNames: [],
        );
        

@override Future<RangeType> seekstormSearchRangeTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 615, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_range_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchRangeTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchRangeTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "range_type_default",
            argNames: [],
        );
        

@override Future<Repeat> tokioIoRepeat({required int byte })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_8(byte, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 616, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoRepeatConstMeta,
            argValues: [byte],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoRepeatConstMeta => const TaskConstMeta(
            debugName: "repeat",
            argNames: ["byte"],
        );
        

@override Future<ResultType> seekstormSearchResultTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 617, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_result_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormSearchResultTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormSearchResultTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "result_type_default",
            argNames: [],
        );
        

@override Future<void> tokioTimeResume()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 618, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeResumeConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeResumeConstMeta => const TaskConstMeta(
            debugName: "resume",
            argNames: [],
        );
        

@override Future<void> crateApiKeywordSearchSearchFnDeleteIndex({required SearchFn that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_search_fn(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 619, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiKeywordSearchSearchFnDeleteIndexConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiKeywordSearchSearchFnDeleteIndexConstMeta => const TaskConstMeta(
            debugName: "search_fn_delete_index",
            argNames: ["that"],
        );
        

@override Future<void> crateApiKeywordSearchSearchFnIngestPdfDir({required SearchFn that , required Path dirPath })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_search_fn(that, serializer);
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(dirPath, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 620, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiKeywordSearchSearchFnIngestPdfDirConstMeta,
            argValues: [that, dirPath],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiKeywordSearchSearchFnIngestPdfDirConstMeta => const TaskConstMeta(
            debugName: "search_fn_ingest_pdf_dir",
            argNames: ["that", "dirPath"],
        );
        

@override Future<SearchFn> crateApiKeywordSearchSearchFnNew({required SearchFn that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_search_fn(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 621, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_search_fn,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiKeywordSearchSearchFnNewConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiKeywordSearchSearchFnNewConstMeta => const TaskConstMeta(
            debugName: "search_fn_new",
            argNames: ["that"],
        );
        

@override Future<Signal> tokioSignalUnixSignal({required SignalKind kind })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(kind, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 622, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kTokioSignalUnixSignalConstMeta,
            argValues: [kind],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioSignalUnixSignalConstMeta => const TaskConstMeta(
            debugName: "signal",
            argNames: ["kind"],
        );
        

@override Future<SimilarityType> seekstormIndexSimilarityTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 623, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_similarity_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexSimilarityTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexSimilarityTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "similarity_type_default",
            argNames: [],
        );
        

@override Future<(ReadHalfSimplexStream,WriteHalfSimplexStream)> tokioIoSimplex({required BigInt maxBufSize })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(maxBufSize, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 624, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_read_half_simplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_write_half_simplex_stream,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoSimplexConstMeta,
            argValues: [maxBufSize],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoSimplexConstMeta => const TaskConstMeta(
            debugName: "simplex",
            argNames: ["maxBufSize"],
        );
        

@override Future<Sink> tokioIoSink()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 625, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoSinkConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoSinkConstMeta => const TaskConstMeta(
            debugName: "sink",
            argNames: [],
        );
        

@override Future<Sleep> tokioTimeSleep({required Duration duration })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Chrono_Duration(duration, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 626, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeSleepConstMeta,
            argValues: [duration],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeSleepConstMeta => const TaskConstMeta(
            debugName: "sleep",
            argNames: ["duration"],
        );
        

@override Future<Sleep> tokioTimeSleepUntil({required Instant deadline })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(deadline, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 627, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTimeSleepUntilConstMeta,
            argValues: [deadline],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTimeSleepUntilConstMeta => const TaskConstMeta(
            debugName: "sleep_until",
            argNames: ["deadline"],
        );
        

@override Future<Stderr> tokioIoStderr()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 628, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoStderrConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoStderrConstMeta => const TaskConstMeta(
            debugName: "stderr",
            argNames: [],
        );
        

@override Future<Stdin> tokioIoStdin()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 629, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoStdinConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoStdinConstMeta => const TaskConstMeta(
            debugName: "stdin",
            argNames: [],
        );
        

@override Future<Stdout> tokioIoStdout()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 630, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioIoStdoutConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioIoStdoutConstMeta => const TaskConstMeta(
            debugName: "stdout",
            argNames: [],
        );
        

@override Future<StemmerType> seekstormIndexStemmerTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 631, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_stemmer_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexStemmerTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexStemmerTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "stemmer_type_default",
            argNames: [],
        );
        

@override Future<String> seekstormUtilsSubstring({required String source , required BigInt start , required BigInt length })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(source, serializer);
sse_encode_usize(start, serializer);
sse_encode_usize(length, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 632, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormUtilsSubstringConstMeta,
            argValues: [source, start, length],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormUtilsSubstringConstMeta => const TaskConstMeta(
            debugName: "substring",
            argNames: ["source", "start", "length"],
        );
        

@override Future<int> tokioMacrosSupportThreadRngN({required int n })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_32(n, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 633, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioMacrosSupportThreadRngNConstMeta,
            argValues: [n],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioMacrosSupportThreadRngNConstMeta => const TaskConstMeta(
            debugName: "thread_rng_n",
            argNames: ["n"],
        );
        

@override Future<TokenizerType> seekstormIndexTokenizerTypeDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 634, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_tokenizer_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexTokenizerTypeDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexTokenizerTypeDefaultConstMeta => const TaskConstMeta(
            debugName: "tokenizer_type_default",
            argNames: [],
        );
        

@override Future<void> seekstormUtilsTruncate({required String source , required BigInt maxChars })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(source, serializer);
sse_encode_usize(maxChars, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 635, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormUtilsTruncateConstMeta,
            argValues: [source, maxChars],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormUtilsTruncateConstMeta => const TaskConstMeta(
            debugName: "truncate",
            argNames: ["source", "maxChars"],
        );
        

@override Future<void> seekstormIndexVersion()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 636, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kSeekstormIndexVersionConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kSeekstormIndexVersionConstMeta => const TaskConstMeta(
            debugName: "version",
            argNames: [],
        );
        

@override Future<void> tokioTaskYieldNow()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 637, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kTokioTaskYieldNowConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kTokioTaskYieldNowConstMeta => const TaskConstMeta(
            debugName: "yield_now",
            argNames: [],
        );
        

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_AHashMapStringFacet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_AHashMapStringFacet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_AcquireError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_AcquireError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ArcIndex => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ArcIndex => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Barrier => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Barrier => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BarrierWaitResult => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BarrierWaitResult => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Child => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Child => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStderr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStderr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStdin => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStdin => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ChildStdout => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ChildStdout => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Command => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Command => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Context => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Context => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_DocumentItem => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_DocumentItem => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_DuplexStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_DuplexStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Empty => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Empty => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_EnterGuard => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_EnterGuard => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Error => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Error => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExitStatus => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExitStatus => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetField => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetField => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetFilter => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetFilter => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FacetValue => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FacetValue => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_File => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_File => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FileType => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FileType => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FillBufSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FillBufSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FlushSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FlushSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_FrequentwordType => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_FrequentwordType => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Handle => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Handle => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Highlighter => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Highlighter => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Id => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Id => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Index => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Index => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IndexMapStringVecStringUsize => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IndexMapStringVecStringUsize => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IndexMetaObject => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IndexMetaObject => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Instant => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Instant => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Interest => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Interest => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Interval => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Interval => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IoSliceMut => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IoSliceMut => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_IoSlice => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_IoSlice => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ipv4Addr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ipv4Addr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ipv6Addr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ipv6Addr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LinesSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LinesSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LocalEnterGuard => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LocalEnterGuard => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_LocalSet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_LocalSet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MinMaxField => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MinMaxField => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MinMaxFieldJson => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MinMaxFieldJson => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Notified => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Notified => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Notify => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Notify => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OpenOptions => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OpenOptions => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ordering => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ordering => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedFd => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedFd => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedNotified => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedNotified => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedPermitT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedPermitT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedReadHalf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedReadHalf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedSemaphorePermit => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedSemaphorePermit => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_OwnedWriteHalf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_OwnedWriteHalf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Path => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Path => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PdfDocument => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PdfDocument => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PermitIteratorT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PermitIteratorT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PermitT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PermitT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Poll => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Poll => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollInstant => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollInstant => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollOption => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollOption => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollOptionT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollOptionT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollRestoreOnPending => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollRestoreOnPending => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResult => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResult => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultSocketAddr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultSocketAddr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultTcpStreamSocketAddr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultTcpStreamSocketAddr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultUnixStreamSocketAddr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultUnixStreamSocketAddr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollResultUsize => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollResultUsize => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PollUsize => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PollUsize => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_QueryFacet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_QueryFacet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_QueryRewriting => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_QueryRewriting => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ranges => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ranges => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RangeU64 => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RangeU64 => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadBuf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadBuf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadF64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadF64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadHalfSimplexStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadHalfSimplexStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI128LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI128LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI128MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI128MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI16LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI16LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI16MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI16MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadI8MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadI8MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU128LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU128LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU128MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU128MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU16LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU16LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU16MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU16MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReadU8MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReadU8MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Ready => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Ready => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Receiver => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Receiver => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReceiverT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReceiverT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RecvError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RecvError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RefT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RefT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Repeat => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Repeat => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RestoreOnPending => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RestoreOnPending => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Result => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Result => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ResultObject => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ResultObject => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ResultSort => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ResultSort => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ReuniteError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ReuniteError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Runtime => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Runtime => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_RuntimeMetrics => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_RuntimeMetrics => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SchemaField => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SchemaField => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SeekFrom => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SeekFrom => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SeekSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SeekSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Semaphore => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Semaphore => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SemaphorePermit => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SemaphorePermit => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendErrorT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendErrorT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SendTimeoutErrorT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SendTimeoutErrorT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sender => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sender => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SenderT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SenderT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Shutdown => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Shutdown => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ShutdownSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ShutdownSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Signal => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Signal => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SignalKind => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SignalKind => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SimplexStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SimplexStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sink => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sink => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Sleep => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Sleep => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SocketAddr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SocketAddr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SplitSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SplitSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_StdCommand => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_StdCommand => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stderr => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stderr => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stdin => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stdin => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Stdout => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Stdout => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_StopwordType => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_StopwordType => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TakeSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TakeSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpListener => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpListener => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpSocket => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpSocket => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TcpStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TcpStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TryCurrentError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TryCurrentError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TryRecvError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TryRecvError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendError => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendError => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendErrorSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendErrorSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_TrySendErrorT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_TrySendErrorT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UCred => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UCred => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UdpSocket => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UdpSocket => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixDatagram => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixDatagram => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixListener => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixListener => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixSocket => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixSocket => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UnixStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UnixStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ValueType => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ValueType => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_VecT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_VecT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WeakSenderT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WeakSenderT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteF64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteF64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteHalfSimplexStream => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteHalfSimplexStream => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI128LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI128LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI128MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI128MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI16LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI16LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI16MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI16MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteI8MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteI8MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU128LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU128LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU128MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU128MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU16LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU16LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU16MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU16MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU32LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU32LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU32MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU32MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU64LeMutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU64LeMutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU64MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU64MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_WriteU8MutSelf => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_WriteU8MutSelf => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_CInt => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_CInt => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_GidT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_GidT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PidT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PidT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_U8 => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_U8 => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UidT => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UidT => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t;



                  @protected AnyhowException dco_decode_AnyhowException(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AnyhowException(raw as String); }

@protected AHashMapStringFacet dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AHashMapStringFacetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected AcquireError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AcquireErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ArcIndex dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ArcIndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Barrier dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected BarrierWaitResult dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Child dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStderr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStderrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStdin dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStdinImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStdout dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStdoutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Command dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected DocumentItem dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return DocumentItemImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected DuplexStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return DuplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Empty dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EmptyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected EnterGuard dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EnterGuardImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Error dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExitStatus dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExitStatusImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetField dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetFilter dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFilterImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetValue dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetValueImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected File dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FileImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FileType dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FileTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FillBufSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FillBufSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FlushSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FlushSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FrequentwordType dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FrequentwordTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Handle dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return HandleImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Highlighter dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return HighlighterImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Id dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IdImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Index dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMapStringVecStringUsize dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMapStringVecStringUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMetaObject dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Instant dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InstantImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interest dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InterestImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interval dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IntervalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IoSlice dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IoSliceImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ipv4Addr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Ipv4AddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LinesSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LinesSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LocalEnterGuard dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LocalEnterGuardImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LocalSet dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LocalSetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxField dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxFieldJson dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Notified dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NotifiedImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Notify dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NotifyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OpenOptions dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OpenOptionsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ordering dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OrderingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedFd dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedFdImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedNotified dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedNotifiedImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedPermitT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedPermitTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedReadHalf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedSemaphorePermit dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedWriteHalf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PdfDocument dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PdfDocumentImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PermitIteratorT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PermitIteratorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PermitT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PermitTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Poll dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollInstant dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollInstantImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollOption dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollOptionImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollOptionT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollOptionTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollRestoreOnPending dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollRestoreOnPendingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResult dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultSocketAddr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultTcpStreamSocketAddr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultTcpStreamSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultUnixStreamSocketAddr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultUnixStreamSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultUsize dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollUsize dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected QueryFacet dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return QueryFacetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected QueryRewriting dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return QueryRewritingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ranges dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RangesImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RangeU64 dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RangeU64Impl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadHalfSimplexStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadHalfSimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI128LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI128MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI16LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI16MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI8MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU128LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU128MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU16LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU16MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU8MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ready dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Receiver dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReceiverT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RecvError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RecvErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RefT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RefTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Repeat dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RepeatImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RestoreOnPending dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Result dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultObject dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultSort dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultSortImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReuniteError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Runtime dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RuntimeMetrics dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SchemaField dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SchemaFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SeekFrom dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SeekFromImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SeekSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SeekSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Semaphore dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SemaphoreImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SemaphorePermit dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendErrorT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendTimeoutErrorT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendTimeoutErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sender dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SenderT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Shutdown dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ShutdownImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ShutdownSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ShutdownSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Signal dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SignalKind dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalKindImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SimplexStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sink dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SinkImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sleep dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SleepImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SocketAddr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SplitSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SplitSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected StdCommand dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdCommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stderr dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StderrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stdin dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdinImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stdout dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdoutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected StopwordType dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StopwordTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected T dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TakeSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TakeSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpListener dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpSocket dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TryCurrentError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TryRecvError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryRecvErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendError dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendErrorSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendErrorT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UCred dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UCredImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UdpSocket dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UdpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixDatagram dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixDatagramImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixListener dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixSocket dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Value dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ValueType dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ValueTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WeakSenderT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WeakSenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteHalfSimplexStream dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteHalfSimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI128LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI128MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI16LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI16MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI8MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU128LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU128MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU16LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU16MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU32LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU32MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU64LeMutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU64MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU8MutSelf dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected CInt dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CIntImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected GidT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return GidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PidT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UidT dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Child dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Command dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Context dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ContextImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetField dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Index dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMetaObject dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interval dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IntervalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IoSliceMut dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IoSliceMutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxField dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxFieldJson dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OpenOptions dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OpenOptionsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedReadHalf dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedSemaphorePermit dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadBuf dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadBufImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReceiverT dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultObject dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultSort dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultSortImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReuniteError dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SchemaField dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SchemaFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SenderT dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Signal dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected VecT dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return VecTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected U8 dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return U8Impl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ArcIndex dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ArcIndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Barrier dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected BarrierWaitResult dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Child dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Command dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Error dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetField dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Handle dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return HandleImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Index dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMetaObject dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interval dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IntervalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ipv6Addr dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Ipv6AddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LocalSet dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LocalSetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxField dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxFieldJson dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Notify dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NotifyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedReadHalf dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedSemaphorePermit dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedWriteHalf dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Path dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PathImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Receiver dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReceiverT dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RestoreOnPending dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultObject dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultSort dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultSortImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReuniteError dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Runtime dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RuntimeMetrics dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SchemaField dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SchemaFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Semaphore dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SemaphoreImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sender dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SenderT dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SignalKind dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalKindImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sleep dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SleepImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SocketAddr dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpListener dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpSocket dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpStream dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TryCurrentError dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UCred dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UCredImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UdpSocket dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UdpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixDatagram dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixDatagramImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixListener dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixStream dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Duration dco_decode_Chrono_Duration(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeDuration(dco_decode_i_64(raw).toInt()); }

@protected BigInt dco_decode_I128(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BigInt.parse(raw); }

@protected Map<String, MinMaxFieldJson> dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, SchemaField> dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, Value> dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected AHashMapStringFacet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AHashMapStringFacetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected AcquireError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AcquireErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ArcIndex dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ArcIndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Barrier dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected BarrierWaitResult dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Child dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStderr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStderrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStdin dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStdinImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ChildStdout dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChildStdoutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Command dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Context dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ContextImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected DocumentItem dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return DocumentItemImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected DuplexStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return DuplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Empty dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EmptyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected EnterGuard dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EnterGuardImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Error dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExitStatus dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExitStatusImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetField dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetFilter dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetFilterImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FacetValue dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FacetValueImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected File dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FileImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FileType dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FileTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FillBufSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FillBufSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FlushSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FlushSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected FrequentwordType dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FrequentwordTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Handle dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return HandleImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Highlighter dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return HighlighterImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Id dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IdImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Index dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMapStringVecStringUsize dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMapStringVecStringUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IndexMetaObject dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Instant dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InstantImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interest dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InterestImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Interval dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IntervalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IoSliceMut dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IoSliceMutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected IoSlice dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return IoSliceImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ipv4Addr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Ipv4AddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ipv6Addr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Ipv6AddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LinesSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LinesSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LocalEnterGuard dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LocalEnterGuardImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected LocalSet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return LocalSetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxField dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MinMaxFieldJson dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Notified dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NotifiedImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Notify dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NotifyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OpenOptions dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OpenOptionsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ordering dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OrderingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedFd dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedFdImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedNotified dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedNotifiedImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedPermitT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedPermitTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedReadHalf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedSemaphorePermit dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected OwnedWriteHalf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Path dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PathImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PdfDocument dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PdfDocumentImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PermitIteratorT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PermitIteratorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PermitT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PermitTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Poll dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollInstant dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollInstantImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollOption dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollOptionImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollOptionT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollOptionTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollRestoreOnPending dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollRestoreOnPendingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResult dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultSocketAddr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultTcpStreamSocketAddr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultTcpStreamSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultUnixStreamSocketAddr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultUnixStreamSocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollResultUsize dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollResultUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PollUsize dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PollUsizeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected QueryFacet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return QueryFacetImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected QueryRewriting dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return QueryRewritingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ranges dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RangesImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RangeU64 dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RangeU64Impl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadBuf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadBufImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadF64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadF64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadHalfSimplexStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadHalfSimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI128LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI128MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI16LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI16MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadI8MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadI8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU128LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU128MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU16LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU16MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReadU8MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadU8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Ready dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReadyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Receiver dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReceiverT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReceiverTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RecvError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RecvErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RefT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RefTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Repeat dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RepeatImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RestoreOnPending dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Result dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultObject dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultObjectImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ResultSort dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultSortImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ReuniteError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Runtime dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RuntimeMetrics dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SchemaField dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SchemaFieldImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SeekFrom dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SeekFromImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SeekSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SeekSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Semaphore dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SemaphoreImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SemaphorePermit dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SemaphorePermitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendErrorT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SendTimeoutErrorT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SendTimeoutErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sender dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SenderT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Shutdown dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ShutdownImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ShutdownSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ShutdownSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Signal dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SignalKind dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SignalKindImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SimplexStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sink dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SinkImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Sleep dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SleepImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SocketAddr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SocketAddrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected SplitSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SplitSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected StdCommand dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdCommandImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stderr dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StderrImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stdin dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdinImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Stdout dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StdoutImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected StopwordType dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StopwordTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected T dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TakeSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TakeSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpListener dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpSocket dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TcpStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TcpStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TryCurrentError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TryRecvError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryRecvErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendError dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendErrorSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected TrySendErrorT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TrySendErrorTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UCred dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UCredImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UdpSocket dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UdpSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixDatagram dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixDatagramImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixListener dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixListenerImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixSocket dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixSocketImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UnixStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UnixStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Value dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ValueType dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ValueTypeImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected VecT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return VecTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WeakSenderT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WeakSenderTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteF64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteF64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteHalfSimplexStream dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteHalfSimplexStreamImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI128LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI128MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI16LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI16MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteI8MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteI8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU128LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU128LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU128MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU128MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU16LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU16LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU16MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU16MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU32LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU32LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU32MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU32MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU64LeMutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU64LeMutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU64MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU64MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected WriteU8MutSelf dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WriteU8MutSelfImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected CInt dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CIntImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected GidT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return GidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected PidT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected U8 dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return U8Impl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected UidT dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return UidTImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Set<String> dco_decode_Set_String_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Set.from(dco_decode_list_String(raw)); }

@protected String dco_decode_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as String; }

@protected AsyncBufReadExt dco_decode_TraitDef_AsyncBufReadExt(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected AsyncReadExt dco_decode_TraitDef_AsyncReadExt(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected AsyncSeekExt dco_decode_TraitDef_AsyncSeekExt(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected AsyncWriteExt dco_decode_TraitDef_AsyncWriteExt(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected Close dco_decode_TraitDef_Close(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected Commit dco_decode_TraitDef_Commit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected DeleteDocument dco_decode_TraitDef_DeleteDocument(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected DeleteDocuments dco_decode_TraitDef_DeleteDocuments(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected DeleteDocumentsByQuery dco_decode_TraitDef_DeleteDocumentsByQuery(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexDocument dco_decode_TraitDef_IndexDocument(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexDocument2 dco_decode_TraitDef_IndexDocument2(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexDocumentShard dco_decode_TraitDef_IndexDocumentShard(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexDocuments dco_decode_TraitDef_IndexDocuments(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexPdf dco_decode_TraitDef_IndexPdf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexPdfBytes dco_decode_TraitDef_IndexPdfBytes(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IndexPdfFile dco_decode_TraitDef_IndexPdfFile(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IngestCsv dco_decode_TraitDef_IngestCsv(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IngestJson dco_decode_TraitDef_IngestJson(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected IngestPdf dco_decode_TraitDef_IngestPdf(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected InternalStream dco_decode_TraitDef_InternalStream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected Search dco_decode_TraitDef_Search(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected SearchShard dco_decode_TraitDef_SearchShard(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected UpdateDocument dco_decode_TraitDef_UpdateDocument(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected UpdateDocuments dco_decode_TraitDef_UpdateDocuments(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected BigInt dco_decode_U128(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return BigInt.parse(raw); }

@protected AccessType dco_decode_access_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AccessType.values[raw as int]; }

@protected bool dco_decode_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected AHashMapStringFacet dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(raw); }

@protected ChildStderr dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(raw); }

@protected ChildStdin dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(raw); }

@protected ChildStdout dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(raw); }

@protected Error dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(raw); }

@protected ExitStatus dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(raw); }

@protected Highlighter dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(raw); }

@protected Interest dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(raw); }

@protected OwnedSemaphorePermit dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(raw); }

@protected PidT dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(raw); }

@protected Path dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(raw); }

@protected Duration dco_decode_box_autoadd_Chrono_Duration(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_Chrono_Duration(raw); }

@protected QueryCompletion dco_decode_box_autoadd_query_completion(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_query_completion(raw); }

@protected (BigInt,Map<String, Value>) dco_decode_box_autoadd_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as (BigInt,Map<String, Value>); }

@protected SearchFn dco_decode_box_autoadd_search_fn(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_search_fn(raw); }

@protected SpellingCorrection dco_decode_box_autoadd_spelling_correction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_spelling_correction(raw); }

@protected int dco_decode_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected void dco_decode_box_autoadd_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as void; }

@protected BigInt dco_decode_box_autoadd_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_usize(raw); }

@protected CompressionType dco_decode_compression_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CompressionType.values[raw as int]; }

@protected DistanceField dco_decode_distance_field(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return DistanceField(field: dco_decode_String(arr[0]),
distance: dco_decode_String(arr[1]),
base: dco_decode_list_prim_f_64_strict(arr[2]),
unit: dco_decode_distance_unit(arr[3]),); }

@protected DistanceUnit dco_decode_distance_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return DistanceUnit.values[raw as int]; }

@protected double dco_decode_f_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected double dco_decode_f_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected FieldType dco_decode_field_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return FieldType.values[raw as int]; }

@protected Highlight dco_decode_highlight(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
                return Highlight(field: dco_decode_String(arr[0]),
name: dco_decode_String(arr[1]),
fragmentNumber: dco_decode_usize(arr[2]),
fragmentSize: dco_decode_usize(arr[3]),
highlightMarkup: dco_decode_bool(arr[4]),
preTags: dco_decode_String(arr[5]),
postTags: dco_decode_String(arr[6]),); }

@protected int dco_decode_i_16(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected int dco_decode_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected PlatformInt64 dco_decode_i_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeI64(raw); }

@protected int dco_decode_i_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected List<FacetFilter> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter).toList(); }

@protected List<IoSlice> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic).toList(); }

@protected List<QueryFacet> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet).toList(); }

@protected List<Result> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult).toList(); }

@protected List<ResultSort> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort).toList(); }

@protected List<SchemaField> dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField).toList(); }

@protected List<Map<String, Value>> dco_decode_list_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None).toList(); }

@protected List<String> dco_decode_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_String).toList(); }

@protected List<DistanceField> dco_decode_list_distance_field(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_distance_field).toList(); }

@protected List<Highlight> dco_decode_list_highlight(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_highlight).toList(); }

@protected List<double> dco_decode_list_prim_f_64_loose(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as List<double>; }

@protected Float64List dco_decode_list_prim_f_64_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Float64List; }

@protected Uint64List dco_decode_list_prim_u_64_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeUint64List(raw); }

@protected List<int> dco_decode_list_prim_u_8_loose(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as List<int>; }

@protected Uint8List dco_decode_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint8List; }

@protected Uint64List dco_decode_list_prim_usize_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint64List; }

@protected List<(String,MinMaxFieldJson)> dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json).toList(); }

@protected List<(String,SchemaField)> dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field).toList(); }

@protected List<(String,Value)> dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value).toList(); }

@protected List<(BigInt,Map<String, Value>)> dco_decode_list_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none).toList(); }

@protected List<Synonym> dco_decode_list_synonym(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_synonym).toList(); }

@protected MissedTickBehavior dco_decode_missed_tick_behavior(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MissedTickBehavior.values[raw as int]; }

@protected NgramType dco_decode_ngram_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NgramType.values[raw as int]; }

@protected AHashMapStringFacet? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(raw); }

@protected ChildStderr? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(raw); }

@protected ChildStdin? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(raw); }

@protected ChildStdout? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(raw); }

@protected Error? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(raw); }

@protected ExitStatus? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(raw); }

@protected Highlighter? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(raw); }

@protected Interest? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(raw); }

@protected OwnedSemaphorePermit? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(raw); }

@protected PidT? dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(raw); }

@protected Path? dco_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(raw); }

@protected Duration? dco_decode_opt_box_autoadd_Chrono_Duration(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_Chrono_Duration(raw); }

@protected QueryCompletion? dco_decode_opt_box_autoadd_query_completion(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_query_completion(raw); }

@protected SpellingCorrection? dco_decode_opt_box_autoadd_spelling_correction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_spelling_correction(raw); }

@protected int? dco_decode_opt_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_32(raw); }

@protected void? dco_decode_opt_box_autoadd_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_unit(raw); }

@protected BigInt? dco_decode_opt_box_autoadd_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_usize(raw); }

@protected Uint64List? dco_decode_opt_list_prim_usize_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_prim_usize_strict(raw); }

@protected QueryCompletion dco_decode_query_completion(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
                return QueryCompletion(maxCompletionEntries: dco_decode_usize(arr[0]),); }

@protected QueryType dco_decode_query_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return QueryType.values[raw as int]; }

@protected RangeType dco_decode_range_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RangeType.values[raw as int]; }

@protected (DuplexStream,DuplexStream) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(arr[1]),); }

@protected (OwnedReadHalf,OwnedWriteHalf) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_read_half_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_write_half(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(arr[1]),); }

@protected (ReadHalfSimplexStream,WriteHalfSimplexStream) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_read_half_simplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_write_half_simplex_stream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(arr[1]),); }

@protected (Sender,Receiver) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_sender_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_receiver(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(arr[1]),); }

@protected (TcpStream,SocketAddr) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_tcp_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(arr[1]),); }

@protected (UnixDatagram,UnixDatagram) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(arr[1]),); }

@protected (UnixStream,SocketAddr) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(arr[1]),); }

@protected (UnixStream,UnixStream) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(arr[1]),); }

@protected (String,MinMaxFieldJson) dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(arr[1]),); }

@protected (String,SchemaField) dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(arr[1]),); }

@protected (String,Value) dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(arr[1]),); }

@protected (BigInt,Map<String, Value>) dco_decode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_u_64(arr[0]),dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(arr[1]),); }

@protected (BigInt,SocketAddr) dco_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_usize(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(arr[1]),); }

@protected ResultType dco_decode_result_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ResultType.values[raw as int]; }

@protected RuntimeFlavor dco_decode_runtime_flavor(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return RuntimeFlavor.values[raw as int]; }

@protected SearchFn dco_decode_search_fn(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
                return SearchFn(pathToIndex: dco_decode_String(arr[0]),); }

@protected SimilarityType dco_decode_similarity_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SimilarityType.values[raw as int]; }

@protected SortOrder dco_decode_sort_order(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return SortOrder.values[raw as int]; }

@protected SpellingCorrection dco_decode_spelling_correction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return SpellingCorrection(maxDictionaryEditDistance: dco_decode_usize(arr[0]),
termLengthThreshold: dco_decode_opt_list_prim_usize_strict(arr[1]),
countThreshold: dco_decode_usize(arr[2]),
maxDictionaryEntries: dco_decode_usize(arr[3]),); }

@protected StemmerType dco_decode_stemmer_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return StemmerType.values[raw as int]; }

@protected Synonym dco_decode_synonym(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return Synonym(terms: dco_decode_list_String(arr[0]),
multiway: dco_decode_bool(arr[1]),); }

@protected TokenizerType dco_decode_tokenizer_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TokenizerType.values[raw as int]; }

@protected TryAcquireError dco_decode_try_acquire_error(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TryAcquireError.values[raw as int]; }

@protected int dco_decode_u_16(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected int dco_decode_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected BigInt dco_decode_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected int dco_decode_u_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected void dco_decode_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return; }

@protected BigInt dco_decode_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return AnyhowException(inner); }

@protected AHashMapStringFacet sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AHashMapStringFacetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected AcquireError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AcquireErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ArcIndex sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ArcIndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Barrier sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected BarrierWaitResult sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Child sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStderr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStderrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStdin sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStdinImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStdout sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStdoutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Command sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected DocumentItem sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return DocumentItemImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected DuplexStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return DuplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Empty sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EmptyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected EnterGuard sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EnterGuardImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Error sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExitStatus sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExitStatusImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetField sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetFilter sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFilterImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetValue sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetValueImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected File sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FileImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FileType sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FileTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FillBufSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FillBufSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FlushSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FlushSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FrequentwordType sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FrequentwordTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Handle sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return HandleImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Highlighter sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return HighlighterImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Id sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IdImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Index sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMapStringVecStringUsize sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMapStringVecStringUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMetaObject sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Instant sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return InstantImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interest sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return InterestImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interval sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IntervalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IoSlice sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IoSliceImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ipv4Addr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Ipv4AddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LinesSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LinesSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LocalEnterGuard sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LocalEnterGuardImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LocalSet sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LocalSetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxField sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxFieldJson sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Notified sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return NotifiedImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Notify sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return NotifyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OpenOptions sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OpenOptionsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ordering sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OrderingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedFd sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedFdImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedNotified sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedNotifiedImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedPermitT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedPermitTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedReadHalf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedSemaphorePermit sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedWriteHalf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PdfDocument sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PdfDocumentImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PermitIteratorT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PermitIteratorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PermitT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PermitTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Poll sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollInstant sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollInstantImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollOption sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollOptionImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollOptionT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollOptionTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollRestoreOnPending sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollRestoreOnPendingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResult sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultSocketAddr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultTcpStreamSocketAddr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultTcpStreamSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultUnixStreamSocketAddr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultUnixStreamSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultUsize sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollUsize sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected QueryFacet sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return QueryFacetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected QueryRewriting sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return QueryRewritingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ranges sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RangesImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RangeU64 sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RangeU64Impl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadHalfSimplexStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadHalfSimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI128LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI128MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI16LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI16MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI8MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU128LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU128MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU16LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU16MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU8MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ready sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Receiver sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReceiverT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RecvError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RecvErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RefT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RefTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Repeat sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RepeatImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RestoreOnPending sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Result sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultObject sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultSort sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultSortImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReuniteError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Runtime sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RuntimeMetrics sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SchemaField sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SchemaFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SeekFrom sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SeekFromImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SeekSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SeekSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Semaphore sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SemaphoreImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SemaphorePermit sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendErrorT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendTimeoutErrorT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendTimeoutErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sender sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SenderT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Shutdown sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ShutdownImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ShutdownSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ShutdownSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Signal sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SignalKind sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalKindImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SimplexStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sink sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SinkImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sleep sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SleepImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SocketAddr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SplitSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SplitSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected StdCommand sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdCommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stderr sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StderrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stdin sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdinImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stdout sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdoutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected StopwordType sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StopwordTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected T sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TakeSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TakeSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpListener sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpSocket sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TryCurrentError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TryRecvError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TryRecvErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendError sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendErrorSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendErrorT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UCred sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UCredImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UdpSocket sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UdpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixDatagram sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixDatagramImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixListener sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixSocket sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Value sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ValueImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ValueType sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ValueTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WeakSenderT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WeakSenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteHalfSimplexStream sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteHalfSimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI128LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI128MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI16LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI16MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI8MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU128LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU128MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU16LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU16MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU32LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU32MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU64LeMutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU64MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU8MutSelf sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected CInt sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CIntImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected GidT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return GidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PidT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UidT sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Child sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Command sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Context sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ContextImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetField sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Index sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMetaObject sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interval sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IntervalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IoSliceMut sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IoSliceMutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxField sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxFieldJson sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OpenOptions sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OpenOptionsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedReadHalf sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedSemaphorePermit sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadBuf sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadBufImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReceiverT sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultObject sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultSort sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultSortImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReuniteError sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SchemaField sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SchemaFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SenderT sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Signal sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected VecT sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return VecTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected U8 sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return U8Impl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ArcIndex sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ArcIndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Barrier sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected BarrierWaitResult sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Child sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Command sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Error sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetField sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Handle sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return HandleImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Index sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMetaObject sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interval sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IntervalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ipv6Addr sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Ipv6AddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LocalSet sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LocalSetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxField sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxFieldJson sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Notify sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return NotifyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedReadHalf sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedSemaphorePermit sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedWriteHalf sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Path sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PathImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Receiver sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReceiverT sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RestoreOnPending sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultObject sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultSort sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultSortImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReuniteError sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Runtime sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RuntimeMetrics sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SchemaField sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SchemaFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Semaphore sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SemaphoreImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sender sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SenderT sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SignalKind sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalKindImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sleep sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SleepImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SocketAddr sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpListener sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpSocket sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpStream sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TryCurrentError sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UCred sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UCredImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UdpSocket sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UdpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixDatagram sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixDatagramImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixListener sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixStream sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Duration sse_decode_Chrono_Duration(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_64(deserializer);
        return Duration(microseconds: inner.toInt()); }

@protected BigInt sse_decode_I128(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return BigInt.parse(inner); }

@protected Map<String, MinMaxFieldJson> sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, SchemaField> sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, Value> sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected AHashMapStringFacet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AHashMapStringFacetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected AcquireError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AcquireErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ArcIndex sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ArcIndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Barrier sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected BarrierWaitResult sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return BarrierWaitResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Child sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStderr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStderrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStdin sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStdinImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ChildStdout sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ChildStdoutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Command sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Context sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ContextImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected DocumentItem sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return DocumentItemImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected DuplexStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return DuplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Empty sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EmptyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected EnterGuard sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EnterGuardImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Error sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExitStatus sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExitStatusImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetField sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetFilter sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetFilterImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FacetValue sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FacetValueImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected File sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FileImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FileType sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FileTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FillBufSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FillBufSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FlushSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FlushSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected FrequentwordType sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return FrequentwordTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Handle sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return HandleImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Highlighter sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return HighlighterImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Id sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IdImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Index sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMapStringVecStringUsize sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMapStringVecStringUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IndexMetaObject sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IndexMetaObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Instant sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return InstantImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interest sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return InterestImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Interval sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IntervalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IoSliceMut sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IoSliceMutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected IoSlice sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return IoSliceImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ipv4Addr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Ipv4AddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ipv6Addr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Ipv6AddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LinesSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LinesSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LocalEnterGuard sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LocalEnterGuardImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected LocalSet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return LocalSetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxField sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MinMaxFieldJson sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MinMaxFieldJsonImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Notified sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return NotifiedImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Notify sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return NotifyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OpenOptions sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OpenOptionsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ordering sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OrderingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedFd sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedFdImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedNotified sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedNotifiedImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedPermitT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedPermitTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedReadHalf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedReadHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedSemaphorePermit sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedSemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected OwnedWriteHalf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return OwnedWriteHalfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Path sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PathImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PdfDocument sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PdfDocumentImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PermitIteratorT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PermitIteratorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PermitT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PermitTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Poll sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollInstant sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollInstantImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollOption sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollOptionImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollOptionT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollOptionTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollRestoreOnPending sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollRestoreOnPendingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResult sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultSocketAddr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultTcpStreamSocketAddr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultTcpStreamSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultUnixStreamSocketAddr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultUnixStreamSocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollResultUsize sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollResultUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PollUsize sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PollUsizeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected QueryFacet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return QueryFacetImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected QueryRewriting sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return QueryRewritingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ranges sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RangesImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RangeU64 sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RangeU64Impl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadBuf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadBufImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadF64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadF64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadHalfSimplexStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadHalfSimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI128LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI128MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI16LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI16MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadI8MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadI8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU128LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU128MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU16LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU16MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReadU8MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadU8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Ready sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReadyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Receiver sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReceiverT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReceiverTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RecvError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RecvErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RefT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RefTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Repeat sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RepeatImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RestoreOnPending sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RestoreOnPendingImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Result sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultObject sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultObjectImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ResultSort sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ResultSortImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ReuniteError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ReuniteErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Runtime sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RuntimeMetrics sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return RuntimeMetricsImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SchemaField sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SchemaFieldImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SeekFrom sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SeekFromImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SeekSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SeekSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Semaphore sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SemaphoreImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SemaphorePermit sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SemaphorePermitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendErrorT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SendTimeoutErrorT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SendTimeoutErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sender sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SenderT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Shutdown sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ShutdownImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ShutdownSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ShutdownSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Signal sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SignalKind sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SignalKindImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SimplexStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sink sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SinkImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Sleep sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SleepImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SocketAddr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SocketAddrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected SplitSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return SplitSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected StdCommand sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdCommandImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stderr sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StderrImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stdin sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdinImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Stdout sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StdoutImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected StopwordType sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return StopwordTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected T sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TakeSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TakeSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpListener sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpSocket sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TcpStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TcpStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TryCurrentError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TryCurrentErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TryRecvError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TryRecvErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendError sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendErrorSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected TrySendErrorT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return TrySendErrorTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UCred sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UCredImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UdpSocket sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UdpSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixDatagram sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixDatagramImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixListener sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixListenerImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixSocket sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixSocketImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UnixStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UnixStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Value sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ValueImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ValueType sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ValueTypeImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected VecT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return VecTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WeakSenderT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WeakSenderTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteF64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteF64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteHalfSimplexStream sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteHalfSimplexStreamImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI128LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI128MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI16LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI16MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteI8MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteI8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU128LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU128LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU128MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU128MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU16LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU16LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU16MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU16MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU32LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU32LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU32MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU32MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU64LeMutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU64LeMutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU64MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU64MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected WriteU8MutSelf sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WriteU8MutSelfImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected CInt sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CIntImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected GidT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return GidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected PidT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return PidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected U8 sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return U8Impl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected UidT sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return UidTImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Set<String> sse_decode_Set_String_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_String(deserializer);
        return Set.from(inner); }

@protected String sse_decode_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return utf8.decoder.convert(inner); }

@protected BigInt sse_decode_U128(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return BigInt.parse(inner); }

@protected AccessType sse_decode_access_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return AccessType.values[inner]; }

@protected bool sse_decode_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8() != 0; }

@protected AHashMapStringFacet sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(deserializer)); }

@protected ChildStderr sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(deserializer)); }

@protected ChildStdin sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(deserializer)); }

@protected ChildStdout sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(deserializer)); }

@protected Error sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(deserializer)); }

@protected ExitStatus sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(deserializer)); }

@protected Highlighter sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(deserializer)); }

@protected Interest sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(deserializer)); }

@protected OwnedSemaphorePermit sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(deserializer)); }

@protected PidT sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(deserializer)); }

@protected Path sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(deserializer)); }

@protected Duration sse_decode_box_autoadd_Chrono_Duration(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_Chrono_Duration(deserializer)); }

@protected QueryCompletion sse_decode_box_autoadd_query_completion(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_query_completion(deserializer)); }

@protected (BigInt,Map<String, Value>) sse_decode_box_autoadd_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(deserializer)); }

@protected SearchFn sse_decode_box_autoadd_search_fn(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_search_fn(deserializer)); }

@protected SpellingCorrection sse_decode_box_autoadd_spelling_correction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_spelling_correction(deserializer)); }

@protected int sse_decode_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_32(deserializer)); }

@protected void sse_decode_box_autoadd_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_unit(deserializer)); }

@protected BigInt sse_decode_box_autoadd_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_usize(deserializer)); }

@protected CompressionType sse_decode_compression_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return CompressionType.values[inner]; }

@protected DistanceField sse_decode_distance_field(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field = sse_decode_String(deserializer);
var var_distance = sse_decode_String(deserializer);
var var_base = sse_decode_list_prim_f_64_strict(deserializer);
var var_unit = sse_decode_distance_unit(deserializer);
return DistanceField(field: var_field, distance: var_distance, base: var_base, unit: var_unit); }

@protected DistanceUnit sse_decode_distance_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return DistanceUnit.values[inner]; }

@protected double sse_decode_f_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getFloat32(); }

@protected double sse_decode_f_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getFloat64(); }

@protected FieldType sse_decode_field_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return FieldType.values[inner]; }

@protected Highlight sse_decode_highlight(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field = sse_decode_String(deserializer);
var var_name = sse_decode_String(deserializer);
var var_fragmentNumber = sse_decode_usize(deserializer);
var var_fragmentSize = sse_decode_usize(deserializer);
var var_highlightMarkup = sse_decode_bool(deserializer);
var var_preTags = sse_decode_String(deserializer);
var var_postTags = sse_decode_String(deserializer);
return Highlight(field: var_field, name: var_name, fragmentNumber: var_fragmentNumber, fragmentSize: var_fragmentSize, highlightMarkup: var_highlightMarkup, preTags: var_preTags, postTags: var_postTags); }

@protected int sse_decode_i_16(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt16(); }

@protected int sse_decode_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt32(); }

@protected PlatformInt64 sse_decode_i_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getPlatformInt64(); }

@protected int sse_decode_i_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt8(); }

@protected List<FacetFilter> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <FacetFilter>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(deserializer)); }
        return ans_;
         }

@protected List<IoSlice> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <IoSlice>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(deserializer)); }
        return ans_;
         }

@protected List<QueryFacet> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <QueryFacet>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(deserializer)); }
        return ans_;
         }

@protected List<Result> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Result>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(deserializer)); }
        return ans_;
         }

@protected List<ResultSort> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <ResultSort>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(deserializer)); }
        return ans_;
         }

@protected List<SchemaField> sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <SchemaField>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(deserializer)); }
        return ans_;
         }

@protected List<Map<String, Value>> sse_decode_list_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Map<String, Value>>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(deserializer)); }
        return ans_;
         }

@protected List<String> sse_decode_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <String>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_String(deserializer)); }
        return ans_;
         }

@protected List<DistanceField> sse_decode_list_distance_field(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <DistanceField>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_distance_field(deserializer)); }
        return ans_;
         }

@protected List<Highlight> sse_decode_list_highlight(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Highlight>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_highlight(deserializer)); }
        return ans_;
         }

@protected List<double> sse_decode_list_prim_f_64_loose(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getFloat64List(len_); }

@protected Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getFloat64List(len_); }

@protected Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint64List(len_); }

@protected List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint64List(len_); }

@protected List<(String,MinMaxFieldJson)> sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,MinMaxFieldJson)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(deserializer)); }
        return ans_;
         }

@protected List<(String,SchemaField)> sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,SchemaField)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(deserializer)); }
        return ans_;
         }

@protected List<(String,Value)> sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,Value)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(deserializer)); }
        return ans_;
         }

@protected List<(BigInt,Map<String, Value>)> sse_decode_list_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(BigInt,Map<String, Value>)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(deserializer)); }
        return ans_;
         }

@protected List<Synonym> sse_decode_list_synonym(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Synonym>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_synonym(deserializer)); }
        return ans_;
         }

@protected MissedTickBehavior sse_decode_missed_tick_behavior(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return MissedTickBehavior.values[inner]; }

@protected NgramType sse_decode_ngram_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return NgramType.values[inner]; }

@protected AHashMapStringFacet? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(deserializer));
            } else {
                return null;
            }
             }

@protected ChildStderr? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(deserializer));
            } else {
                return null;
            }
             }

@protected ChildStdin? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(deserializer));
            } else {
                return null;
            }
             }

@protected ChildStdout? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(deserializer));
            } else {
                return null;
            }
             }

@protected Error? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(deserializer));
            } else {
                return null;
            }
             }

@protected ExitStatus? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(deserializer));
            } else {
                return null;
            }
             }

@protected Highlighter? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(deserializer));
            } else {
                return null;
            }
             }

@protected Interest? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(deserializer));
            } else {
                return null;
            }
             }

@protected OwnedSemaphorePermit? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(deserializer));
            } else {
                return null;
            }
             }

@protected PidT? sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(deserializer));
            } else {
                return null;
            }
             }

@protected Path? sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(deserializer));
            } else {
                return null;
            }
             }

@protected Duration? sse_decode_opt_box_autoadd_Chrono_Duration(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_Chrono_Duration(deserializer));
            } else {
                return null;
            }
             }

@protected QueryCompletion? sse_decode_opt_box_autoadd_query_completion(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_query_completion(deserializer));
            } else {
                return null;
            }
             }

@protected SpellingCorrection? sse_decode_opt_box_autoadd_spelling_correction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_spelling_correction(deserializer));
            } else {
                return null;
            }
             }

@protected int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_32(deserializer));
            } else {
                return null;
            }
             }

@protected void? sse_decode_opt_box_autoadd_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_unit(deserializer));
            } else {
                return null;
            }
             }

@protected BigInt? sse_decode_opt_box_autoadd_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_usize(deserializer));
            } else {
                return null;
            }
             }

@protected Uint64List? sse_decode_opt_list_prim_usize_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_prim_usize_strict(deserializer));
            } else {
                return null;
            }
             }

@protected QueryCompletion sse_decode_query_completion(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_maxCompletionEntries = sse_decode_usize(deserializer);
return QueryCompletion(maxCompletionEntries: var_maxCompletionEntries); }

@protected QueryType sse_decode_query_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return QueryType.values[inner]; }

@protected RangeType sse_decode_range_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return RangeType.values[inner]; }

@protected (DuplexStream,DuplexStream) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(deserializer);
return (var_field0, var_field1); }

@protected (OwnedReadHalf,OwnedWriteHalf) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_read_half_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_write_half(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(deserializer);
return (var_field0, var_field1); }

@protected (ReadHalfSimplexStream,WriteHalfSimplexStream) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_read_half_simplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_write_half_simplex_stream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(deserializer);
return (var_field0, var_field1); }

@protected (Sender,Receiver) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_sender_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_receiver(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(deserializer);
return (var_field0, var_field1); }

@protected (TcpStream,SocketAddr) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_tcp_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(deserializer);
return (var_field0, var_field1); }

@protected (UnixDatagram,UnixDatagram) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(deserializer);
return (var_field0, var_field1); }

@protected (UnixStream,SocketAddr) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(deserializer);
return (var_field0, var_field1); }

@protected (UnixStream,UnixStream) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(deserializer);
return (var_field0, var_field1); }

@protected (String,MinMaxFieldJson) sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(deserializer);
return (var_field0, var_field1); }

@protected (String,SchemaField) sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(deserializer);
return (var_field0, var_field1); }

@protected (String,Value) sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(deserializer);
return (var_field0, var_field1); }

@protected (BigInt,Map<String, Value>) sse_decode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_u_64(deserializer);
var var_field1 = sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(deserializer);
return (var_field0, var_field1); }

@protected (BigInt,SocketAddr) sse_decode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_usize(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(deserializer);
return (var_field0, var_field1); }

@protected ResultType sse_decode_result_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return ResultType.values[inner]; }

@protected RuntimeFlavor sse_decode_runtime_flavor(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return RuntimeFlavor.values[inner]; }

@protected SearchFn sse_decode_search_fn(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_pathToIndex = sse_decode_String(deserializer);
return SearchFn(pathToIndex: var_pathToIndex); }

@protected SimilarityType sse_decode_similarity_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return SimilarityType.values[inner]; }

@protected SortOrder sse_decode_sort_order(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return SortOrder.values[inner]; }

@protected SpellingCorrection sse_decode_spelling_correction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_maxDictionaryEditDistance = sse_decode_usize(deserializer);
var var_termLengthThreshold = sse_decode_opt_list_prim_usize_strict(deserializer);
var var_countThreshold = sse_decode_usize(deserializer);
var var_maxDictionaryEntries = sse_decode_usize(deserializer);
return SpellingCorrection(maxDictionaryEditDistance: var_maxDictionaryEditDistance, termLengthThreshold: var_termLengthThreshold, countThreshold: var_countThreshold, maxDictionaryEntries: var_maxDictionaryEntries); }

@protected StemmerType sse_decode_stemmer_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return StemmerType.values[inner]; }

@protected Synonym sse_decode_synonym(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_terms = sse_decode_list_String(deserializer);
var var_multiway = sse_decode_bool(deserializer);
return Synonym(terms: var_terms, multiway: var_multiway); }

@protected TokenizerType sse_decode_tokenizer_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return TokenizerType.values[inner]; }

@protected TryAcquireError sse_decode_try_acquire_error(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return TryAcquireError.values[inner]; }

@protected int sse_decode_u_16(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint16(); }

@protected int sse_decode_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint32(); }

@protected BigInt sse_decode_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected int sse_decode_u_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8(); }

@protected void sse_decode_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected BigInt sse_decode_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.message, serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(AHashMapStringFacet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AHashMapStringFacetImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(AcquireError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AcquireErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(ArcIndex self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ArcIndexImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(Barrier self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(BarrierWaitResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierWaitResultImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(Child self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(ChildStderr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStderrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(ChildStdin self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStdinImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(ChildStdout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStdoutImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(Command self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CommandImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(DocumentItem self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as DocumentItemImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(DuplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as DuplexStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(Empty self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EmptyImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(EnterGuard self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EnterGuardImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(Error self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(ExitStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExitStatusImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(FacetField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFieldImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(FacetFilter self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFilterImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(FacetValue self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetValueImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(File self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FileImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(FileType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FileTypeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(FillBufSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FillBufSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(FlushSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FlushSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(FrequentwordType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FrequentwordTypeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(Handle self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as HandleImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(Highlighter self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as HighlighterImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(Id self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IdImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(Index self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(IndexMapStringVecStringUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMapStringVecStringUsizeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(IndexMetaObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMetaObjectImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(Instant self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as InstantImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(Interest self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as InterestImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(Interval self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IntervalImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(IoSlice self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IoSliceImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(Ipv4Addr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Ipv4AddrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(LinesSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LinesSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(LocalEnterGuard self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LocalEnterGuardImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(LocalSet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LocalSetImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(MinMaxField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(MinMaxFieldJson self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldJsonImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(Notified self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as NotifiedImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(Notify self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as NotifyImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(OpenOptions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OpenOptionsImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(Ordering self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OrderingImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(OwnedFd self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedFdImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(OwnedNotified self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedNotifiedImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(OwnedPermitT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedPermitTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(OwnedReadHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedReadHalfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedSemaphorePermitImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(OwnedWriteHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedWriteHalfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(PdfDocument self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PdfDocumentImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(PermitIteratorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PermitIteratorTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(PermitT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PermitTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(Poll self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(PollInstant self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollInstantImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(PollOption self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollOptionImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(PollOptionT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollOptionTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(PollRestoreOnPending self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollRestoreOnPendingImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(PollResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(PollResultSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultSocketAddrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(PollResultTcpStreamSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultTcpStreamSocketAddrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(PollResultUnixStreamSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultUnixStreamSocketAddrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(PollResultUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultUsizeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(PollUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollUsizeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(QueryFacet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as QueryFacetImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(QueryRewriting self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as QueryRewritingImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(Ranges self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RangesImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(RangeU64 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RangeU64Impl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(ReadF32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(ReadF32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(ReadF64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(ReadF64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(ReadHalfSimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadHalfSimplexStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(ReadI128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI128LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(ReadI128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI128MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(ReadI16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI16LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(ReadI16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI16MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(ReadI32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(ReadI32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(ReadI64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(ReadI64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(ReadI8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI8MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(ReadU128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU128LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(ReadU128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU128MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(ReadU16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU16LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(ReadU16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU16MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(ReadU32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(ReadU32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(ReadU64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(ReadU64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(ReadU8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU8MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(Ready self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadyImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(Receiver self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(ReceiverT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(RecvError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RecvErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(RefT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RefTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(Repeat self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RepeatImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(RestoreOnPending self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RestoreOnPendingImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(Result self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(ResultObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultObjectImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(ResultSort self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultSortImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(ReuniteError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReuniteErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(Runtime self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(RuntimeMetrics self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeMetricsImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SchemaField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SchemaFieldImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(SeekFrom self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SeekFromImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(SeekSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SeekSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(Semaphore self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SemaphoreImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(SemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SemaphorePermitImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(SendError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(SendErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendErrorTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(SendTimeoutErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendTimeoutErrorTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(Sender self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(Shutdown self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ShutdownImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(ShutdownSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ShutdownSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(Signal self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SignalKind self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalKindImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(SimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SimplexStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(Sink self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SinkImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(Sleep self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SleepImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SocketAddrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(SplitSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SplitSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(StdCommand self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdCommandImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(Stderr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StderrImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(Stdin self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdinImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(Stdout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdoutImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(StopwordType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StopwordTypeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(T self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(TakeSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TakeSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(TcpListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpListenerImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(TcpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpSocketImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(TcpStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(TryCurrentError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TryCurrentErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(TryRecvError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TryRecvErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(TrySendError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(TrySendErrorSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(TrySendErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(UCred self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UCredImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(UdpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UdpSocketImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(UnixDatagram self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixDatagramImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(UnixListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixListenerImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(UnixSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixSocketImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(UnixStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(Value self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ValueImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(ValueType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ValueTypeImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(WeakSenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WeakSenderTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(WriteF32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(WriteF32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(WriteF64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(WriteF64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(WriteHalfSimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteHalfSimplexStreamImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(WriteI128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI128LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(WriteI128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI128MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(WriteI16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI16LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(WriteI16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI16MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(WriteI32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(WriteI32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(WriteI64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(WriteI64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(WriteI8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI8MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(WriteU128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU128LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(WriteU128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU128MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(WriteU16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU16LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(WriteU16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU16MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(WriteU32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU32LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(WriteU32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU32MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(WriteU64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU64LeMutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(WriteU64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU64MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(WriteU8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU8MutSelfImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(CInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CIntImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(GidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as GidTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(PidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PidTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(UidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UidTImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(Child self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(Command self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CommandImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(Context self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ContextImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(FacetField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(Index self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(IndexMetaObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMetaObjectImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(Interval self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IntervalImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(IoSliceMut self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IoSliceMutImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(MinMaxField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(MinMaxFieldJson self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldJsonImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(OpenOptions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OpenOptionsImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(OwnedReadHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedReadHalfImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedSemaphorePermitImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(ReadBuf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadBufImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(ReceiverT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverTImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(ResultObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultObjectImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(ResultSort self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultSortImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(ReuniteError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReuniteErrorImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SchemaField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SchemaFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderTImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(Signal self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(VecT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as VecTImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(U8 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as U8Impl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(ArcIndex self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ArcIndexImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(Barrier self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(BarrierWaitResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierWaitResultImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(Child self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(Command self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CommandImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(Error self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ErrorImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(FacetField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(Handle self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as HandleImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(Index self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(IndexMetaObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMetaObjectImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(Interval self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IntervalImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(Ipv6Addr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Ipv6AddrImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(LocalSet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LocalSetImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(MinMaxField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(MinMaxFieldJson self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldJsonImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(Notify self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as NotifyImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(OwnedReadHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedReadHalfImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedSemaphorePermitImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(OwnedWriteHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedWriteHalfImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(Path self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PathImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(Receiver self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(ReceiverT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverTImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(RestoreOnPending self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RestoreOnPendingImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(ResultObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultObjectImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(ResultSort self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultSortImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(ReuniteError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReuniteErrorImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(Runtime self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(RuntimeMetrics self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeMetricsImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SchemaField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SchemaFieldImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(Semaphore self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SemaphoreImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(Sender self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderTImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SignalKind self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalKindImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(Sleep self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SleepImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SocketAddrImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(TcpListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpListenerImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(TcpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpSocketImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(TcpStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpStreamImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(TryCurrentError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TryCurrentErrorImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(UCred self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UCredImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(UdpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UdpSocketImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(UnixDatagram self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixDatagramImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(UnixListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixListenerImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(UnixStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixStreamImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Chrono_Duration(Duration self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_64(PlatformInt64Util.from(self.inMicroseconds), serializer); }

@protected void sse_encode_I128(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.toString(), serializer); }

@protected void sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson_None(Map<String, MinMaxFieldJson> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField_None(Map<String, SchemaField> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(Map<String, Value> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(AHashMapStringFacet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AHashMapStringFacetImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAcquireError(AcquireError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AcquireErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcRwLockIndex(ArcIndex self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ArcIndexImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrier(Barrier self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBarrierWaitResult(BarrierWaitResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as BarrierWaitResultImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChild(Child self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(ChildStderr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStderrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(ChildStdin self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStdinImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(ChildStdout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ChildStdoutImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommand(Command self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CommandImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContextstatic(Context self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ContextImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDocumentItem(DocumentItem self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as DocumentItemImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(DuplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as DuplexStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmpty(Empty self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EmptyImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnterGuardstatic(EnterGuard self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EnterGuardImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(Error self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(ExitStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExitStatusImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetField(FacetField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFieldImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(FacetFilter self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetFilterImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetValue(FacetValue self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FacetValueImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFile(File self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FileImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFileType(FileType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FileTypeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFillBufstaticSelf(FillBufSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FillBufSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlushstaticSelf(FlushSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FlushSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrequentwordType(FrequentwordType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as FrequentwordTypeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHandle(Handle self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as HandleImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(Highlighter self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as HighlighterImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerId(Id self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IdImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndex(Index self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMapStringVecStringusize(IndexMapStringVecStringUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMapStringVecStringUsizeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIndexMetaObject(IndexMetaObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IndexMetaObjectImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInstant(Instant self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as InstantImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(Interest self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as InterestImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterval(Interval self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IntervalImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSliceMut_(IoSliceMut self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IoSliceMutImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(IoSlice self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as IoSliceImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(Ipv4Addr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Ipv4AddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(Ipv6Addr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Ipv6AddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLinesSelf(LinesSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LinesSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalEnterGuard(LocalEnterGuard self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LocalEnterGuardImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLocalSet(LocalSet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as LocalSetImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxField(MinMaxField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(MinMaxFieldJson self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MinMaxFieldJsonImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotifiedstatic(Notified self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as NotifiedImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNotify(Notify self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as NotifyImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOpenOptions(OpenOptions self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OpenOptionsImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(Ordering self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OrderingImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedFd(OwnedFd self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedFdImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedNotified(OwnedNotified self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedNotifiedImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedPermitT(OwnedPermitT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedPermitTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(OwnedReadHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedReadHalfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedSemaphorePermitImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(OwnedWriteHalf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as OwnedWriteHalfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(Path self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PathImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPdfDocumentstatic(PdfDocument self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PdfDocumentImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitIteratorstaticT(PermitIteratorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PermitIteratorTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPermitstaticT(PermitT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PermitTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPoll(Poll self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollInstant(PollInstant self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollInstantImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOption(PollOption self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollOptionImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollOptionT(PollOptionT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollOptionTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollRestoreOnPending(PollRestoreOnPending self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollRestoreOnPendingImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResult(PollResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultSocketAddr(PollResultSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultSocketAddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultTcpStreamSocketAddr(PollResultTcpStreamSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultTcpStreamSocketAddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultUnixStreamSocketAddr(PollResultUnixStreamSocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultUnixStreamSocketAddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollResultusize(PollResultUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollResultUsizeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPollusize(PollUsize self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PollUsizeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(QueryFacet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as QueryFacetImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryRewriting(QueryRewriting self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as QueryRewritingImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRanges(Ranges self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RangesImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRangeu64(RangeU64 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RangeU64Impl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadBufstatic(ReadBuf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadBufImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32LemutSelf(ReadF32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF32mutSelf(ReadF32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64LemutSelf(ReadF64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadF64mutSelf(ReadF64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadF64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(ReadHalfSimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadHalfSimplexStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128LemutSelf(ReadI128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI128LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI128mutSelf(ReadI128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI128MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16LemutSelf(ReadI16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI16LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI16mutSelf(ReadI16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI16MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32LemutSelf(ReadI32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI32mutSelf(ReadI32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64LemutSelf(ReadI64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI64mutSelf(ReadI64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadI8mutSelf(ReadI8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadI8MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128LemutSelf(ReadU128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU128LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU128mutSelf(ReadU128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU128MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16LemutSelf(ReadU16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU16LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU16mutSelf(ReadU16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU16MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32LemutSelf(ReadU32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU32mutSelf(ReadU32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64LemutSelf(ReadU64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU64mutSelf(ReadU64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadU8mutSelf(ReadU8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadU8MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReady(Ready self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReadyImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(Receiver self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverT(ReceiverT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReceiverTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRecvError(RecvError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RecvErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRefstaticT(RefT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RefTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRepeat(Repeat self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RepeatImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRestoreOnPending(RestoreOnPending self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RestoreOnPendingImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(Result self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultObject(ResultObject self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultObjectImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(ResultSort self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ResultSortImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReuniteError(ReuniteError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ReuniteErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntime(Runtime self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRuntimeMetrics(RuntimeMetrics self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as RuntimeMetricsImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(SchemaField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SchemaFieldImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekFrom(SeekFrom self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SeekFromImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSeekstaticSelf(SeekSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SeekSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphore(Semaphore self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SemaphoreImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSemaphorePermitstatic(SemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SemaphorePermitImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendError(SendError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendErrorT(SendErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendErrorTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSendTimeoutErrorT(SendTimeoutErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SendTimeoutErrorTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(Sender self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderT(SenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SenderTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdown(Shutdown self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ShutdownImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerShutdownstaticSelf(ShutdownSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ShutdownSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignal(Signal self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSignalKind(SignalKind self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SignalKindImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSimplexStream(SimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SimplexStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSink(Sink self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SinkImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSleep(Sleep self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SleepImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(SocketAddr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SocketAddrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSplitSelf(SplitSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as SplitSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdCommand(StdCommand self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdCommandImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStderr(Stderr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StderrImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdin(Stdin self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdinImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStdout(Stdout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StdoutImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStopwordType(StopwordType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as StopwordTypeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(T self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTakeSelf(TakeSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TakeSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpListener(TcpListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpListenerImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpSocket(TcpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpSocketImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(TcpStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TcpStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryCurrentError(TryCurrentError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TryCurrentErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryRecvError(TryRecvError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TryRecvErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendError(TrySendError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorSelf(TrySendErrorSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTrySendErrorT(TrySendErrorT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as TrySendErrorTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUCred(UCred self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UCredImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUdpSocket(UdpSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UdpSocketImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(UnixDatagram self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixDatagramImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixListener(UnixListener self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixListenerImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixSocket(UnixSocket self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixSocketImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(UnixStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UnixStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(Value self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ValueImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValueType(ValueType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ValueTypeImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVecT(VecT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as VecTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWeakSenderT(WeakSenderT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WeakSenderTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32LemutSelf(WriteF32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF32mutSelf(WriteF32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64LemutSelf(WriteF64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteF64mutSelf(WriteF64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteF64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(WriteHalfSimplexStream self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteHalfSimplexStreamImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128LemutSelf(WriteI128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI128LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI128mutSelf(WriteI128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI128MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16LemutSelf(WriteI16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI16LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI16mutSelf(WriteI16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI16MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32LemutSelf(WriteI32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI32mutSelf(WriteI32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64LemutSelf(WriteI64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI64mutSelf(WriteI64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteI8mutSelf(WriteI8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteI8MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128LemutSelf(WriteU128LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU128LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU128mutSelf(WriteU128MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU128MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16LemutSelf(WriteU16LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU16LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU16mutSelf(WriteU16MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU16MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32LemutSelf(WriteU32LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU32LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU32mutSelf(WriteU32MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU32MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64LemutSelf(WriteU64LeMutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU64LeMutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU64mutSelf(WriteU64MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU64MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteU8mutSelf(WriteU8MutSelf self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WriteU8MutSelfImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerc_int(CInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CIntImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnergid_t(GidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as GidTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(PidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as PidTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(U8 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as U8Impl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneruid_t(UidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as UidTImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_Set_String_None(Set<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.toList(), serializer); }

@protected void sse_encode_String(String self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer); }

@protected void sse_encode_U128(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.toString(), serializer); }

@protected void sse_encode_access_type(AccessType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self ? 1 : 0); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(AHashMapStringFacet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(ChildStderr self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(ChildStdin self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(ChildStdout self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(Error self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(ExitStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(Highlighter self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(Interest self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(PidT self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(self, serializer); }

@protected void sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(Path self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(self, serializer); }

@protected void sse_encode_box_autoadd_Chrono_Duration(Duration self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Chrono_Duration(self, serializer); }

@protected void sse_encode_box_autoadd_query_completion(QueryCompletion self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_query_completion(self, serializer); }

@protected void sse_encode_box_autoadd_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none((BigInt,Map<String, Value>) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(self, serializer); }

@protected void sse_encode_box_autoadd_search_fn(SearchFn self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_search_fn(self, serializer); }

@protected void sse_encode_box_autoadd_spelling_correction(SpellingCorrection self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_spelling_correction(self, serializer); }

@protected void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self, serializer); }

@protected void sse_encode_box_autoadd_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_unit(self, serializer); }

@protected void sse_encode_box_autoadd_usize(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize(self, serializer); }

@protected void sse_encode_compression_type(CompressionType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_distance_field(DistanceField self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.field, serializer);
sse_encode_String(self.distance, serializer);
sse_encode_list_prim_f_64_strict(self.base, serializer);
sse_encode_distance_unit(self.unit, serializer);
 }

@protected void sse_encode_distance_unit(DistanceUnit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_f_32(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putFloat32(self); }

@protected void sse_encode_f_64(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putFloat64(self); }

@protected void sse_encode_field_type(FieldType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_highlight(Highlight self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.field, serializer);
sse_encode_String(self.name, serializer);
sse_encode_usize(self.fragmentNumber, serializer);
sse_encode_usize(self.fragmentSize, serializer);
sse_encode_bool(self.highlightMarkup, serializer);
sse_encode_String(self.preTags, serializer);
sse_encode_String(self.postTags, serializer);
 }

@protected void sse_encode_i_16(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt16(self); }

@protected void sse_encode_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt32(self); }

@protected void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putPlatformInt64(self); }

@protected void sse_encode_i_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt8(self); }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(List<FacetFilter> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFacetFilter(item, serializer); } }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(List<IoSlice> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIoSlicestatic(item, serializer); } }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(List<QueryFacet> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQueryFacet(item, serializer); } }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(List<Result> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResult(item, serializer); } }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(List<ResultSort> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultSort(item, serializer); } }

@protected void sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(List<SchemaField> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(item, serializer); } }

@protected void sse_encode_list_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(List<Map<String, Value>> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(item, serializer); } }

@protected void sse_encode_list_String(List<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_String(item, serializer); } }

@protected void sse_encode_list_distance_field(List<DistanceField> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_distance_field(item, serializer); } }

@protected void sse_encode_list_highlight(List<Highlight> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_highlight(item, serializer); } }

@protected void sse_encode_list_prim_f_64_loose(List<double> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putFloat64List(self is Float64List ? self : Float64List.fromList(self)); }

@protected void sse_encode_list_prim_f_64_strict(Float64List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putFloat64List(self); }

@protected void sse_encode_list_prim_u_64_strict(Uint64List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint64List(self); }

@protected void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self is Uint8List ? self : Uint8List.fromList(self)); }

@protected void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self); }

@protected void sse_encode_list_prim_usize_strict(Uint64List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint64List(self); }

@protected void sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(List<(String,MinMaxFieldJson)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json(item, serializer); } }

@protected void sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(List<(String,SchemaField)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field(item, serializer); } }

@protected void sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(List<(String,Value)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(item, serializer); } }

@protected void sse_encode_list_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(List<(BigInt,Map<String, Value>)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none(item, serializer); } }

@protected void sse_encode_list_synonym(List<Synonym> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_synonym(item, serializer); } }

@protected void sse_encode_missed_tick_behavior(MissedTickBehavior self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_ngram_type(NgramType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(AHashMapStringFacet? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAHashMapStringFacet(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(ChildStderr? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStderr(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(ChildStdin? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdin(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(ChildStdout? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChildStdout(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(Error? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerError(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(ExitStatus? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExitStatus(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(Highlighter? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHighlighter(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(Interest? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInterest(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(OwnedSemaphorePermit? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedSemaphorePermit(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(PidT? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerpid_t(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(Path? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPath(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_Chrono_Duration(Duration? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_Chrono_Duration(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_query_completion(QueryCompletion? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_query_completion(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_spelling_correction(SpellingCorrection? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_spelling_correction(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_32(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_unit(void? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_unit(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_usize(BigInt? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_usize(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_prim_usize_strict(Uint64List? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_prim_usize_strict(self, serializer);
                }
                 }

@protected void sse_encode_query_completion(QueryCompletion self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize(self.maxCompletionEntries, serializer);
 }

@protected void sse_encode_query_type(QueryType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_range_type(RangeType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_duplex_stream((DuplexStream,DuplexStream) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDuplexStream(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_read_half_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_owned_write_half((OwnedReadHalf,OwnedWriteHalf) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedReadHalf(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOwnedWriteHalf(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_read_half_simplex_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_write_half_simplex_stream((ReadHalfSimplexStream,WriteHalfSimplexStream) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReadHalfSimplexStream(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWriteHalfSimplexStream(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_sender_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_receiver((Sender,Receiver) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSender(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiver(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_tcp_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr((TcpStream,SocketAddr) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTcpStream(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_datagram((UnixDatagram,UnixDatagram) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixDatagram(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr((UnixStream,SocketAddr) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(self.$2, serializer);
 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_unix_stream((UnixStream,UnixStream) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnixStream(self.$2, serializer);
 }

@protected void sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_min_max_field_json((String,MinMaxFieldJson) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMinMaxFieldJson(self.$2, serializer);
 }

@protected void sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_schema_field((String,SchemaField) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSchemaField(self.$2, serializer);
 }

@protected void sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value((String,Value) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(self.$2, serializer);
 }

@protected void sse_encode_record_u_64_map_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value_none((BigInt,Map<String, Value>) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.$1, serializer);
sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(self.$2, serializer);
 }

@protected void sse_encode_record_usize_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_addr((BigInt,SocketAddr) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddr(self.$2, serializer);
 }

@protected void sse_encode_result_type(ResultType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_runtime_flavor(RuntimeFlavor self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_search_fn(SearchFn self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.pathToIndex, serializer);
 }

@protected void sse_encode_similarity_type(SimilarityType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_sort_order(SortOrder self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_spelling_correction(SpellingCorrection self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize(self.maxDictionaryEditDistance, serializer);
sse_encode_opt_list_prim_usize_strict(self.termLengthThreshold, serializer);
sse_encode_usize(self.countThreshold, serializer);
sse_encode_usize(self.maxDictionaryEntries, serializer);
 }

@protected void sse_encode_stemmer_type(StemmerType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_synonym(Synonym self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.terms, serializer);
sse_encode_bool(self.multiway, serializer);
 }

@protected void sse_encode_tokenizer_type(TokenizerType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_try_acquire_error(TryAcquireError self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_u_16(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint16(self); }

@protected void sse_encode_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint32(self); }

@protected void sse_encode_u_64(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }

@protected void sse_encode_u_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self); }

@protected void sse_encode_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected void sse_encode_usize(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }
                }
                

            @sealed class AHashMapStringFacetImpl extends RustOpaque implements AHashMapStringFacet {
                // Not to be used by end users
                AHashMapStringFacetImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                AHashMapStringFacetImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_AHashMapStringFacet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_AHashMapStringFacet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_AHashMapStringFacetPtr,
                );

                
            }
            @sealed class AcquireErrorImpl extends RustOpaque implements AcquireError {
                // Not to be used by end users
                AcquireErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                AcquireErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_AcquireError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_AcquireError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_AcquireErrorPtr,
                );

                
            }
            @sealed class ArcIndexImpl extends RustOpaque implements ArcIndex {
                // Not to be used by end users
                ArcIndexImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ArcIndexImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ArcIndex,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ArcIndex,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ArcIndexPtr,
                );

                
            }
            @sealed class BarrierImpl extends RustOpaque implements Barrier {
                // Not to be used by end users
                BarrierImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                BarrierImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Barrier,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Barrier,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_BarrierPtr,
                );

                /// Does not resolve until all tasks have rendezvoused here.
///
/// Barriers are re-usable after all tasks have rendezvoused once, and can
/// be used continuously.
///
/// A single (arbitrary) future will receive a [`BarrierWaitResult`] that returns `true` from
/// [`BarrierWaitResult::is_leader`] when returning from this function, and all other tasks
/// will receive a result that will return `false` from `is_leader`.
///
/// # Cancel safety
///
/// This method is not cancel safe.
 Future<BarrierWaitResult>  wait()=>RustLib.instance.api.tokioSyncBarrierWait(that: this, );


            }
            @sealed class BarrierWaitResultImpl extends RustOpaque implements BarrierWaitResult {
                // Not to be used by end users
                BarrierWaitResultImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                BarrierWaitResultImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_BarrierWaitResult,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_BarrierWaitResult,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_BarrierWaitResultPtr,
                );

                /// Returns `true` if this task from wait is the "leader task".
///
/// Only one task will have `true` returned from their result, all other tasks will have
/// `false` returned.
 Future<bool>  isLeader()=>RustLib.instance.api.tokioSyncBarrierWaitResultIsLeader(that: this, );


            }
            @sealed class CIntImpl extends RustOpaque implements CInt {
                // Not to be used by end users
                CIntImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                CIntImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_CInt,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_CInt,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_CIntPtr,
                );

                
            }
            @sealed class ChildImpl extends RustOpaque implements Child {
                // Not to be used by end users
                ChildImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ChildImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Child,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Child,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ChildPtr,
                );

                 ChildStderr? get stderr=>RustLib.instance.api.tokioProcessChildAutoAccessorGetStderr(that: this, );


 ChildStdin? get stdin=>RustLib.instance.api.tokioProcessChildAutoAccessorGetStdin(that: this, );


 ChildStdout? get stdout=>RustLib.instance.api.tokioProcessChildAutoAccessorGetStdout(that: this, );


  set stderr(ChildStderr? stderr)=>RustLib.instance.api.tokioProcessChildAutoAccessorSetStderr(that: this, stderr: stderr);


  set stdin(ChildStdin? stdin)=>RustLib.instance.api.tokioProcessChildAutoAccessorSetStdin(that: this, stdin: stdin);


  set stdout(ChildStdout? stdout)=>RustLib.instance.api.tokioProcessChildAutoAccessorSetStdout(that: this, stdout: stdout);


/// Returns the OS-assigned process identifier associated with this child
/// while it is still running.
///
/// Once the child has been polled to completion this will return `None`.
/// This is done to avoid confusion on platforms like Unix where the OS
/// identifier could be reused once the process has completed.
 Future<int?>  id()=>RustLib.instance.api.tokioProcessChildId(that: this, );


/// Forces the child to exit.
///
/// This is equivalent to sending a `SIGKILL` on unix platforms
/// followed by [`wait`](Child::wait).
///
/// Note: std version of [`Child::kill`](std::process::Child::kill) does not `wait`.
/// For an equivalent of `Child::kill` in the standard library,
/// use [`start_kill`](Child::start_kill).
///
/// # Examples
///
/// If the child has to be killed remotely, it is possible to do it using
/// a combination of the select! macro and a `oneshot` channel. In the following
/// example, the child will run until completion unless a message is sent on
/// the `oneshot` channel. If that happens, the child is killed immediately
/// using the `.kill()` method.
///
/// ```no_run
/// use tokio::process::Command;
/// use tokio::sync::oneshot::channel;
///
/// #[tokio::main]
/// async fn main() {
///     let (send, recv) = channel::<()>();
///     let mut child = Command::new("sleep").arg("1").spawn().unwrap();
///     tokio::spawn(async move { send.send(()) });
///     tokio::select! {
///         _ = child.wait() => {}
///         _ = recv => child.kill().await.expect("kill failed"),
///     }
/// }
/// ```
///
/// You can also interact with the child's standard I/O. For example, you can
/// read its stdout while waiting for it to exit.
///
/// ```no_run
/// # use std::process::Stdio;
/// #
/// # use tokio::io::AsyncReadExt;
/// # use tokio::process::Command;
/// # use tokio::sync::oneshot::channel;
///
/// #[tokio::main]
/// async fn main() {
///     let (_tx, rx) = channel::<()>();
///
///     let mut child = Command::new("echo")
///         .arg("Hello World!")
///         .stdout(Stdio::piped())
///         .spawn()
///         .unwrap();
///
///     let mut stdout = child.stdout.take().expect("stdout is not captured");
///
///     let read_stdout = tokio::spawn(async move {
///         let mut buff = Vec::new();
///         let _ = stdout.read_to_end(&mut buff).await;
///
///         buff
///     });
///
///     tokio::select! {
///         _ = child.wait() => {}
///         _ = rx => { child.kill().await.expect("kill failed") },
///     }
///
///     let buff = read_stdout.await.unwrap();
///
///     assert_eq!(buff, b"Hello World!\n");
/// }
/// ```
 Future<void>  kill()=>RustLib.instance.api.tokioProcessChildKill(that: this, );


/// Attempts to force the child to exit, but does not wait for the request
/// to take effect.
///
/// On Unix platforms, this is the equivalent to sending a `SIGKILL`. Note
/// that on Unix platforms it is possible for a zombie process to remain
/// after a kill is sent; to avoid this, the caller should ensure that either
/// `child.wait().await` or `child.try_wait()` is invoked successfully.
 Future<void>  startKill()=>RustLib.instance.api.tokioProcessChildStartKill(that: this, );


/// Attempts to collect the exit status of the child if it has already
/// exited.
///
/// This function will not block the calling thread and will only
/// check to see if the child process has exited or not. If the child has
/// exited then on Unix the process ID is reaped. This function is
/// guaranteed to repeatedly return a successful exit status so long as the
/// child has already exited.
///
/// If the child has exited, then `Ok(Some(status))` is returned. If the
/// exit status is not available at this time then `Ok(None)` is returned.
/// If an error occurs, then that error is returned.
///
/// Note that unlike `wait`, this function will not attempt to drop stdin,
/// nor will it wake the current task if the child exits.
 Future<ExitStatus?>  tryWait()=>RustLib.instance.api.tokioProcessChildTryWait(that: this, );


/// Waits for the child to exit completely, returning the status that it
/// exited with. This function will continue to have the same return value
/// after it has been called at least once.
///
/// The stdin handle to the child process, if any, will be closed
/// before waiting. This helps avoid deadlock: it ensures that the
/// child does not block waiting for input from the parent, while
/// the parent waits for the child to exit.
///
/// If the caller wishes to explicitly control when the child's stdin
/// handle is closed, they may `.take()` it before calling `.wait()`:
///
/// # Cancel safety
///
/// This function is cancel safe.
///
/// ```
/// # #[cfg(not(unix))]fn main(){}
/// # #[cfg(unix)]
/// use tokio::io::AsyncWriteExt;
/// # #[cfg(unix)]
/// use tokio::process::Command;
/// # #[cfg(unix)]
/// use std::process::Stdio;
///
/// # #[cfg(unix)]
/// #[tokio::main]
/// async fn main() {
/// #   if cfg!(miri) { return; } // No `pidfd_spawnp` in miri.
///     let mut child = Command::new("cat")
///         .stdin(Stdio::piped())
///         .spawn()
///         .unwrap();
///
///     let mut stdin = child.stdin.take().unwrap();
///     tokio::spawn(async move {
///         // do something with stdin here...
///         stdin.write_all(b"hello world\n").await.unwrap();
///
///         // then drop when finished
///         drop(stdin);
///     });
///
///     // wait for the process to complete
///     let _ = child.wait().await;
/// }
/// ```
 Future<ExitStatus>  wait()=>RustLib.instance.api.tokioProcessChildWait(that: this, );


            }
            @sealed class ChildStderrImpl extends RustOpaque implements ChildStderr {
                // Not to be used by end users
                ChildStderrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ChildStderrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ChildStderr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStderr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStderrPtr,
                );

                /// Convert into [`OwnedFd`].
 Future<OwnedFd>  intoOwnedFd()=>RustLib.instance.api.tokioProcessChildStderrIntoOwnedFd(that: this, );


            }
            @sealed class ChildStdinImpl extends RustOpaque implements ChildStdin {
                // Not to be used by end users
                ChildStdinImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ChildStdinImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ChildStdin,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStdin,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStdinPtr,
                );

                /// Convert into [`OwnedFd`].
 Future<OwnedFd>  intoOwnedFd()=>RustLib.instance.api.tokioProcessChildStdinIntoOwnedFd(that: this, );


            }
            @sealed class ChildStdoutImpl extends RustOpaque implements ChildStdout {
                // Not to be used by end users
                ChildStdoutImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ChildStdoutImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ChildStdout,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStdout,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ChildStdoutPtr,
                );

                /// Convert into [`OwnedFd`].
 Future<OwnedFd>  intoOwnedFd()=>RustLib.instance.api.tokioProcessChildStdoutIntoOwnedFd(that: this, );


            }
            @sealed class CommandImpl extends RustOpaque implements Command {
                // Not to be used by end users
                CommandImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                CommandImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Command,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Command,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_CommandPtr,
                );

                /// Cheaply convert to a `&std::process::Command` for places where the type from the standard
/// library is expected.
 Future<void>  asStd()=>RustLib.instance.api.tokioProcessCommandAsStd(that: this, );


/// Cheaply convert to a `&mut std::process::Command` for places where the type from the
/// standard library is expected.
 Future<void>  asStdMut()=>RustLib.instance.api.tokioProcessCommandAsStdMut(that: this, );


/// Clears the entire environment map for the child process.
///
/// # Examples
///
/// Basic usage:
///
/// ```no_run
/// # async fn test() { // allow using await
/// use tokio::process::Command;
///
/// let output = Command::new("ls")
///         .env_clear()
///         .output().await.unwrap();
/// # }
/// ```
 Future<void>  envClear()=>RustLib.instance.api.tokioProcessCommandEnvClear(that: this, );


/// Returns the boolean value that was previously set by [`Command::kill_on_drop`].
///
/// Note that if you have not previously called [`Command::kill_on_drop`], the
/// default value of `false` will be returned here.
///
/// # Examples
///
/// ```
/// use tokio::process::Command;
///
/// let mut cmd = Command::new("echo");
/// assert!(!cmd.get_kill_on_drop());
///
/// cmd.kill_on_drop(true);
/// assert!(cmd.get_kill_on_drop());
/// ```
 Future<bool>  getKillOnDrop()=>RustLib.instance.api.tokioProcessCommandGetKillOnDrop(that: this, );


/// Similar to `uid` but sets the group ID of the child process. This has
/// the same semantics as the `uid` field.
 Future<void>  gid({required int id })=>RustLib.instance.api.tokioProcessCommandGid(that: this, id: id);


/// Cheaply convert into a `std::process::Command`.
///
/// Note that Tokio specific options will be lost. Currently, this only applies to [`kill_on_drop`].
///
/// [`kill_on_drop`]: Command::kill_on_drop
 Future<StdCommand>  intoStd()=>RustLib.instance.api.tokioProcessCommandIntoStd(that: this, );


/// Controls whether a `kill` operation should be invoked on a spawned child
/// process when its corresponding `Child` handle is dropped.
///
/// By default, this value is assumed to be `false`, meaning the next spawned
/// process will not be killed on drop, similar to the behavior of the standard
/// library.
///
/// # Caveats
///
/// On Unix platforms processes must be "reaped" by their parent process after
/// they have exited in order to release all OS resources. A child process which
/// has exited, but has not yet been reaped by its parent is considered a "zombie"
/// process. Such processes continue to count against limits imposed by the system,
/// and having too many zombie processes present can prevent additional processes
/// from being spawned.
///
/// Although issuing a `kill` signal to the child process is a synchronous
/// operation, the resulting zombie process cannot be `.await`ed inside of the
/// destructor to avoid blocking other tasks. The tokio runtime will, on a
/// best-effort basis, attempt to reap and clean up such processes in the
/// background, but no additional guarantees are made with regard to
/// how quickly or how often this procedure will take place.
///
/// If stronger guarantees are required, it is recommended to avoid dropping
/// a [`Child`] handle where possible, and instead utilize `child.wait().await`
/// or `child.kill().await` where possible.
 Future<void>  killOnDrop({required bool killOnDrop })=>RustLib.instance.api.tokioProcessCommandKillOnDrop(that: this, killOnDrop: killOnDrop);


/// Sets the process group ID (PGID) of the child process. Equivalent to a
/// `setpgid` call in the child process, but may be more efficient.
///
/// Process groups determine which processes receive signals.
///
/// # Examples
///
/// Pressing Ctrl-C in a terminal will send `SIGINT` to all processes
/// in the current foreground process group. By spawning the `sleep`
/// subprocess in a new process group, it will not receive `SIGINT`
/// from the terminal.
///
/// The parent process could install a [signal handler] and manage the
/// process on its own terms.
///
/// A process group ID of 0 will use the process ID as the PGID.
///
/// ```no_run
/// # async fn test() { // allow using await
/// use tokio::process::Command;
///
/// let output = Command::new("sleep")
///     .arg("10")
///     .process_group(0)
///     .output()
///     .await
///     .unwrap();
/// # }
/// ```
///
/// [signal handler]: crate::signal
 Future<void>  processGroup({required int pgroup })=>RustLib.instance.api.tokioProcessCommandProcessGroup(that: this, pgroup: pgroup);


/// Executes the command as a child process, returning a handle to it.
///
/// By default, stdin, stdout and stderr are inherited from the parent.
///
/// This method will spawn the child process synchronously and return a
/// handle to a future-aware child process. The `Child` returned implements
/// `Future` itself to acquire the `ExitStatus` of the child, and otherwise
/// the `Child` has methods to acquire handles to the stdin, stdout, and
/// stderr streams.
///
/// All I/O this child does will be associated with the current default
/// event loop.
///
/// # Examples
///
/// Basic usage:
///
/// ```no_run
/// use tokio::process::Command;
///
/// async fn run_ls() -> std::process::ExitStatus {
///     Command::new("ls")
///         .spawn()
///         .expect("ls command failed to start")
///         .wait()
///         .await
///         .expect("ls command failed to run")
/// }
/// ```
///
/// # Caveats
///
/// ## Dropping/Cancellation
///
/// Similar to the behavior to the standard library, and unlike the futures
/// paradigm of dropping-implies-cancellation, a spawned process will, by
/// default, continue to execute even after the `Child` handle has been dropped.
///
/// The [`Command::kill_on_drop`] method can be used to modify this behavior
/// and kill the child process if the `Child` wrapper is dropped before it
/// has exited.
///
/// ## Unix Processes
///
/// On Unix platforms processes must be "reaped" by their parent process after
/// they have exited in order to release all OS resources. A child process which
/// has exited, but has not yet been reaped by its parent is considered a "zombie"
/// process. Such processes continue to count against limits imposed by the system,
/// and having too many zombie processes present can prevent additional processes
/// from being spawned.
///
/// The tokio runtime will, on a best-effort basis, attempt to reap and clean up
/// any process which it has spawned. No additional guarantees are made with regard to
/// how quickly or how often this procedure will take place.
///
/// It is recommended to avoid dropping a [`Child`] process handle before it has been
/// fully `await`ed if stricter cleanup guarantees are required.
///
/// [`Command`]: crate::process::Command
/// [`Command::kill_on_drop`]: crate::process::Command::kill_on_drop
/// [`Child`]: crate::process::Child
///
/// # Errors
///
/// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`
/// if the system process limit is reached (which includes other applications
/// running on the system).
 Future<Child>  spawn()=>RustLib.instance.api.tokioProcessCommandSpawn(that: this, );


/// Sets the child process's user ID. This translates to a
/// `setuid` call in the child process. Failure in the `setuid`
/// call will cause the spawn to fail.
 Future<void>  uid({required int id })=>RustLib.instance.api.tokioProcessCommandUid(that: this, id: id);


            }
            @sealed class ContextImpl extends RustOpaque implements Context {
                // Not to be used by end users
                ContextImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ContextImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Context,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Context,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ContextPtr,
                );

                
            }
            @sealed class DocumentItemImpl extends RustOpaque implements DocumentItem {
                // Not to be used by end users
                DocumentItemImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                DocumentItemImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_DocumentItem,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_DocumentItem,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_DocumentItemPtr,
                );

                
            }
            @sealed class DuplexStreamImpl extends RustOpaque implements DuplexStream {
                // Not to be used by end users
                DuplexStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                DuplexStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_DuplexStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_DuplexStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_DuplexStreamPtr,
                );

                
            }
            @sealed class EmptyImpl extends RustOpaque implements Empty {
                // Not to be used by end users
                EmptyImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                EmptyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Empty,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Empty,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_EmptyPtr,
                );

                
            }
            @sealed class EnterGuardImpl extends RustOpaque implements EnterGuard {
                // Not to be used by end users
                EnterGuardImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                EnterGuardImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_EnterGuard,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_EnterGuard,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_EnterGuardPtr,
                );

                
            }
            @sealed class ErrorImpl extends RustOpaque implements Error {
                // Not to be used by end users
                ErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Error,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Error,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ErrorPtr,
                );

                /// Returns `true` if the error was caused by the timer being at capacity.
 Future<bool>  isAtCapacity()=>RustLib.instance.api.tokioTimeErrorErrorIsAtCapacity(that: this, );


/// Returns `true` if the error was caused by the timer being misconfigured.
 Future<bool>  isInvalid()=>RustLib.instance.api.tokioTimeErrorErrorIsInvalid(that: this, );


/// Returns `true` if the error was caused by the timer being shutdown.
 Future<bool>  isShutdown()=>RustLib.instance.api.tokioTimeErrorErrorIsShutdown(that: this, );


            }
            @sealed class ExitStatusImpl extends RustOpaque implements ExitStatus {
                // Not to be used by end users
                ExitStatusImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ExitStatusImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ExitStatus,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ExitStatus,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ExitStatusPtr,
                );

                
            }
            @sealed class FacetFieldImpl extends RustOpaque implements FacetField {
                // Not to be used by end users
                FacetFieldImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FacetFieldImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FacetField,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FacetField,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FacetFieldPtr,
                );

                 ValueType get max=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorGetMax(that: this, );


 ValueType get min=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorGetMin(that: this, );


 String get name=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorGetName(that: this, );


 IndexMapStringVecStringUsize get values=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorGetValues(that: this, );


  set max(ValueType max)=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorSetMax(that: this, max: max);


  set min(ValueType min)=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorSetMin(that: this, min: min);


  set name(String name)=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorSetName(that: this, name: name);


  set values(IndexMapStringVecStringUsize values)=>RustLib.instance.api.seekstormIndexFacetFieldAutoAccessorSetValues(that: this, values: values);


            }
            @sealed class FacetFilterImpl extends RustOpaque implements FacetFilter {
                // Not to be used by end users
                FacetFilterImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FacetFilterImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FacetFilter,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FacetFilter,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FacetFilterPtr,
                );

                
            }
            @sealed class FacetValueImpl extends RustOpaque implements FacetValue {
                // Not to be used by end users
                FacetValueImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FacetValueImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FacetValue,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FacetValue,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FacetValuePtr,
                );

                
            }
            @sealed class FileImpl extends RustOpaque implements File {
                // Not to be used by end users
                FileImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FileImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_File,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_File,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FilePtr,
                );

                
            }
            @sealed class FileTypeImpl extends RustOpaque implements FileType {
                // Not to be used by end users
                FileTypeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FileTypeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FileType,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FileType,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FileTypePtr,
                );

                
            }
            @sealed class FillBufSelfImpl extends RustOpaque implements FillBufSelf {
                // Not to be used by end users
                FillBufSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FillBufSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FillBufSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FillBufSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FillBufSelfPtr,
                );

                
            }
            @sealed class FlushSelfImpl extends RustOpaque implements FlushSelf {
                // Not to be used by end users
                FlushSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FlushSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FlushSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FlushSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FlushSelfPtr,
                );

                
            }
            @sealed class FrequentwordTypeImpl extends RustOpaque implements FrequentwordType {
                // Not to be used by end users
                FrequentwordTypeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                FrequentwordTypeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_FrequentwordType,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_FrequentwordType,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_FrequentwordTypePtr,
                );

                
            }
            @sealed class GidTImpl extends RustOpaque implements GidT {
                // Not to be used by end users
                GidTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                GidTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_GidT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_GidT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_GidTPtr,
                );

                
            }
            @sealed class HandleImpl extends RustOpaque implements Handle {
                // Not to be used by end users
                HandleImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                HandleImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Handle,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Handle,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_HandlePtr,
                );

                /// Enters the runtime context. This allows you to construct types that must
/// have an executor available on creation such as [`Sleep`] or
/// [`TcpStream`]. It will also allow you to call methods such as
/// [`tokio::spawn`] and [`Handle::current`] without panicking.
///
/// # Panics
///
/// When calling `Handle::enter` multiple times, the returned guards
/// **must** be dropped in the reverse order that they were acquired.
/// Failure to do so will result in a panic and possible memory leaks.
///
/// # Examples
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use tokio::runtime::Runtime;
///
/// let rt = Runtime::new().unwrap();
///
/// let _guard = rt.enter();
/// tokio::spawn(async {
///     println!("Hello world!");
/// });
/// # }
/// ```
///
/// Do **not** do the following, this shows a scenario that will result in a
/// panic and possible memory leak.
///
/// ```should_panic,ignore-wasm
/// use tokio::runtime::Runtime;
///
/// let rt1 = Runtime::new().unwrap();
/// let rt2 = Runtime::new().unwrap();
///
/// let enter1 = rt1.enter();
/// let enter2 = rt2.enter();
///
/// drop(enter1);
/// drop(enter2);
/// ```
///
/// [`Sleep`]: struct@crate::time::Sleep
/// [`TcpStream`]: struct@crate::net::TcpStream
/// [`tokio::spawn`]: fn@crate::spawn
 Future<EnterGuard>  enter()=>RustLib.instance.api.tokioRuntimeHandleEnter(that: this, );


/// Returns the [`Id`] of the current `Runtime`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// #[tokio::main(flavor = "current_thread")]
/// async fn main() {
///   println!("Current runtime id: {}", Handle::current().id());
/// }
/// ```
///
/// [`Id`]: struct@crate::runtime::Id
 Future<Id>  id()=>RustLib.instance.api.tokioRuntimeHandleId(that: this, );


/// Returns a view that lets you get information about how the runtime
/// is performing.
 Future<RuntimeMetrics>  metrics()=>RustLib.instance.api.tokioRuntimeHandleMetrics(that: this, );


/// Returns the flavor of the current `Runtime`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::{Handle, RuntimeFlavor};
///
/// #[tokio::main(flavor = "current_thread")]
/// async fn main() {
///   assert_eq!(RuntimeFlavor::CurrentThread, Handle::current().runtime_flavor());
/// }
/// ```
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use tokio::runtime::{Handle, RuntimeFlavor};
///
/// #[tokio::main(flavor = "multi_thread", worker_threads = 4)]
/// async fn main() {
///   assert_eq!(RuntimeFlavor::MultiThread, Handle::current().runtime_flavor());
/// }
/// # }
/// ```
 Future<RuntimeFlavor>  runtimeFlavor()=>RustLib.instance.api.tokioRuntimeHandleRuntimeFlavor(that: this, );


            }
            @sealed class HighlighterImpl extends RustOpaque implements Highlighter {
                // Not to be used by end users
                HighlighterImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                HighlighterImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Highlighter,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Highlighter,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_HighlighterPtr,
                );

                
            }
            @sealed class IdImpl extends RustOpaque implements Id {
                // Not to be used by end users
                IdImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Id,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Id,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IdPtr,
                );

                
            }
            @sealed class IndexImpl extends RustOpaque implements Index {
                // Not to be used by end users
                IndexImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IndexImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Index,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Index,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IndexPtr,
                );

                /// Add/append/update/merge synonyms in index
/// Affects only subsequently indexed documents
 Future<BigInt>  addSynonyms({required List<Synonym> synonyms })=>RustLib.instance.api.seekstormIndexIndexAddSynonyms(that: this, synonyms: synonyms);


 int get indexFormatVersionMajor=>RustLib.instance.api.seekstormIndexIndexAutoAccessorGetIndexFormatVersionMajor(that: this, );


 int get indexFormatVersionMinor=>RustLib.instance.api.seekstormIndexIndexAutoAccessorGetIndexFormatVersionMinor(that: this, );


 IndexMetaObject get meta=>RustLib.instance.api.seekstormIndexIndexAutoAccessorGetMeta(that: this, );


 Map<String, SchemaField> get schemaMap=>RustLib.instance.api.seekstormIndexIndexAutoAccessorGetSchemaMap(that: this, );


 List<String> get storedFieldNames=>RustLib.instance.api.seekstormIndexIndexAutoAccessorGetStoredFieldNames(that: this, );


  set indexFormatVersionMajor(int indexFormatVersionMajor)=>RustLib.instance.api.seekstormIndexIndexAutoAccessorSetIndexFormatVersionMajor(that: this, indexFormatVersionMajor: indexFormatVersionMajor);


  set indexFormatVersionMinor(int indexFormatVersionMinor)=>RustLib.instance.api.seekstormIndexIndexAutoAccessorSetIndexFormatVersionMinor(that: this, indexFormatVersionMinor: indexFormatVersionMinor);


  set meta(IndexMetaObject meta)=>RustLib.instance.api.seekstormIndexIndexAutoAccessorSetMeta(that: this, meta: meta);


  set schemaMap(Map<String, SchemaField> schemaMap)=>RustLib.instance.api.seekstormIndexIndexAutoAccessorSetSchemaMap(that: this, schemaMap: schemaMap);


  set storedFieldNames(List<String> storedFieldNames)=>RustLib.instance.api.seekstormIndexIndexAutoAccessorSetStoredFieldNames(that: this, storedFieldNames: storedFieldNames);


/// Reset index to empty, while maintaining schema
 Future<void>  clearIndex()=>RustLib.instance.api.seekstormIndexIndexClearIndex(that: this, );


/// Get number of indexed documents.
 Future<BigInt>  committedDocCount()=>RustLib.instance.api.seekstormIndexIndexCommittedDocCount(that: this, );


/// Current document count: indexed document count - deleted document count
 Future<BigInt>  currentDocCount()=>RustLib.instance.api.seekstormIndexIndexCurrentDocCount(that: this, );


/// Delete index from disc and ram
 Future<void>  deleteIndex()=>RustLib.instance.api.seekstormIndexIndexDeleteIndex(that: this, );


/// Get number of facets defined in the index schema.
 Future<BigInt>  facetsCount()=>RustLib.instance.api.seekstormIndexIndexFacetsCount(that: this, );


/// Get document for document id
/// Arguments:
/// * `doc_id`: Specifies which document to load from the document store of the index.
/// * `include_uncommited`: Return also documents which have not yet been committed.
/// * `highlighter_option`: Specifies the extraction of keyword-in-context (KWIC) fragments from fields in documents, and the highlighting of the query terms within.
/// * `fields`: Specifies which of the stored fields to return with each document. Default: If empty return all stored fields
/// * `distance_fields`: insert distance fields into result documents, calculating the distance between a specified facet field of type Point and a base Point, in kilometers or miles.
///   using Euclidian distance (Pythagoras theorem) with Equirectangular approximation.
 Future<Map<String, Value>>  getDocument({required BigInt docId , required bool includeUncommited , Highlighter? highlighterOption , required Set<String> fields , required List<DistanceField> distanceFields })=>RustLib.instance.api.seekstormIndexIndexGetDocument(that: this, docId: docId, includeUncommited: includeUncommited, highlighterOption: highlighterOption, fields: fields, distanceFields: distanceFields);


/// get_facet_value: Returns value from facet field for a doc_id even if schema stored=false (field not stored in document JSON).  
/// Facet fields are more compact than fields stored in document JSON.
/// Strings are stored more compact as indices to a unique term dictionary. Numbers are stored binary, not as strings.
/// Facet fields are faster because no document loading, decompression and JSON decoding is required.  
/// Facet fields are always memory mapped, internally always stored with fixed byte length layout, regardless of string size.
 Future<FacetValue>  getFacetValue({required String field , required BigInt docId })=>RustLib.instance.api.seekstormIndexIndexGetFacetValue(that: this, field: field, docId: docId);


/// Get file for document id
/// Arguments:
/// * `doc_id`: Specifies which document to load from the document store of the index.
///
/// Returns:
/// * `Vec<u8>`: The file content as a byte vector.
///
 Future<Uint8List>  getFile({required BigInt docId })=>RustLib.instance.api.seekstormIndexIndexGetFile(that: this, docId: docId);


/// get_index_string_facets: list of string facet fields, each with field name and a map of unique values and their count (number of times the specific value appears in the whole index).
/// values are sorted by their occurrence count within all indexed documents in descending order
/// * `query_facets`: Must be set if facet fields should be returned in get_index_facets. If set to Vec::new() then no facet fields are returned.
///   The prefix property of a QueryFacet allows to filter the returned facet values to those matching a given prefix, if there are too many distinct values per facet field.
///   The length property of a QueryFacet allows limiting the number of returned distinct values per facet field, if there are too many distinct values.  The QueryFacet can be used to improve the usability in an UI.
///   If the length property of a QueryFacet is set to 0 then no facet values for that facet are returned.
///   The facet values are sorted by the frequency of the appearance of the value within the indexed documents matching the query in descending order.
///   Example: query_facets = vec![QueryFacet::String16 {field: "language".to_string(),prefix: "ger".to_string(),length: 5},QueryFacet::String16 {field: "brand".to_string(),prefix: "a".to_string(),length: 5}];
 Future<AHashMapStringFacet?>  getIndexStringFacets({required List<QueryFacet> queryFacets })=>RustLib.instance.api.seekstormIndexIndexGetIndexStringFacets(that: this, queryFacets: queryFacets);


/// Get synonyms from index
 Future<List<Synonym>>  getSynonyms()=>RustLib.instance.api.seekstormIndexIndexGetSynonyms(that: this, );


/// get_index_facets_minmax: return map of numeric facet fields, each with field name and min/max values.
 Future<Map<String, MinMaxFieldJson>>  indexFacetsMinmax()=>RustLib.instance.api.seekstormIndexIndexIndexFacetsMinmax(that: this, );


/// Get number of indexed documents.
 Future<BigInt>  indexedDocCount()=>RustLib.instance.api.seekstormIndexIndexIndexedDocCount(that: this, );


/// Get number of index levels. One index level comprises 64K documents.
 Future<BigInt>  levelCount()=>RustLib.instance.api.seekstormIndexIndexLevelCount(that: this, );


/// Set/replace/overwrite synonyms in index
/// Affects only subsequently indexed documents
 Future<BigInt>  setSynonyms({required List<Synonym> synonyms })=>RustLib.instance.api.seekstormIndexIndexSetSynonyms(that: this, synonyms: synonyms);


/// Get number of index shards.
 Future<BigInt>  shardCount()=>RustLib.instance.api.seekstormIndexIndexShardCount(that: this, );


/// are there uncommited documents?
 Future<BigInt>  uncommittedDocCount()=>RustLib.instance.api.seekstormIndexIndexUncommittedDocCount(that: this, );


            }
            @sealed class IndexMapStringVecStringUsizeImpl extends RustOpaque implements IndexMapStringVecStringUsize {
                // Not to be used by end users
                IndexMapStringVecStringUsizeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IndexMapStringVecStringUsizeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_IndexMapStringVecStringUsize,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_IndexMapStringVecStringUsize,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IndexMapStringVecStringUsizePtr,
                );

                
            }
            @sealed class IndexMetaObjectImpl extends RustOpaque implements IndexMetaObject {
                // Not to be used by end users
                IndexMetaObjectImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IndexMetaObjectImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_IndexMetaObject,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_IndexMetaObject,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IndexMetaObjectPtr,
                );

                 AccessType get accessType=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetAccessType(that: this, );


 FrequentwordType get frequentWords=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetFrequentWords(that: this, );


 BigInt get id=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetId(that: this, );


 String get name=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetName(that: this, );


 int get ngramIndexing=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetNgramIndexing(that: this, );


 QueryCompletion? get queryCompletion=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetQueryCompletion(that: this, );


 SimilarityType get similarity=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetSimilarity(that: this, );


 SpellingCorrection? get spellingCorrection=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetSpellingCorrection(that: this, );


 StemmerType get stemmer=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetStemmer(that: this, );


 StopwordType get stopWords=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetStopWords(that: this, );


 TokenizerType get tokenizer=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorGetTokenizer(that: this, );


  set accessType(AccessType accessType)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetAccessType(that: this, accessType: accessType);


  set frequentWords(FrequentwordType frequentWords)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetFrequentWords(that: this, frequentWords: frequentWords);


  set id(BigInt id)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetId(that: this, id: id);


  set name(String name)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetName(that: this, name: name);


  set ngramIndexing(int ngramIndexing)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetNgramIndexing(that: this, ngramIndexing: ngramIndexing);


  set queryCompletion(QueryCompletion? queryCompletion)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetQueryCompletion(that: this, queryCompletion: queryCompletion);


  set similarity(SimilarityType similarity)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetSimilarity(that: this, similarity: similarity);


  set spellingCorrection(SpellingCorrection? spellingCorrection)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetSpellingCorrection(that: this, spellingCorrection: spellingCorrection);


  set stemmer(StemmerType stemmer)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetStemmer(that: this, stemmer: stemmer);


  set stopWords(StopwordType stopWords)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetStopWords(that: this, stopWords: stopWords);


  set tokenizer(TokenizerType tokenizer)=>RustLib.instance.api.seekstormIndexIndexMetaObjectAutoAccessorSetTokenizer(that: this, tokenizer: tokenizer);


            }
            @sealed class InstantImpl extends RustOpaque implements Instant {
                // Not to be used by end users
                InstantImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                InstantImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Instant,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Instant,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_InstantPtr,
                );

                
            }
            @sealed class InterestImpl extends RustOpaque implements Interest {
                // Not to be used by end users
                InterestImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                InterestImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Interest,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Interest,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_InterestPtr,
                );

                /// Add together two `Interest` values.
///
/// This function works from a `const` context.
///
/// # Examples
///
/// ```
/// use tokio::io::Interest;
///
/// const BOTH: Interest = Interest::READABLE.add(Interest::WRITABLE);
///
/// assert!(BOTH.is_readable());
/// assert!(BOTH.is_writable());
 Future<Interest>  add({required Interest other })=>RustLib.instance.api.tokioIoInterestAdd(that: this, other: other);


/// Returns true if the value includes error interest.
///
/// # Examples
///
/// ```
/// use tokio::io::Interest;
///
/// assert!(Interest::ERROR.is_error());
/// assert!(!Interest::WRITABLE.is_error());
///
/// let combined = Interest::READABLE | Interest::ERROR;
/// assert!(combined.is_error());
/// ```
 Future<bool>  isError()=>RustLib.instance.api.tokioIoInterestIsError(that: this, );


/// Returns true if the value includes readable interest.
///
/// # Examples
///
/// ```
/// use tokio::io::Interest;
///
/// assert!(Interest::READABLE.is_readable());
/// assert!(!Interest::WRITABLE.is_readable());
///
/// let both = Interest::READABLE | Interest::WRITABLE;
/// assert!(both.is_readable());
/// ```
 Future<bool>  isReadable()=>RustLib.instance.api.tokioIoInterestIsReadable(that: this, );


/// Returns true if the value includes writable interest.
///
/// # Examples
///
/// ```
/// use tokio::io::Interest;
///
/// assert!(!Interest::READABLE.is_writable());
/// assert!(Interest::WRITABLE.is_writable());
///
/// let both = Interest::READABLE | Interest::WRITABLE;
/// assert!(both.is_writable());
/// ```
 Future<bool>  isWritable()=>RustLib.instance.api.tokioIoInterestIsWritable(that: this, );


/// Remove `Interest` from `self`.
///
/// Interests present in `other` but *not* in `self` are ignored.
///
/// Returns `None` if the set would be empty after removing `Interest`.
///
/// # Examples
///
/// ```
/// use tokio::io::Interest;
///
/// const RW_INTEREST: Interest = Interest::READABLE.add(Interest::WRITABLE);
///
/// let w_interest = RW_INTEREST.remove(Interest::READABLE).unwrap();
/// assert!(!w_interest.is_readable());
/// assert!(w_interest.is_writable());
///
/// // Removing all interests from the set returns `None`.
/// assert_eq!(w_interest.remove(Interest::WRITABLE), None);
///
/// // Remove all interests at once.
/// assert_eq!(RW_INTEREST.remove(RW_INTEREST), None);
/// ```
 Future<Interest?>  remove({required Interest other })=>RustLib.instance.api.tokioIoInterestRemove(that: this, other: other);


            }
            @sealed class IntervalImpl extends RustOpaque implements Interval {
                // Not to be used by end users
                IntervalImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IntervalImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Interval,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Interval,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IntervalPtr,
                );

                /// Returns the [`MissedTickBehavior`] strategy currently being used.
 Future<MissedTickBehavior>  missedTickBehavior()=>RustLib.instance.api.tokioTimeIntervalMissedTickBehavior(that: this, );


/// Returns the period of the interval.
 Future<Duration>  period()=>RustLib.instance.api.tokioTimeIntervalPeriod(that: this, );


/// Polls for the next instant in the interval to be reached.
///
/// This method can return the following values:
///
///  * `Poll::Pending` if the next instant has not yet been reached.
///  * `Poll::Ready(instant)` if the next instant has been reached.
///
/// When this method returns `Poll::Pending`, the current task is scheduled
/// to receive a wakeup when the instant has elapsed. Note that on multiple
/// calls to `poll_tick`, only the [`Waker`](std::task::Waker) from the
/// [`Context`] passed to the most recent call is scheduled to receive a
/// wakeup.
 Future<PollInstant>  pollTick({required Context cx })=>RustLib.instance.api.tokioTimeIntervalPollTick(that: this, cx: cx);


/// Resets the interval to complete one period after the current time.
///
/// This method ignores [`MissedTickBehavior`] strategy.
///
/// This is equivalent to calling `reset_at(Instant::now() + period)`.
///
/// # Examples
///
/// ```
/// use tokio::time;
///
/// use std::time::Duration;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(100));
///
/// interval.tick().await;
///
/// time::sleep(Duration::from_millis(50)).await;
/// interval.reset();
///
/// interval.tick().await;
/// interval.tick().await;
///
/// // approximately 250ms have elapsed.
/// # }
/// ```
 Future<void>  reset()=>RustLib.instance.api.tokioTimeIntervalReset(that: this, );


/// Resets the interval after the specified [`std::time::Duration`].
///
/// This method ignores [`MissedTickBehavior`] strategy.
///
/// This is equivalent to calling `reset_at(Instant::now() + after)`.
///
/// # Examples
///
/// ```
/// use tokio::time;
///
/// use std::time::Duration;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(100));
/// interval.tick().await;
///
/// time::sleep(Duration::from_millis(50)).await;
///
/// let after = Duration::from_millis(20);
/// interval.reset_after(after);
///
/// interval.tick().await;
/// interval.tick().await;
///
/// // approximately 170ms have elapsed.
/// # }
/// ```
 Future<void>  resetAfter({required Duration after })=>RustLib.instance.api.tokioTimeIntervalResetAfter(that: this, after: after);


/// Resets the interval to a [`crate::time::Instant`] deadline.
///
/// Sets the next tick to expire at the given instant. If the instant is in
/// the past, then the [`MissedTickBehavior`] strategy will be used to
/// catch up. If the instant is in the future, then the next tick will
/// complete at the given instant, even if that means that it will sleep for
/// longer than the duration of this [`Interval`]. If the [`Interval`] had
/// any missed ticks before calling this method, then those are discarded.
///
/// # Examples
///
/// ```
/// use tokio::time::{self, Instant};
///
/// use std::time::Duration;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(100));
/// interval.tick().await;
///
/// time::sleep(Duration::from_millis(50)).await;
///
/// let deadline = Instant::now() + Duration::from_millis(30);
/// interval.reset_at(deadline);
///
/// interval.tick().await;
/// interval.tick().await;
///
/// // approximately 180ms have elapsed.
/// # }
/// ```
 Future<void>  resetAt({required Instant deadline })=>RustLib.instance.api.tokioTimeIntervalResetAt(that: this, deadline: deadline);


/// Resets the interval immediately.
///
/// This method ignores [`MissedTickBehavior`] strategy.
///
/// This is equivalent to calling `reset_at(Instant::now())`.
///
/// # Examples
///
/// ```
/// use tokio::time;
///
/// use std::time::Duration;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(100));
///
/// interval.tick().await;
///
/// time::sleep(Duration::from_millis(50)).await;
/// interval.reset_immediately();
///
/// interval.tick().await;
/// interval.tick().await;
///
/// // approximately 150ms have elapsed.
/// # }
/// ```
 Future<void>  resetImmediately()=>RustLib.instance.api.tokioTimeIntervalResetImmediately(that: this, );


/// Sets the [`MissedTickBehavior`] strategy that should be used.
 Future<void>  setMissedTickBehavior({required MissedTickBehavior behavior })=>RustLib.instance.api.tokioTimeIntervalSetMissedTickBehavior(that: this, behavior: behavior);


/// Completes when the next instant in the interval has been reached.
///
/// # Cancel safety
///
/// This method is cancellation safe. If `tick` is used as the branch in a `tokio::select!` and
/// another branch completes first, then no tick has been consumed.
///
/// # Examples
///
/// ```
/// use tokio::time;
///
/// use std::time::Duration;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(10));
///
/// interval.tick().await;
/// // approximately 0ms have elapsed. The first tick completes immediately.
/// interval.tick().await;
/// interval.tick().await;
///
/// // approximately 20ms have elapsed.
/// # }
/// ```
 Future<Instant>  tick()=>RustLib.instance.api.tokioTimeIntervalTick(that: this, );


            }
            @sealed class IoSliceImpl extends RustOpaque implements IoSlice {
                // Not to be used by end users
                IoSliceImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IoSliceImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_IoSlice,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_IoSlice,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IoSlicePtr,
                );

                
            }
            @sealed class IoSliceMutImpl extends RustOpaque implements IoSliceMut {
                // Not to be used by end users
                IoSliceMutImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                IoSliceMutImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_IoSliceMut,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_IoSliceMut,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_IoSliceMutPtr,
                );

                
            }
            @sealed class Ipv4AddrImpl extends RustOpaque implements Ipv4Addr {
                // Not to be used by end users
                Ipv4AddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                Ipv4AddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Ipv4Addr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Ipv4Addr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_Ipv4AddrPtr,
                );

                
            }
            @sealed class Ipv6AddrImpl extends RustOpaque implements Ipv6Addr {
                // Not to be used by end users
                Ipv6AddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                Ipv6AddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Ipv6Addr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Ipv6Addr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_Ipv6AddrPtr,
                );

                
            }
            @sealed class LinesSelfImpl extends RustOpaque implements LinesSelf {
                // Not to be used by end users
                LinesSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                LinesSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_LinesSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_LinesSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_LinesSelfPtr,
                );

                
            }
            @sealed class LocalEnterGuardImpl extends RustOpaque implements LocalEnterGuard {
                // Not to be used by end users
                LocalEnterGuardImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                LocalEnterGuardImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_LocalEnterGuard,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_LocalEnterGuard,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_LocalEnterGuardPtr,
                );

                
            }
            @sealed class LocalSetImpl extends RustOpaque implements LocalSet {
                // Not to be used by end users
                LocalSetImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                LocalSetImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_LocalSet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_LocalSet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_LocalSetPtr,
                );

                /// Enters the context of this `LocalSet`.
///
/// The [`spawn_local`] method will spawn tasks on the `LocalSet` whose
/// context you are inside.
///
/// [`spawn_local`]: fn@crate::task::spawn_local
 Future<LocalEnterGuard>  enter()=>RustLib.instance.api.tokioTaskLocalSetEnter(that: this, );


/// Returns the [`Id`] of the current [`LocalSet`] runtime.
///
/// # Examples
///
/// ```rust
/// use tokio::task;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let local_set = task::LocalSet::new();
/// println!("Local set id: {}", local_set.id());
/// # }
/// ```
///
/// [`Id`]: struct@crate::runtime::Id
 Future<Id>  id()=>RustLib.instance.api.tokioTaskLocalSetId(that: this, );


            }
            @sealed class MinMaxFieldImpl extends RustOpaque implements MinMaxField {
                // Not to be used by end users
                MinMaxFieldImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MinMaxFieldImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_MinMaxField,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_MinMaxField,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MinMaxFieldPtr,
                );

                 ValueType get max=>RustLib.instance.api.seekstormIndexMinMaxFieldAutoAccessorGetMax(that: this, );


 ValueType get min=>RustLib.instance.api.seekstormIndexMinMaxFieldAutoAccessorGetMin(that: this, );


  set max(ValueType max)=>RustLib.instance.api.seekstormIndexMinMaxFieldAutoAccessorSetMax(that: this, max: max);


  set min(ValueType min)=>RustLib.instance.api.seekstormIndexMinMaxFieldAutoAccessorSetMin(that: this, min: min);


            }
            @sealed class MinMaxFieldJsonImpl extends RustOpaque implements MinMaxFieldJson {
                // Not to be used by end users
                MinMaxFieldJsonImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MinMaxFieldJsonImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_MinMaxFieldJson,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_MinMaxFieldJson,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MinMaxFieldJsonPtr,
                );

                 Value get max=>RustLib.instance.api.seekstormIndexMinMaxFieldJsonAutoAccessorGetMax(that: this, );


 Value get min=>RustLib.instance.api.seekstormIndexMinMaxFieldJsonAutoAccessorGetMin(that: this, );


  set max(Value max)=>RustLib.instance.api.seekstormIndexMinMaxFieldJsonAutoAccessorSetMax(that: this, max: max);


  set min(Value min)=>RustLib.instance.api.seekstormIndexMinMaxFieldJsonAutoAccessorSetMin(that: this, min: min);


            }
            @sealed class NotifiedImpl extends RustOpaque implements Notified {
                // Not to be used by end users
                NotifiedImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                NotifiedImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Notified,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Notified,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_NotifiedPtr,
                );

                
            }
            @sealed class NotifyImpl extends RustOpaque implements Notify {
                // Not to be used by end users
                NotifyImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                NotifyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Notify,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Notify,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_NotifyPtr,
                );

                /// Wait for a notification.
///
/// Equivalent to:
///
/// ```ignore
/// async fn notified(&self);
/// ```
///
/// Each `Notify` value holds a single permit. If a permit is available from
/// an earlier call to [`notify_one()`], then `notified().await` will complete
/// immediately, consuming that permit. Otherwise, `notified().await` waits
/// for a permit to be made available by the next call to `notify_one()`.
///
/// The `Notified` future is not guaranteed to receive wakeups from calls to
/// `notify_one()` if it has not yet been polled. See the documentation for
/// [`Notified::enable()`] for more details.
///
/// The `Notified` future is guaranteed to receive wakeups from
/// `notify_waiters()` as soon as it has been created, even if it has not
/// yet been polled.
///
/// [`notify_one()`]: Notify::notify_one
/// [`Notified::enable()`]: Notified::enable
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute notifications in the order
/// they were requested. Cancelling a call to `notified` makes you lose your
/// place in the queue.
///
/// # Examples
///
/// ```
/// use tokio::sync::Notify;
/// use std::sync::Arc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let notify = Arc::new(Notify::new());
/// let notify2 = notify.clone();
///
/// tokio::spawn(async move {
///     notify2.notified().await;
///     println!("received notification");
/// });
///
/// println!("sending notification");
/// notify.notify_one();
/// # }
/// ```
 Future<Notified>  notified()=>RustLib.instance.api.tokioSyncNotifyNotified(that: this, );


/// Wait for a notification with an owned `Future`.
///
/// Unlike [`Self::notified`] which returns a future tied to the `Notify`'s
/// lifetime, `notified_owned` creates a self-contained future that owns its
/// notification state, making it safe to move between threads.
///
/// See [`Self::notified`] for more details.
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute notifications in the order
/// they were requested. Cancelling a call to `notified_owned` makes you lose your
/// place in the queue.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::Notify;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let notify = Arc::new(Notify::new());
///
/// for _ in 0..10 {
///     let notified = notify.clone().notified_owned();
///     tokio::spawn(async move {
///         notified.await;
///         println!("received notification");
///     });
/// }
///
/// println!("sending notification");
/// notify.notify_waiters();
/// # }
/// ```
 Future<OwnedNotified>  notifiedOwned()=>RustLib.instance.api.tokioSyncNotifyNotifiedOwned(that: this, );


/// Notifies the last waiting task.
///
/// This function behaves similar to `notify_one`. The only difference is that it wakes
/// the most recently added waiter instead of the oldest waiter.
///
/// Check the [`notify_one()`] documentation for more info and
/// examples.
///
/// [`notify_one()`]: Notify::notify_one
 Future<void>  notifyLast()=>RustLib.instance.api.tokioSyncNotifyNotifyLast(that: this, );


/// Notifies the first waiting task.
///
/// If a task is currently waiting, that task is notified. Otherwise, a
/// permit is stored in this `Notify` value and the **next** call to
/// [`notified().await`] will complete immediately consuming the permit made
/// available by this call to `notify_one()`.
///
/// At most one permit may be stored by `Notify`. Many sequential calls to
/// `notify_one` will result in a single permit being stored. The next call to
/// `notified().await` will complete immediately, but the one after that
/// will wait.
///
/// [`notified().await`]: Notify::notified()
///
/// # Examples
///
/// ```
/// use tokio::sync::Notify;
/// use std::sync::Arc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let notify = Arc::new(Notify::new());
/// let notify2 = notify.clone();
///
/// tokio::spawn(async move {
///     notify2.notified().await;
///     println!("received notification");
/// });
///
/// println!("sending notification");
/// notify.notify_one();
/// # }
/// ```
 Future<void>  notifyOne()=>RustLib.instance.api.tokioSyncNotifyNotifyOne(that: this, );


/// Notifies all waiting tasks.
///
/// If a task is currently waiting, that task is notified. Unlike with
/// `notify_one()`, no permit is stored to be used by the next call to
/// `notified().await`. The purpose of this method is to notify all
/// already registered waiters. Registering for notification is done by
/// acquiring an instance of the `Notified` future via calling `notified()`.
///
/// # Examples
///
/// ```
/// use tokio::sync::Notify;
/// use std::sync::Arc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let notify = Arc::new(Notify::new());
/// let notify2 = notify.clone();
///
/// let notified1 = notify.notified();
/// let notified2 = notify.notified();
///
/// let handle = tokio::spawn(async move {
///     println!("sending notifications");
///     notify2.notify_waiters();
/// });
///
/// notified1.await;
/// notified2.await;
/// println!("received notifications");
/// # }
/// ```
 Future<void>  notifyWaiters()=>RustLib.instance.api.tokioSyncNotifyNotifyWaiters(that: this, );


            }
            @sealed class OpenOptionsImpl extends RustOpaque implements OpenOptions {
                // Not to be used by end users
                OpenOptionsImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OpenOptionsImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OpenOptions,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OpenOptions,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OpenOptionsPtr,
                );

                /// Sets the option for the append mode.
///
/// This option, when true, means that writes will append to a file instead
/// of overwriting previous contents.  Note that setting
/// `.write(true).append(true)` has the same effect as setting only
/// `.append(true)`.
///
/// For most filesystems, the operating system guarantees that all writes are
/// atomic: no writes get mangled because another process writes at the same
/// time.
///
/// One maybe obvious note when using append-mode: make sure that all data
/// that belongs together is written to the file in one operation. This
/// can be done by concatenating strings before passing them to [`write()`],
/// or using a buffered writer (with a buffer of adequate size),
/// and calling [`flush()`] when the message is complete.
///
/// If a file is opened with both read and append access, beware that after
/// opening, and after every write, the position for reading may be set at the
/// end of the file. So, before writing, save the current position (using
/// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.
///
/// This is an async version of [`std::fs::OpenOptions::append`][std]
///
/// [std]: std::fs::OpenOptions::append
///
/// ## Note
///
/// This function doesn't create the file if it doesn't exist. Use the [`create`]
/// method to do so.
///
/// [`write()`]: crate::io::AsyncWriteExt::write
/// [`flush()`]: crate::io::AsyncWriteExt::flush
/// [`seek`]: crate::io::AsyncSeekExt::seek
/// [`SeekFrom`]: std::io::SeekFrom
/// [`Current`]: std::io::SeekFrom::Current
/// [`create`]: OpenOptions::create
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .append(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  append({required bool append })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsAppend(that: this, append: append);


/// Sets the option for creating a new file.
///
/// This option indicates whether a new file will be created if the file
/// does not yet already exist.
///
/// In order for the file to be created, [`write`] or [`append`] access must
/// be used.
///
/// This is an async version of [`std::fs::OpenOptions::create`][std]
///
/// [std]: std::fs::OpenOptions::create
/// [`write`]: OpenOptions::write
/// [`append`]: OpenOptions::append
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .write(true)
///         .create(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  create({required bool create })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsCreate(that: this, create: create);


/// Sets the option to always create a new file.
///
/// This option indicates whether a new file will be created.  No file is
/// allowed to exist at the target location, also no (dangling) symlink.
///
/// This option is useful because it is atomic. Otherwise between checking
/// whether a file exists and creating a new one, the file may have been
/// created by another process (a TOCTOU race condition / attack).
///
/// If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are
/// ignored.
///
/// The file must be opened with write or append access in order to create a
/// new file.
///
/// This is an async version of [`std::fs::OpenOptions::create_new`][std]
///
/// [std]: std::fs::OpenOptions::create_new
/// [`.create()`]: OpenOptions::create
/// [`.truncate()`]: OpenOptions::truncate
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .write(true)
///         .create_new(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  createNew({required bool createNew })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsCreateNew(that: this, createNew: createNew);


/// Passes custom flags to the `flags` argument of `open`.
///
/// The bits that define the access mode are masked out with `O_ACCMODE`, to
/// ensure they do not interfere with the access mode set by Rusts options.
///
/// Custom flags can only set flags, not remove flags set by Rusts options.
/// This options overwrites any previously set custom flags.
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let mut options = OpenOptions::new();
///     options.write(true);
///     if cfg!(unix) {
///         options.custom_flags(libc::O_NOFOLLOW);
///     }
///     let file = options.open("foo.txt").await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  customFlags({required int flags })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsCustomFlags(that: this, flags: flags);


/// Sets the mode bits that a new file will be created with.
///
/// If a new file is created as part of an `OpenOptions::open` call then this
/// specified `mode` will be used as the permission bits for the new file.
/// If no `mode` is set, the default of `0o666` will be used.
/// The operating system masks out bits with the system's `umask`, to produce
/// the final permissions.
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let mut options = OpenOptions::new();
///     options.mode(0o644); // Give read/write for owner and read for others.
///     let file = options.open("foo.txt").await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  mode({required int mode })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsMode(that: this, mode: mode);


/// Sets the option for read access.
///
/// This option, when true, will indicate that the file should be
/// `read`-able if opened.
///
/// This is an async version of [`std::fs::OpenOptions::read`][std]
///
/// [std]: std::fs::OpenOptions::read
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .read(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  read({required bool read })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsRead(that: this, read: read);


/// Sets the option for truncating a previous file.
///
/// If a file is successfully opened with this option set it will truncate
/// the file to 0 length if it already exists.
///
/// The file must be opened with write access for truncate to work.
///
/// This is an async version of [`std::fs::OpenOptions::truncate`][std]
///
/// [std]: std::fs::OpenOptions::truncate
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .write(true)
///         .truncate(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  truncate({required bool truncate })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsTruncate(that: this, truncate: truncate);


/// Sets the option to skip the check for FIFO file type.
///
/// By default, [`open_receiver`] and [`open_sender`] functions will check
/// if the opened file is a FIFO file. Set this option to `true` if you are
/// sure the file is a FIFO file.
///
/// [`open_receiver`]: OpenOptions::open_receiver
/// [`open_sender`]: OpenOptions::open_sender
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use nix::{unistd::mkfifo, sys::stat::Mode};
/// # use std::error::Error;
///
/// // Our program has exclusive access to this path.
/// const FIFO_NAME: &str = "path/to/a/new/fifo";
///
/// # async fn dox() -> Result<(), Box<dyn Error>> {
/// mkfifo(FIFO_NAME, Mode::S_IRWXU)?;
/// let rx = pipe::OpenOptions::new()
///     .unchecked(true)
///     .open_receiver(FIFO_NAME)?;
/// # Ok(())
/// # }
/// ```
 Future<void>  unchecked({required bool value })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsUnchecked(that: this, value: value);


/// Sets the option for write access.
///
/// This option, when true, will indicate that the file should be
/// `write`-able if opened.
///
/// This is an async version of [`std::fs::OpenOptions::write`][std]
///
/// [std]: std::fs::OpenOptions::write
///
/// # Examples
///
/// ```no_run
/// use tokio::fs::OpenOptions;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let file = OpenOptions::new()
///         .write(true)
///         .open("foo.txt")
///         .await?;
///
///     Ok(())
/// }
/// ```
 Future<void>  write({required bool write })=>RustLib.instance.api.tokioNetUnixPipeOpenOptionsWrite(that: this, write: write);


            }
            @sealed class OrderingImpl extends RustOpaque implements Ordering {
                // Not to be used by end users
                OrderingImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OrderingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Ordering,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Ordering,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OrderingPtr,
                );

                
            }
            @sealed class OwnedFdImpl extends RustOpaque implements OwnedFd {
                // Not to be used by end users
                OwnedFdImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedFdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedFd,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedFd,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedFdPtr,
                );

                
            }
            @sealed class OwnedNotifiedImpl extends RustOpaque implements OwnedNotified {
                // Not to be used by end users
                OwnedNotifiedImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedNotifiedImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedNotified,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedNotified,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedNotifiedPtr,
                );

                
            }
            @sealed class OwnedPermitTImpl extends RustOpaque implements OwnedPermitT {
                // Not to be used by end users
                OwnedPermitTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedPermitTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedPermitT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedPermitT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedPermitTPtr,
                );

                
            }
            @sealed class OwnedReadHalfImpl extends RustOpaque implements OwnedReadHalf {
                // Not to be used by end users
                OwnedReadHalfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedReadHalfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedReadHalf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedReadHalf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedReadHalfPtr,
                );

                /// Returns the local address that this stream is bound to.
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetTcpOwnedReadHalfLocalAddr(that: this, );


/// Receives data on the socket from the remote address to which it is
/// connected, without removing that data from the queue. On success,
/// returns the number of bytes peeked.
///
/// See the [`TcpStream::peek`] level documentation for more details.
///
/// [`TcpStream::peek`]: TcpStream::peek
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use tokio::io::AsyncReadExt;
/// use std::error::Error;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///     let (mut read_half, _) = stream.into_split();
///
///     let mut b1 = [0; 10];
///     let mut b2 = [0; 10];
///
///     // Peek at the data
///     let n = read_half.peek(&mut b1).await?;
///
///     // Read the data
///     assert_eq!(n, read_half.read(&mut b2[..n]).await?);
///     assert_eq!(&b1[..n], &b2[..n]);
///
///     Ok(())
/// }
/// ```
///
/// The [`read`] method is defined on the [`AsyncReadExt`] trait.
///
/// [`read`]: fn@crate::io::AsyncReadExt::read
/// [`AsyncReadExt`]: trait@crate::io::AsyncReadExt
 Future<BigInt>  peek({required U8 buf })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfPeek(that: this, buf: buf);


/// Returns the remote address that this stream is connected to.
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetTcpOwnedReadHalfPeerAddr(that: this, );


/// Attempt to receive data on the socket, without removing that data from
/// the queue, registering the current task for wakeup if data is not yet
/// available.
///
/// Note that on multiple calls to `poll_peek` or `poll_read`, only the
/// `Waker` from the `Context` passed to the most recent call is scheduled
/// to receive a wakeup.
///
/// See the [`TcpStream::poll_peek`] level documentation for more details.
///
/// # Examples
///
/// ```no_run
/// use tokio::io::{self, ReadBuf};
/// use tokio::net::TcpStream;
///
/// use std::future::poll_fn;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let stream = TcpStream::connect("127.0.0.1:8000").await?;
///     let (mut read_half, _) = stream.into_split();
///     let mut buf = [0; 10];
///     let mut buf = ReadBuf::new(&mut buf);
///
///     poll_fn(|cx| {
///         read_half.poll_peek(cx, &mut buf)
///     }).await?;
///
///     Ok(())
/// }
/// ```
///
/// [`TcpStream::poll_peek`]: TcpStream::poll_peek
 Future<PollResultUsize>  pollPeek({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfPollPeek(that: this, cx: cx, buf: buf);


/// Waits for the socket to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with `try_read()`.
///
/// This function is also equivalent to [`TcpStream::ready`].
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<void>  readable()=>RustLib.instance.api.tokioNetTcpOwnedReadHalfReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with [`try_read()`]. It can be used instead
/// of [`readable()`] to check the returned ready set for [`Ready::READABLE`]
/// and [`Ready::READ_CLOSED`] events.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// This function is equivalent to [`TcpStream::ready`].
///
/// [`try_read()`]: Self::try_read
/// [`readable()`]: Self::readable
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfReady(that: this, interest: interest);


/// Attempts to put the two halves of a `TcpStream` back together and
/// recover the original socket. Succeeds only if the two halves
/// originated from the same call to [`into_split`].
///
/// [`into_split`]: TcpStream::into_split()
 Future<TcpStream>  reunite({required OwnedWriteHalf other })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfReunite(that: this, other: other);


/// Tries to read data from the stream into the provided buffer, returning how
/// many bytes were read.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read()` is non-blocking, the buffer does not have to be stored by
/// the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`readable()`]: Self::readable()
/// [`ready()`]: Self::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
///
/// 1. The stream's read half is closed and will no longer yield data.
/// 2. The specified buffer was 0 bytes in length.
///
/// If the stream is not ready to read data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
 Future<BigInt>  tryRead({required U8 buf })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfTryRead(that: this, buf: buf);


/// Tries to read data from the stream into the provided buffers, returning
/// how many bytes were read.
///
/// Data is copied to fill each buffer in order, with the final buffer
/// written to possibly being only partially filled. This method behaves
/// equivalently to a single call to [`try_read()`] with concatenated
/// buffers.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read_vectored()` is non-blocking, the buffer does not have to be
/// stored by the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`try_read()`]: Self::try_read()
/// [`readable()`]: Self::readable()
/// [`ready()`]: Self::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. `Ok(0)` indicates the stream's read half is closed
/// and will no longer yield data. If the stream is not ready to read data
/// `Err(io::ErrorKind::WouldBlock)` is returned.
 Future<BigInt>  tryReadVectored({required IoSliceMut bufs })=>RustLib.instance.api.tokioNetTcpOwnedReadHalfTryReadVectored(that: this, bufs: bufs);


            }
            @sealed class OwnedSemaphorePermitImpl extends RustOpaque implements OwnedSemaphorePermit {
                // Not to be used by end users
                OwnedSemaphorePermitImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedSemaphorePermitImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedSemaphorePermit,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedSemaphorePermit,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedSemaphorePermitPtr,
                );

                /// Merge two [`OwnedSemaphorePermit`] instances together, consuming `other`
/// without releasing the permits it holds.
///
/// Permits held by both `self` and `other` are released when `self` drops.
///
/// # Panics
///
/// This function panics if permits from different [`Semaphore`] instances
/// are merged.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::Semaphore;
///
/// let sem = Arc::new(Semaphore::new(10));
/// let mut permit = sem.clone().try_acquire_owned().unwrap();
///
/// for _ in 0..9 {
///     let _permit = sem.clone().try_acquire_owned().unwrap();
///     // Merge individual permits into a single one.
///     permit.merge(_permit)
/// }
///
/// assert_eq!(sem.available_permits(), 0);
///
/// // Release all permits in a single batch.
/// drop(permit);
///
/// assert_eq!(sem.available_permits(), 10);
/// ```
 Future<void>  merge({required OwnedSemaphorePermit other })=>RustLib.instance.api.tokioSyncOwnedSemaphorePermitMerge(that: this, other: other);


/// Returns the number of permits held by `self`.
 Future<BigInt>  numPermits()=>RustLib.instance.api.tokioSyncOwnedSemaphorePermitNumPermits(that: this, );


/// Returns the [`Semaphore`] from which this permit was acquired.
 Future<void>  semaphore()=>RustLib.instance.api.tokioSyncOwnedSemaphorePermitSemaphore(that: this, );


/// Splits `n` permits from `self` and returns a new [`OwnedSemaphorePermit`] instance that holds `n` permits.
///
/// If there are insufficient permits and it's not possible to reduce by `n`, returns `None`.
///
/// # Note
///
/// It will clone the owned `Arc<Semaphore>` to construct the new instance.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::Semaphore;
///
/// let sem = Arc::new(Semaphore::new(3));
///
/// let mut p1 = sem.try_acquire_many_owned(3).unwrap();
/// let p2 = p1.split(1).unwrap();
///
/// assert_eq!(p1.num_permits(), 2);
/// assert_eq!(p2.num_permits(), 1);
/// ```
 Future<OwnedSemaphorePermit?>  split({required BigInt n })=>RustLib.instance.api.tokioSyncOwnedSemaphorePermitSplit(that: this, n: n);


            }
            @sealed class OwnedWriteHalfImpl extends RustOpaque implements OwnedWriteHalf {
                // Not to be used by end users
                OwnedWriteHalfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                OwnedWriteHalfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_OwnedWriteHalf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedWriteHalf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_OwnedWriteHalfPtr,
                );

                /// Returns the local address that this stream is bound to.
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfLocalAddr(that: this, );


/// Returns the remote address that this stream is connected to.
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfPeerAddr(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with [`try_write()`]. It can be used instead
/// of [`writable()`] to check the returned ready set for [`Ready::WRITABLE`]
/// and [`Ready::WRITE_CLOSED`] events.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// This function is equivalent to [`TcpStream::ready`].
///
/// [`try_write()`]: Self::try_write
/// [`writable()`]: Self::writable
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfReady(that: this, interest: interest);


/// Attempts to put the two halves of a `TcpStream` back together and
/// recover the original socket. Succeeds only if the two halves
/// originated from the same call to [`into_split`].
///
/// [`into_split`]: TcpStream::into_split()
 Future<TcpStream>  reunite({required OwnedReadHalf other })=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfReunite(that: this, other: other);


/// Tries to write a buffer to the stream, returning how many bytes were
/// written.
///
/// The function will attempt to write the entire contents of `buf`, but
/// only part of the buffer may be written.
///
/// This function is usually paired with `writable()`.
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
 Future<BigInt>  tryWrite({required List<int> buf })=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfTryWrite(that: this, buf: buf);


/// Tries to write several buffers to the stream, returning how many bytes
/// were written.
///
/// Data is written from each buffer in order, with the final buffer read
/// from possible being only partially consumed. This method behaves
/// equivalently to a single call to [`try_write()`] with concatenated
/// buffers.
///
/// This function is usually paired with `writable()`.
///
/// [`try_write()`]: Self::try_write()
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
 Future<BigInt>  tryWriteVectored({required List<IoSlice> bufs })=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfTryWriteVectored(that: this, bufs: bufs);


/// Waits for the socket to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
/// paired with `try_write()`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<void>  writable()=>RustLib.instance.api.tokioNetTcpOwnedWriteHalfWritable(that: this, );


            }
            @sealed class PathImpl extends RustOpaque implements Path {
                // Not to be used by end users
                PathImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PathImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Path,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Path,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PathPtr,
                );

                
            }
            @sealed class PdfDocumentImpl extends RustOpaque implements PdfDocument {
                // Not to be used by end users
                PdfDocumentImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PdfDocumentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PdfDocument,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PdfDocument,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PdfDocumentPtr,
                );

                
            }
            @sealed class PermitIteratorTImpl extends RustOpaque implements PermitIteratorT {
                // Not to be used by end users
                PermitIteratorTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PermitIteratorTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PermitIteratorT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PermitIteratorT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PermitIteratorTPtr,
                );

                
            }
            @sealed class PermitTImpl extends RustOpaque implements PermitT {
                // Not to be used by end users
                PermitTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PermitTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PermitT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PermitT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PermitTPtr,
                );

                
            }
            @sealed class PidTImpl extends RustOpaque implements PidT {
                // Not to be used by end users
                PidTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PidTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PidT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PidT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PidTPtr,
                );

                
            }
            @sealed class PollImpl extends RustOpaque implements Poll {
                // Not to be used by end users
                PollImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Poll,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Poll,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollPtr,
                );

                
            }
            @sealed class PollInstantImpl extends RustOpaque implements PollInstant {
                // Not to be used by end users
                PollInstantImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollInstantImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollInstant,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollInstant,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollInstantPtr,
                );

                
            }
            @sealed class PollOptionImpl extends RustOpaque implements PollOption {
                // Not to be used by end users
                PollOptionImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollOptionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollOption,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollOption,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollOptionPtr,
                );

                
            }
            @sealed class PollOptionTImpl extends RustOpaque implements PollOptionT {
                // Not to be used by end users
                PollOptionTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollOptionTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollOptionT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollOptionT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollOptionTPtr,
                );

                
            }
            @sealed class PollRestoreOnPendingImpl extends RustOpaque implements PollRestoreOnPending {
                // Not to be used by end users
                PollRestoreOnPendingImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollRestoreOnPendingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollRestoreOnPending,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollRestoreOnPending,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollRestoreOnPendingPtr,
                );

                
            }
            @sealed class PollResultImpl extends RustOpaque implements PollResult {
                // Not to be used by end users
                PollResultImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollResultImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollResult,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollResult,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultPtr,
                );

                
            }
            @sealed class PollResultSocketAddrImpl extends RustOpaque implements PollResultSocketAddr {
                // Not to be used by end users
                PollResultSocketAddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollResultSocketAddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollResultSocketAddr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultSocketAddr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultSocketAddrPtr,
                );

                
            }
            @sealed class PollResultTcpStreamSocketAddrImpl extends RustOpaque implements PollResultTcpStreamSocketAddr {
                // Not to be used by end users
                PollResultTcpStreamSocketAddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollResultTcpStreamSocketAddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollResultTcpStreamSocketAddr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultTcpStreamSocketAddr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultTcpStreamSocketAddrPtr,
                );

                
            }
            @sealed class PollResultUnixStreamSocketAddrImpl extends RustOpaque implements PollResultUnixStreamSocketAddr {
                // Not to be used by end users
                PollResultUnixStreamSocketAddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollResultUnixStreamSocketAddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollResultUnixStreamSocketAddr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultUnixStreamSocketAddr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultUnixStreamSocketAddrPtr,
                );

                
            }
            @sealed class PollResultUsizeImpl extends RustOpaque implements PollResultUsize {
                // Not to be used by end users
                PollResultUsizeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollResultUsizeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollResultUsize,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultUsize,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollResultUsizePtr,
                );

                
            }
            @sealed class PollUsizeImpl extends RustOpaque implements PollUsize {
                // Not to be used by end users
                PollUsizeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                PollUsizeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_PollUsize,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_PollUsize,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_PollUsizePtr,
                );

                
            }
            @sealed class QueryFacetImpl extends RustOpaque implements QueryFacet {
                // Not to be used by end users
                QueryFacetImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                QueryFacetImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_QueryFacet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_QueryFacet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_QueryFacetPtr,
                );

                
            }
            @sealed class QueryRewritingImpl extends RustOpaque implements QueryRewriting {
                // Not to be used by end users
                QueryRewritingImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                QueryRewritingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_QueryRewriting,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_QueryRewriting,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_QueryRewritingPtr,
                );

                
            }
            @sealed class RangeU64Impl extends RustOpaque implements RangeU64 {
                // Not to be used by end users
                RangeU64Impl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RangeU64Impl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_RangeU64,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_RangeU64,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RangeU64Ptr,
                );

                
            }
            @sealed class RangesImpl extends RustOpaque implements Ranges {
                // Not to be used by end users
                RangesImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RangesImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Ranges,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Ranges,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RangesPtr,
                );

                
            }
            @sealed class ReadBufImpl extends RustOpaque implements ReadBuf {
                // Not to be used by end users
                ReadBufImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadBufImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadBuf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadBuf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadBufPtr,
                );

                
            }
            @sealed class ReadF32LeMutSelfImpl extends RustOpaque implements ReadF32LeMutSelf {
                // Not to be used by end users
                ReadF32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadF32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadF32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF32LeMutSelfPtr,
                );

                
            }
            @sealed class ReadF32MutSelfImpl extends RustOpaque implements ReadF32MutSelf {
                // Not to be used by end users
                ReadF32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadF32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadF32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF32MutSelfPtr,
                );

                
            }
            @sealed class ReadF64LeMutSelfImpl extends RustOpaque implements ReadF64LeMutSelf {
                // Not to be used by end users
                ReadF64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadF64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadF64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF64LeMutSelfPtr,
                );

                
            }
            @sealed class ReadF64MutSelfImpl extends RustOpaque implements ReadF64MutSelf {
                // Not to be used by end users
                ReadF64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadF64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadF64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadF64MutSelfPtr,
                );

                
            }
            @sealed class ReadHalfSimplexStreamImpl extends RustOpaque implements ReadHalfSimplexStream {
                // Not to be used by end users
                ReadHalfSimplexStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadHalfSimplexStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadHalfSimplexStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadHalfSimplexStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadHalfSimplexStreamPtr,
                );

                
            }
            @sealed class ReadI128LeMutSelfImpl extends RustOpaque implements ReadI128LeMutSelf {
                // Not to be used by end users
                ReadI128LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI128LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI128LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI128LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI128LeMutSelfPtr,
                );

                
            }
            @sealed class ReadI128MutSelfImpl extends RustOpaque implements ReadI128MutSelf {
                // Not to be used by end users
                ReadI128MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI128MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI128MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI128MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI128MutSelfPtr,
                );

                
            }
            @sealed class ReadI16LeMutSelfImpl extends RustOpaque implements ReadI16LeMutSelf {
                // Not to be used by end users
                ReadI16LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI16LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI16LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI16LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI16LeMutSelfPtr,
                );

                
            }
            @sealed class ReadI16MutSelfImpl extends RustOpaque implements ReadI16MutSelf {
                // Not to be used by end users
                ReadI16MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI16MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI16MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI16MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI16MutSelfPtr,
                );

                
            }
            @sealed class ReadI32LeMutSelfImpl extends RustOpaque implements ReadI32LeMutSelf {
                // Not to be used by end users
                ReadI32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI32LeMutSelfPtr,
                );

                
            }
            @sealed class ReadI32MutSelfImpl extends RustOpaque implements ReadI32MutSelf {
                // Not to be used by end users
                ReadI32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI32MutSelfPtr,
                );

                
            }
            @sealed class ReadI64LeMutSelfImpl extends RustOpaque implements ReadI64LeMutSelf {
                // Not to be used by end users
                ReadI64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI64LeMutSelfPtr,
                );

                
            }
            @sealed class ReadI64MutSelfImpl extends RustOpaque implements ReadI64MutSelf {
                // Not to be used by end users
                ReadI64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI64MutSelfPtr,
                );

                
            }
            @sealed class ReadI8MutSelfImpl extends RustOpaque implements ReadI8MutSelf {
                // Not to be used by end users
                ReadI8MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadI8MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadI8MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI8MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadI8MutSelfPtr,
                );

                
            }
            @sealed class ReadU128LeMutSelfImpl extends RustOpaque implements ReadU128LeMutSelf {
                // Not to be used by end users
                ReadU128LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU128LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU128LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU128LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU128LeMutSelfPtr,
                );

                
            }
            @sealed class ReadU128MutSelfImpl extends RustOpaque implements ReadU128MutSelf {
                // Not to be used by end users
                ReadU128MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU128MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU128MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU128MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU128MutSelfPtr,
                );

                
            }
            @sealed class ReadU16LeMutSelfImpl extends RustOpaque implements ReadU16LeMutSelf {
                // Not to be used by end users
                ReadU16LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU16LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU16LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU16LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU16LeMutSelfPtr,
                );

                
            }
            @sealed class ReadU16MutSelfImpl extends RustOpaque implements ReadU16MutSelf {
                // Not to be used by end users
                ReadU16MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU16MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU16MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU16MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU16MutSelfPtr,
                );

                
            }
            @sealed class ReadU32LeMutSelfImpl extends RustOpaque implements ReadU32LeMutSelf {
                // Not to be used by end users
                ReadU32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU32LeMutSelfPtr,
                );

                
            }
            @sealed class ReadU32MutSelfImpl extends RustOpaque implements ReadU32MutSelf {
                // Not to be used by end users
                ReadU32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU32MutSelfPtr,
                );

                
            }
            @sealed class ReadU64LeMutSelfImpl extends RustOpaque implements ReadU64LeMutSelf {
                // Not to be used by end users
                ReadU64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU64LeMutSelfPtr,
                );

                
            }
            @sealed class ReadU64MutSelfImpl extends RustOpaque implements ReadU64MutSelf {
                // Not to be used by end users
                ReadU64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU64MutSelfPtr,
                );

                
            }
            @sealed class ReadU8MutSelfImpl extends RustOpaque implements ReadU8MutSelf {
                // Not to be used by end users
                ReadU8MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadU8MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReadU8MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU8MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadU8MutSelfPtr,
                );

                
            }
            @sealed class ReadyImpl extends RustOpaque implements Ready {
                // Not to be used by end users
                ReadyImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReadyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Ready,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Ready,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReadyPtr,
                );

                /// Returns true if `Ready` is the empty set.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(Ready::EMPTY.is_empty());
/// assert!(!Ready::READABLE.is_empty());
/// ```
 Future<bool>  isEmpty()=>RustLib.instance.api.tokioIoReadyIsEmpty(that: this, );


/// Returns `true` if the value includes error `readiness`.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(!Ready::EMPTY.is_error());
/// assert!(!Ready::WRITABLE.is_error());
/// assert!(Ready::ERROR.is_error());
/// ```
 Future<bool>  isError()=>RustLib.instance.api.tokioIoReadyIsError(that: this, );


/// Returns `true` if the value includes read-closed `readiness`.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(!Ready::EMPTY.is_read_closed());
/// assert!(!Ready::READABLE.is_read_closed());
/// assert!(Ready::READ_CLOSED.is_read_closed());
/// ```
 Future<bool>  isReadClosed()=>RustLib.instance.api.tokioIoReadyIsReadClosed(that: this, );


/// Returns `true` if the value includes `readable`.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(!Ready::EMPTY.is_readable());
/// assert!(Ready::READABLE.is_readable());
/// assert!(Ready::READ_CLOSED.is_readable());
/// assert!(!Ready::WRITABLE.is_readable());
/// ```
 Future<bool>  isReadable()=>RustLib.instance.api.tokioIoReadyIsReadable(that: this, );


/// Returns `true` if the value includes writable `readiness`.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(!Ready::EMPTY.is_writable());
/// assert!(!Ready::READABLE.is_writable());
/// assert!(Ready::WRITABLE.is_writable());
/// assert!(Ready::WRITE_CLOSED.is_writable());
/// ```
 Future<bool>  isWritable()=>RustLib.instance.api.tokioIoReadyIsWritable(that: this, );


/// Returns `true` if the value includes write-closed `readiness`.
///
/// # Examples
///
/// ```
/// use tokio::io::Ready;
///
/// assert!(!Ready::EMPTY.is_write_closed());
/// assert!(!Ready::WRITABLE.is_write_closed());
/// assert!(Ready::WRITE_CLOSED.is_write_closed());
/// ```
 Future<bool>  isWriteClosed()=>RustLib.instance.api.tokioIoReadyIsWriteClosed(that: this, );


            }
            @sealed class ReceiverImpl extends RustOpaque implements Receiver {
                // Not to be used by end users
                ReceiverImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReceiverImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Receiver,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Receiver,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReceiverPtr,
                );

                /// Converts the pipe into an [`OwnedFd`] in blocking mode.
///
/// This function will deregister this pipe end from the event loop, set
/// it in blocking mode and perform the conversion.
 Future<OwnedFd>  intoBlockingFd()=>RustLib.instance.api.tokioNetUnixPipeReceiverIntoBlockingFd(that: this, );


/// Converts the pipe into an [`OwnedFd`] in nonblocking mode.
///
/// This function will deregister this pipe end from the event loop and
/// perform the conversion. Returned file descriptor will be in nonblocking
/// mode.
 Future<OwnedFd>  intoNonblockingFd()=>RustLib.instance.api.tokioNetUnixPipeReceiverIntoNonblockingFd(that: this, );


/// Polls for read readiness.
///
/// If the pipe is not currently ready for reading, this method will
/// store a clone of the `Waker` from the provided `Context`. When the pipe
/// becomes ready for reading, `Waker::wake` will be called on the waker.
///
/// Note that on multiple calls to `poll_read_ready` or `poll_read`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup.
///
/// This function is intended for cases where creating and pinning a future
/// via [`readable`] is not feasible. Where possible, using [`readable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// [`readable`]: Self::readable
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the pipe is not ready for reading.
/// * `Poll::Ready(Ok(()))` if the pipe is ready for reading.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
 Future<PollResult>  pollReadReady({required Context cx })=>RustLib.instance.api.tokioNetUnixPipeReceiverPollReadReady(that: this, cx: cx);


/// Waits for the pipe to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with [`try_read()`].
///
/// [`try_read()`]: Self::try_read()
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a reading end of a fifo
///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
///
///     let mut msg = vec![0; 1024];
///
///     loop {
///         // Wait for the pipe to be readable
///         rx.readable().await?;
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match rx.try_read(&mut msg) {
///             Ok(n) => {
///                 msg.truncate(n);
///                 break;
///             }
///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     println!("GOT = {:?}", msg);
///     Ok(())
/// }
/// ```
 Future<void>  readable()=>RustLib.instance.api.tokioNetUnixPipeReceiverReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function can be used instead of [`readable()`] to check the returned
/// ready set for [`Ready::READABLE`] and [`Ready::READ_CLOSED`] events.
///
/// The function may complete without the pipe being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// [`readable()`]: Self::readable
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetUnixPipeReceiverReady(that: this, interest: interest);


/// Tries to read data from the pipe into the provided buffer, returning how
/// many bytes were read.
///
/// Reads any pending data from the pipe but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read()` is non-blocking, the buffer does not have to be stored by
/// the async task and can exist entirely on the stack.
///
/// Usually [`readable()`] is used with this function.
///
/// [`readable()`]: Self::readable()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
///
/// 1. The pipe's writing end is closed and will no longer write data.
/// 2. The specified buffer was 0 bytes in length.
///
/// If the pipe is not ready to read data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a reading end of a fifo
///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
///
///     let mut msg = vec![0; 1024];
///
///     loop {
///         // Wait for the pipe to be readable
///         rx.readable().await?;
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match rx.try_read(&mut msg) {
///             Ok(n) => {
///                 msg.truncate(n);
///                 break;
///             }
///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     println!("GOT = {:?}", msg);
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryRead({required U8 buf })=>RustLib.instance.api.tokioNetUnixPipeReceiverTryRead(that: this, buf: buf);


/// Tries to read data from the pipe into the provided buffers, returning
/// how many bytes were read.
///
/// Data is copied to fill each buffer in order, with the final buffer
/// written to possibly being only partially filled. This method behaves
/// equivalently to a single call to [`try_read()`] with concatenated
/// buffers.
///
/// Reads any pending data from the pipe but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read_vectored()` is non-blocking, the buffer does not have to be
/// stored by the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] is used with this function.
///
/// [`try_read()`]: Self::try_read()
/// [`readable()`]: Self::readable()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. `Ok(0)` indicates the pipe's writing end is
/// closed and will no longer write data. If the pipe is not ready to read
/// data `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a reading end of a fifo
///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
///
///     loop {
///         // Wait for the pipe to be readable
///         rx.readable().await?;
///
///         // Creating the buffer **after** the `await` prevents it from
///         // being stored in the async task.
///         let mut buf_a = [0; 512];
///         let mut buf_b = [0; 1024];
///         let mut bufs = [
///             io::IoSliceMut::new(&mut buf_a),
///             io::IoSliceMut::new(&mut buf_b),
///         ];
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match rx.try_read_vectored(&mut bufs) {
///             Ok(0) => break,
///             Ok(n) => {
///                 println!("read {} bytes", n);
///             }
///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryReadVectored({required IoSliceMut bufs })=>RustLib.instance.api.tokioNetUnixPipeReceiverTryReadVectored(that: this, bufs: bufs);


            }
            @sealed class ReceiverTImpl extends RustOpaque implements ReceiverT {
                // Not to be used by end users
                ReceiverTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReceiverTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReceiverT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReceiverT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReceiverTPtr,
                );

                /// Blocking receive to call outside of asynchronous contexts.
///
/// # Panics
///
/// This function panics if called within an asynchronous execution
/// context.
///
/// # Examples
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use std::thread;
/// use tokio::sync::broadcast;
///
/// #[tokio::main]
/// async fn main() {
///     let (tx, mut rx) = broadcast::channel(16);
///
///     let sync_code = thread::spawn(move || {
///         assert_eq!(rx.blocking_recv(), Ok(10));
///     });
///
///     let _ = tx.send(10);
///     sync_code.join().unwrap();
/// }
/// # }
/// ```
 Future<T>  blockingRecv()=>RustLib.instance.api.tokioNetUnixPipeReceiverTBlockingRecv(that: this, );


/// Variant of [`Self::recv_many`] for blocking contexts.
///
/// The same conditions as in [`Self::blocking_recv`] apply.
 Future<BigInt>  blockingRecvMany({required VecT buffer , required BigInt limit })=>RustLib.instance.api.tokioNetUnixPipeReceiverTBlockingRecvMany(that: this, buffer: buffer, limit: limit);


/// Returns a reference to the most recently sent value.
///
/// This method does not mark the returned value as seen, so future calls to
/// [`changed`] may return immediately even if you have already seen the
/// value with a call to `borrow`.
///
/// Outstanding borrows hold a read lock on the inner value. This means that
/// long-lived borrows could cause the producer half to block. It is recommended
/// to keep the borrow as short-lived as possible. Additionally, if you are
/// running in an environment that allows `!Send` futures, you must ensure that
/// the returned `Ref` type is never held alive across an `.await` point,
/// otherwise, it can lead to a deadlock.
///
/// The priority policy of the lock is dependent on the underlying lock
/// implementation, and this type does not guarantee that any particular policy
/// will be used. In particular, a producer which is waiting to acquire the lock
/// in `send` might or might not block concurrent calls to `borrow`, e.g.:
///
/// <details><summary>Potential deadlock example</summary>
///
/// ```text
/// // Task 1 (on thread A)    |  // Task 2 (on thread B)
/// let _ref1 = rx.borrow();   |
///                            |  // will block
///                            |  let _ = tx.send(());
/// // may deadlock            |
/// let _ref2 = rx.borrow();   |
/// ```
/// </details>
///
/// For more information on when to use this method versus
/// [`borrow_and_update`], see [here](self#borrow_and_update-versus-borrow).
///
/// [`changed`]: Receiver::changed
/// [`borrow_and_update`]: Receiver::borrow_and_update
///
/// # Examples
///
/// ```
/// use tokio::sync::watch;
///
/// let (_, rx) = watch::channel("hello");
/// assert_eq!(*rx.borrow(), "hello");
/// ```
 Future<RefT>  borrow()=>RustLib.instance.api.tokioNetUnixPipeReceiverTBorrow(that: this, );


/// Returns a reference to the most recently sent value and marks that value
/// as seen.
///
/// This method marks the current value as seen. Subsequent calls to [`changed`]
/// will not return immediately until the [`Sender`] has modified the shared
/// value again.
///
/// Outstanding borrows hold a read lock on the inner value. This means that
/// long-lived borrows could cause the producer half to block. It is recommended
/// to keep the borrow as short-lived as possible. Additionally, if you are
/// running in an environment that allows `!Send` futures, you must ensure that
/// the returned `Ref` type is never held alive across an `.await` point,
/// otherwise, it can lead to a deadlock.
///
/// The priority policy of the lock is dependent on the underlying lock
/// implementation, and this type does not guarantee that any particular policy
/// will be used. In particular, a producer which is waiting to acquire the lock
/// in `send` might or might not block concurrent calls to `borrow`, e.g.:
///
/// <details><summary>Potential deadlock example</summary>
///
/// ```text
/// // Task 1 (on thread A)                |  // Task 2 (on thread B)
/// let _ref1 = rx1.borrow_and_update();   |
///                                        |  // will block
///                                        |  let _ = tx.send(());
/// // may deadlock                        |
/// let _ref2 = rx2.borrow_and_update();   |
/// ```
/// </details>
///
/// For more information on when to use this method versus [`borrow`], see
/// [here](self#borrow_and_update-versus-borrow).
///
/// [`changed`]: Receiver::changed
/// [`borrow`]: Receiver::borrow
 Future<RefT>  borrowAndUpdate()=>RustLib.instance.api.tokioNetUnixPipeReceiverTBorrowAndUpdate(that: this, );


/// Returns the current capacity of the channel.
///
/// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving
/// capacity with [`Sender::reserve`]. The capacity goes up when values are received.
/// This is distinct from [`max_capacity`], which always returns buffer capacity initially
/// specified when calling [`channel`].
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel::<()>(5);
///
/// assert_eq!(rx.capacity(), 5);
///
/// // Making a reservation drops the capacity by one.
/// let permit = tx.reserve().await.unwrap();
/// assert_eq!(rx.capacity(), 4);
/// assert_eq!(rx.len(), 0);
///
/// // Sending and receiving a value increases the capacity by one.
/// permit.send(());
/// assert_eq!(rx.len(), 1);
/// rx.recv().await.unwrap();
/// assert_eq!(rx.capacity(), 5);
///
/// // Directly sending a message drops the capacity by one.
/// tx.send(()).await.unwrap();
/// assert_eq!(rx.capacity(), 4);
/// assert_eq!(rx.len(), 1);
///
/// // Receiving the message increases the capacity by one.
/// rx.recv().await.unwrap();
/// assert_eq!(rx.capacity(), 5);
/// assert_eq!(rx.len(), 0);
/// # }
/// ```
/// [`capacity`]: Receiver::capacity
/// [`max_capacity`]: Receiver::max_capacity
 Future<BigInt>  capacity()=>RustLib.instance.api.tokioNetUnixPipeReceiverTCapacity(that: this, );


/// Waits for a change notification, then marks the current value as seen.
///
/// If the current value in the channel has not yet been marked seen when
/// this method is called, the method marks that value seen and returns
/// immediately. If the newest value has already been marked seen, then the
/// method sleeps until a new message is sent by a [`Sender`] connected to
/// this `Receiver`, or until all [`Sender`]s are dropped.
///
/// For more information, see
/// [*Change notifications*](self#change-notifications) in the module-level documentation.
///
/// # Errors
///
/// Returns a [`RecvError`](error::RecvError) if the channel has been closed __AND__
/// the current value is seen.
///
/// # Cancel safety
///
/// This method is cancel safe. If you use it as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that no values have been marked
/// seen by this call to `changed`.
///
/// [`Sender`]: struct@Sender
///
/// # Examples
///
/// ```
/// use tokio::sync::watch;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = watch::channel("hello");
///
/// tokio::spawn(async move {
///     tx.send("goodbye").unwrap();
/// });
///
/// assert!(rx.changed().await.is_ok());
/// assert_eq!(*rx.borrow_and_update(), "goodbye");
///
/// // The `tx` handle has been dropped
/// assert!(rx.changed().await.is_err());
/// # }
/// ```
 Future<void>  changed()=>RustLib.instance.api.tokioNetUnixPipeReceiverTChanged(that: this, );


/// Closes the receiving half of a channel without dropping it.
///
/// This prevents any further messages from being sent on the channel while
/// still enabling the receiver to drain messages that are buffered. Any
/// outstanding [`Permit`] values will still be able to send messages.
///
/// To guarantee that no messages are dropped, after calling `close()`,
/// `recv()` must be called until `None` is returned. If there are
/// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will
/// not return `None` until those are released.
///
/// [`Permit`]: Permit
/// [`OwnedPermit`]: OwnedPermit
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(20);
///
/// tokio::spawn(async move {
///     let mut i = 0;
///     while let Ok(permit) = tx.reserve().await {
///         permit.send(i);
///         i += 1;
///     }
/// });
///
/// rx.close();
///
/// while let Some(msg) = rx.recv().await {
///     println!("got {}", msg);
/// }
///
/// // Channel closed and no messages are lost.
/// # }
/// ```
 Future<void>  close()=>RustLib.instance.api.tokioNetUnixPipeReceiverTClose(that: this, );


/// Checks if this channel contains a message that this receiver has not yet
/// seen. The current value will not be marked as seen.
///
/// Although this method is called `has_changed`, it does not check
/// messages for equality, so this call will return true even if the current
/// message is equal to the previous message.
///
/// # Errors
///
/// Returns a [`RecvError`](error::RecvError) if and only if the channel has been closed.
///
/// # Examples
///
/// ## Basic usage
///
/// ```
/// use tokio::sync::watch;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = watch::channel("hello");
///
/// tx.send("goodbye").unwrap();
///
/// assert!(rx.has_changed().unwrap());
/// assert_eq!(*rx.borrow_and_update(), "goodbye");
///
/// // The value has been marked as seen
/// assert!(!rx.has_changed().unwrap());
/// # }
/// ```
///
/// ## Closed channel example
///
/// ```
/// use tokio::sync::watch;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, rx) = watch::channel("hello");
/// tx.send("goodbye").unwrap();
///
/// drop(tx);
///
/// // The channel is closed
/// assert!(rx.has_changed().is_err());
/// # }
/// ```
 Future<bool>  hasChanged()=>RustLib.instance.api.tokioNetUnixPipeReceiverTHasChanged(that: this, );


/// Checks if a channel is closed.
///
/// This method returns `true` if the channel has been closed. The channel is closed
/// when all [`Sender`] have been dropped.
///
/// [`Sender`]: crate::sync::broadcast::Sender
///
/// # Examples
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, rx) = broadcast::channel::<()>(10);
/// assert!(!rx.is_closed());
///
/// drop(tx);
///
/// assert!(rx.is_closed());
/// # }
/// ```
 Future<bool>  isClosed()=>RustLib.instance.api.tokioNetUnixPipeReceiverTIsClosed(that: this, );


/// Returns true if there aren't any messages in the channel that the [`Receiver`]
/// has yet to receive.
///
/// [`Receiver`]: crate::sync::broadcast::Receiver
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
///
/// assert!(rx1.is_empty());
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
///
/// assert!(!rx1.is_empty());
/// assert_eq!(rx1.recv().await.unwrap(), 10);
/// assert_eq!(rx1.recv().await.unwrap(), 20);
/// assert!(rx1.is_empty());
/// # }
/// ```
 Future<bool>  isEmpty()=>RustLib.instance.api.tokioNetUnixPipeReceiverTIsEmpty(that: this, );


/// Checks if this receiver is terminated.
///
/// This function returns true if this receiver has already yielded a [`Poll::Ready`] result.
/// If so, this receiver should no longer be polled.
///
/// # Examples
///
/// Sending a value and polling it.
///
/// ```
/// use tokio::sync::oneshot;
///
/// use std::task::Poll;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = oneshot::channel();
///
/// // A receiver is not terminated when it is initialized.
/// assert!(!rx.is_terminated());
///
/// // A receiver is not terminated it is polled and is still pending.
/// let poll = futures::poll!(&mut rx);
/// assert_eq!(poll, Poll::Pending);
/// assert!(!rx.is_terminated());
///
/// // A receiver is not terminated if a value has been sent, but not yet read.
/// tx.send(0).unwrap();
/// assert!(!rx.is_terminated());
///
/// // A receiver *is* terminated after it has been polled and yielded a value.
/// assert_eq!((&mut rx).await, Ok(0));
/// assert!(rx.is_terminated());
/// # }
/// ```
///
/// Dropping the sender.
///
/// ```
/// use tokio::sync::oneshot;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = oneshot::channel::<()>();
///
/// // A receiver is not immediately terminated when the sender is dropped.
/// drop(tx);
/// assert!(!rx.is_terminated());
///
/// // A receiver *is* terminated after it has been polled and yielded an error.
/// let _ = (&mut rx).await.unwrap_err();
/// assert!(rx.is_terminated());
/// # }
/// ```
 Future<bool>  isTerminated()=>RustLib.instance.api.tokioNetUnixPipeReceiverTIsTerminated(that: this, );


/// Returns the number of messages that were sent into the channel and that
/// this [`Receiver`] has yet to receive.
///
/// If the returned value from `len` is larger than the next largest power of 2
/// of the capacity of the channel any call to [`recv`] will return an
/// `Err(RecvError::Lagged)` and any call to [`try_recv`] will return an
/// `Err(TryRecvError::Lagged)`, e.g. if the capacity of the channel is 10,
/// [`recv`] will start to return `Err(RecvError::Lagged)` once `len` returns
/// values larger than 16.
///
/// [`Receiver`]: crate::sync::broadcast::Receiver
/// [`recv`]: crate::sync::broadcast::Receiver::recv
/// [`try_recv`]: crate::sync::broadcast::Receiver::try_recv
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
///
/// assert_eq!(rx1.len(), 2);
/// assert_eq!(rx1.recv().await.unwrap(), 10);
/// assert_eq!(rx1.len(), 1);
/// assert_eq!(rx1.recv().await.unwrap(), 20);
/// assert_eq!(rx1.len(), 0);
/// # }
/// ```
 Future<BigInt>  len()=>RustLib.instance.api.tokioNetUnixPipeReceiverTLen(that: this, );


/// Marks the state as changed.
///
/// After invoking this method [`has_changed()`](Self::has_changed)
/// returns `true` and [`changed()`](Self::changed) returns
/// immediately, regardless of whether a new value has been sent.
///
/// This is useful for triggering an initial change notification after
/// subscribing to synchronize new receivers.
 Future<void>  markChanged()=>RustLib.instance.api.tokioNetUnixPipeReceiverTMarkChanged(that: this, );


/// Marks the state as unchanged.
///
/// The current value will be considered seen by the receiver.
///
/// This is useful if you are not interested in the current value
/// visible in the receiver.
 Future<void>  markUnchanged()=>RustLib.instance.api.tokioNetUnixPipeReceiverTMarkUnchanged(that: this, );


/// Returns the maximum buffer capacity of the channel.
///
/// The maximum capacity is the buffer capacity initially specified when calling
/// [`channel`]. This is distinct from [`capacity`], which returns the *current*
/// available buffer capacity: as messages are sent and received, the value
/// returned by [`capacity`] will go up or down, whereas the value
/// returned by [`max_capacity`] will remain constant.
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, rx) = mpsc::channel::<()>(5);
///
/// // both max capacity and capacity are the same at first
/// assert_eq!(rx.max_capacity(), 5);
/// assert_eq!(rx.capacity(), 5);
///
/// // Making a reservation doesn't change the max capacity.
/// let permit = tx.reserve().await.unwrap();
/// assert_eq!(rx.max_capacity(), 5);
/// // but drops the capacity by one
/// assert_eq!(rx.capacity(), 4);
/// # }
/// ```
/// [`capacity`]: Receiver::capacity
/// [`max_capacity`]: Receiver::max_capacity
 Future<BigInt>  maxCapacity()=>RustLib.instance.api.tokioNetUnixPipeReceiverTMaxCapacity(that: this, );


/// Polls to receive the next message on this channel.
///
/// This method returns:
///
///  * `Poll::Pending` if no messages are available but the channel is not
///    closed, or if a spurious failure happens.
///  * `Poll::Ready(Some(message))` if a message is available.
///  * `Poll::Ready(None)` if the channel has been closed and all messages
///    sent before it was closed have been received.
///
/// When the method returns `Poll::Pending`, the `Waker` in the provided
/// `Context` is scheduled to receive a wakeup when a message is sent on any
/// receiver, or when the channel is closed.  Note that on multiple calls to
/// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`
/// passed to the most recent call is scheduled to receive a wakeup.
///
/// If this method returns `Poll::Pending` due to a spurious failure, then
/// the `Waker` will be notified when the situation causing the spurious
/// failure has been resolved. Note that receiving such a wakeup does not
/// guarantee that the next call will succeed  it could fail with another
/// spurious failure.
 Future<PollOptionT>  pollRecv({required Context cx })=>RustLib.instance.api.tokioNetUnixPipeReceiverTPollRecv(that: this, cx: cx);


/// Polls to receive multiple messages on this channel, extending the provided buffer.
///
/// This method returns:
/// * `Poll::Pending` if no messages are available but the channel is not closed, or if a
///   spurious failure happens.
/// * `Poll::Ready(count)` where `count` is the number of messages successfully received and
///   stored in `buffer`. This can be less than, or equal to, `limit`.
/// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.
///
/// When the method returns `Poll::Pending`, the `Waker` in the provided
/// `Context` is scheduled to receive a wakeup when a message is sent on any
/// receiver, or when the channel is closed.  Note that on multiple calls to
/// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`
/// passed to the most recent call is scheduled to receive a wakeup.
///
/// Note that this method does not guarantee that exactly `limit` messages
/// are received. Rather, if at least one message is available, it returns
/// as many messages as it can up to the given limit. This method returns
/// zero only if the channel is closed (or if `limit` is zero).
///
/// # Examples
///
/// ```
/// use std::task::{Context, Poll};
/// use std::pin::Pin;
/// use tokio::sync::mpsc;
/// use futures::Future;
///
/// struct MyReceiverFuture<'a> {
///     receiver: mpsc::Receiver<i32>,
///     buffer: &'a mut Vec<i32>,
///     limit: usize,
/// }
///
/// impl<'a> Future for MyReceiverFuture<'a> {
///     type Output = usize; // Number of messages received
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         let MyReceiverFuture { receiver, buffer, limit } = &mut *self;
///
///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied
///         match receiver.poll_recv_many(cx, *buffer, *limit) {
///             Poll::Pending => Poll::Pending,
///             Poll::Ready(count) => Poll::Ready(count),
///         }
///     }
/// }
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, rx) = mpsc::channel(32);
/// let mut buffer = Vec::new();
///
/// let my_receiver_future = MyReceiverFuture {
///     receiver: rx,
///     buffer: &mut buffer,
///     limit: 3,
/// };
///
/// for i in 0..10 {
///     tx.send(i).await.unwrap();
/// }
///
/// let count = my_receiver_future.await;
/// assert_eq!(count, 3);
/// assert_eq!(buffer, vec![0,1,2])
/// # }
/// ```
 Future<PollUsize>  pollRecvMany({required Context cx , required VecT buffer , required BigInt limit })=>RustLib.instance.api.tokioNetUnixPipeReceiverTPollRecvMany(that: this, cx: cx, buffer: buffer, limit: limit);


/// Receives the next value for this receiver.
///
/// Each [`Receiver`] handle will receive a clone of all values sent
/// **after** it has subscribed.
///
/// `Err(RecvError::Closed)` is returned when all `Sender` halves have
/// dropped, indicating that no further values can be sent on the channel.
///
/// If the [`Receiver`] handle falls behind, once the channel is full, newly
/// sent values will overwrite old values. At this point, a call to [`recv`]
/// will return with `Err(RecvError::Lagged)` and the [`Receiver`]'s
/// internal cursor is updated to point to the oldest value still held by
/// the channel. A subsequent call to [`recv`] will return this value
/// **unless** it has been since overwritten.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// channel.
///
/// [`Receiver`]: crate::sync::broadcast::Receiver
/// [`recv`]: crate::sync::broadcast::Receiver::recv
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
/// let mut rx2 = tx.subscribe();
///
/// tokio::spawn(async move {
///     assert_eq!(rx1.recv().await.unwrap(), 10);
///     assert_eq!(rx1.recv().await.unwrap(), 20);
/// });
///
/// tokio::spawn(async move {
///     assert_eq!(rx2.recv().await.unwrap(), 10);
///     assert_eq!(rx2.recv().await.unwrap(), 20);
/// });
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
/// # }
/// ```
///
/// Handling lag
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = broadcast::channel(2);
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
/// tx.send(30).unwrap();
///
/// // The receiver lagged behind
/// assert!(rx.recv().await.is_err());
///
/// // At this point, we can abort or continue with lost messages
///
/// assert_eq!(20, rx.recv().await.unwrap());
/// assert_eq!(30, rx.recv().await.unwrap());
/// # }
/// ```
 Future<T>  recv()=>RustLib.instance.api.tokioNetUnixPipeReceiverTRecv(that: this, );


/// Receives the next values for this receiver and extends `buffer`.
///
/// This method extends `buffer` by no more than a fixed number of values
/// as specified by `limit`. If `limit` is zero, the function immediately
/// returns `0`. The return value is the number of values added to `buffer`.
///
/// For `limit > 0`, if there are no messages in the channel's queue, but
/// the channel has not yet been closed, this method will sleep until a
/// message is sent or the channel is closed. Note that if [`close`] is
/// called, but there are still outstanding [`Permits`] from before it was
/// closed, the channel is not considered closed by `recv_many` until the
/// permits are released.
///
/// For non-zero values of `limit`, this method will never return `0` unless
/// the channel has been closed and there are no remaining messages in the
/// channel's queue. This indicates that no further values can ever be
/// received from this `Receiver`. The channel is closed when all senders
/// have been dropped, or when [`close`] is called.
///
/// The capacity of `buffer` is increased as needed.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv_many` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// channel.
///
/// [`close`]: Self::close
/// [`Permits`]: struct@crate::sync::mpsc::Permit
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut buffer: Vec<&str> = Vec::with_capacity(2);
/// let limit = 2;
/// let (tx, mut rx) = mpsc::channel(100);
/// let tx2 = tx.clone();
/// tx2.send("first").await.unwrap();
/// tx2.send("second").await.unwrap();
/// tx2.send("third").await.unwrap();
///
/// // Call `recv_many` to receive up to `limit` (2) values.
/// assert_eq!(2, rx.recv_many(&mut buffer, limit).await);
/// assert_eq!(vec!["first", "second"], buffer);
///
/// // If the buffer is full, the next call to `recv_many`
/// // reserves additional capacity.
/// assert_eq!(1, rx.recv_many(&mut buffer, 1).await);
///
/// tokio::spawn(async move {
///     tx.send("fourth").await.unwrap();
/// });
///
/// // 'tx' is dropped, but `recv_many`
/// // is guaranteed not to return 0 as the channel
/// // is not yet closed.
/// assert_eq!(1, rx.recv_many(&mut buffer, 1).await);
/// assert_eq!(vec!["first", "second", "third", "fourth"], buffer);
///
/// // Once the last sender is dropped, the channel is
/// // closed and `recv_many` returns 0, capacity unchanged.
/// drop(tx2);
/// assert_eq!(0, rx.recv_many(&mut buffer, limit).await);
/// assert_eq!(vec!["first", "second", "third", "fourth"], buffer);
/// # }
/// ```
 Future<BigInt>  recvMany({required VecT buffer , required BigInt limit })=>RustLib.instance.api.tokioNetUnixPipeReceiverTRecvMany(that: this, buffer: buffer, limit: limit);


/// Re-subscribes to the channel starting from the current tail element.
///
/// This [`Receiver`] handle will receive a clone of all values sent
/// **after** it has resubscribed. This will not include elements that are
/// in the queue of the current receiver. Consider the following example.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = broadcast::channel(2);
///
/// tx.send(1).unwrap();
/// let mut rx2 = rx.resubscribe();
/// tx.send(2).unwrap();
///
/// assert_eq!(rx2.recv().await.unwrap(), 2);
/// assert_eq!(rx.recv().await.unwrap(), 1);
/// # }
/// ```
 Future<ReceiverT>  resubscribe()=>RustLib.instance.api.tokioNetUnixPipeReceiverTResubscribe(that: this, );


/// Returns `true` if receivers belong to the same channel.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, rx) = broadcast::channel::<()>(16);
/// let rx2 = tx.subscribe();
///
/// assert!(rx.same_channel(&rx2));
///
/// let (_tx3, rx3) = broadcast::channel::<()>(16);
///
/// assert!(!rx3.same_channel(&rx2));
/// # }
/// ```
 Future<bool>  sameChannel({required ReceiverT other })=>RustLib.instance.api.tokioNetUnixPipeReceiverTSameChannel(that: this, other: other);


/// Returns the number of [`Sender`] handles.
 Future<BigInt>  senderStrongCount()=>RustLib.instance.api.tokioNetUnixPipeReceiverTSenderStrongCount(that: this, );


/// Returns the number of [`WeakSender`] handles.
 Future<BigInt>  senderWeakCount()=>RustLib.instance.api.tokioNetUnixPipeReceiverTSenderWeakCount(that: this, );


/// Attempts to return a pending value on this receiver without awaiting.
///
/// This is useful for a flavor of "optimistic check" before deciding to
/// await on a receiver.
///
/// Compared with [`recv`], this function has three failure cases instead of two
/// (one for closed, one for an empty buffer, one for a lagging receiver).
///
/// `Err(TryRecvError::Closed)` is returned when all `Sender` halves have
/// dropped, indicating that no further values can be sent on the channel.
///
/// If the [`Receiver`] handle falls behind, once the channel is full, newly
/// sent values will overwrite old values. At this point, a call to [`recv`]
/// will return with `Err(TryRecvError::Lagged)` and the [`Receiver`]'s
/// internal cursor is updated to point to the oldest value still held by
/// the channel. A subsequent call to [`try_recv`] will return this value
/// **unless** it has been since overwritten. If there are no values to
/// receive, `Err(TryRecvError::Empty)` is returned.
///
/// [`recv`]: crate::sync::broadcast::Receiver::recv
/// [`try_recv`]: crate::sync::broadcast::Receiver::try_recv
/// [`Receiver`]: crate::sync::broadcast::Receiver
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = broadcast::channel(16);
///
/// assert!(rx.try_recv().is_err());
///
/// tx.send(10).unwrap();
///
/// let value = rx.try_recv().unwrap();
/// assert_eq!(10, value);
/// # }
/// ```
 Future<T>  tryRecv()=>RustLib.instance.api.tokioNetUnixPipeReceiverTTryRecv(that: this, );


            }
            @sealed class RecvErrorImpl extends RustOpaque implements RecvError {
                // Not to be used by end users
                RecvErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RecvErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_RecvError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_RecvError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RecvErrorPtr,
                );

                
            }
            @sealed class RefTImpl extends RustOpaque implements RefT {
                // Not to be used by end users
                RefTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RefTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_RefT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_RefT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RefTPtr,
                );

                
            }
            @sealed class RepeatImpl extends RustOpaque implements Repeat {
                // Not to be used by end users
                RepeatImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RepeatImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Repeat,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Repeat,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RepeatPtr,
                );

                
            }
            @sealed class RestoreOnPendingImpl extends RustOpaque implements RestoreOnPending {
                // Not to be used by end users
                RestoreOnPendingImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RestoreOnPendingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_RestoreOnPending,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_RestoreOnPending,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RestoreOnPendingPtr,
                );

                /// Signals that the task that obtained this `RestoreOnPending` was able to make
/// progress. This prevents the task budget from being restored to the value
/// it had prior to obtaining this instance when it is dropped.
 Future<void>  madeProgress()=>RustLib.instance.api.tokioTaskCoopRestoreOnPendingMadeProgress(that: this, );


            }
            @sealed class ResultImpl extends RustOpaque implements Result {
                // Not to be used by end users
                ResultImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ResultImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Result,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Result,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ResultPtr,
                );

                
            }
            @sealed class ResultObjectImpl extends RustOpaque implements ResultObject {
                // Not to be used by end users
                ResultObjectImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ResultObjectImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ResultObject,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ResultObject,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ResultObjectPtr,
                );

                 AHashMapStringFacet get facets=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetFacets(that: this, );


 String get originalQuery=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetOriginalQuery(that: this, );


 String get query=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetQuery(that: this, );


 List<String> get queryTerms=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetQueryTerms(that: this, );


 BigInt get resultCount=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetResultCount(that: this, );


 BigInt get resultCountTotal=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetResultCountTotal(that: this, );


 List<Result> get results=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetResults(that: this, );


 List<String> get suggestions=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorGetSuggestions(that: this, );


  set facets(AHashMapStringFacet facets)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetFacets(that: this, facets: facets);


  set originalQuery(String originalQuery)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetOriginalQuery(that: this, originalQuery: originalQuery);


  set query(String query)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetQuery(that: this, query: query);


  set queryTerms(List<String> queryTerms)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetQueryTerms(that: this, queryTerms: queryTerms);


  set resultCount(BigInt resultCount)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetResultCount(that: this, resultCount: resultCount);


  set resultCountTotal(BigInt resultCountTotal)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetResultCountTotal(that: this, resultCountTotal: resultCountTotal);


  set results(List<Result> results)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetResults(that: this, results: results);


  set suggestions(List<String> suggestions)=>RustLib.instance.api.seekstormSearchResultObjectAutoAccessorSetSuggestions(that: this, suggestions: suggestions);


            }
            @sealed class ResultSortImpl extends RustOpaque implements ResultSort {
                // Not to be used by end users
                ResultSortImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ResultSortImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ResultSort,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ResultSort,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ResultSortPtr,
                );

                 FacetValue get base=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorGetBase(that: this, );


 String get field=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorGetField(that: this, );


 SortOrder get order=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorGetOrder(that: this, );


  set base(FacetValue base)=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorSetBase(that: this, base: base);


  set field(String field)=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorSetField(that: this, field: field);


  set order(SortOrder order)=>RustLib.instance.api.seekstormSearchResultSortAutoAccessorSetOrder(that: this, order: order);


            }
            @sealed class ReuniteErrorImpl extends RustOpaque implements ReuniteError {
                // Not to be used by end users
                ReuniteErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ReuniteErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ReuniteError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ReuniteError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ReuniteErrorPtr,
                );

                 OwnedReadHalf get field0=>RustLib.instance.api.tokioNetTcpReuniteErrorAutoAccessorGetField0(that: this, );


 OwnedWriteHalf get field1=>RustLib.instance.api.tokioNetTcpReuniteErrorAutoAccessorGetField1(that: this, );


  set field0(OwnedReadHalf field0)=>RustLib.instance.api.tokioNetTcpReuniteErrorAutoAccessorSetField0(that: this, field0: field0);


  set field1(OwnedWriteHalf field1)=>RustLib.instance.api.tokioNetTcpReuniteErrorAutoAccessorSetField1(that: this, field1: field1);


            }
            @sealed class RuntimeImpl extends RustOpaque implements Runtime {
                // Not to be used by end users
                RuntimeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RuntimeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Runtime,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Runtime,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RuntimePtr,
                );

                /// Enters the runtime context.
///
/// This allows you to construct types that must have an executor
/// available on creation such as [`Sleep`] or [`TcpStream`]. It will
/// also allow you to call methods such as [`tokio::spawn`].
///
/// [`Sleep`]: struct@crate::time::Sleep
/// [`TcpStream`]: struct@crate::net::TcpStream
/// [`tokio::spawn`]: fn@crate::spawn
///
/// # Example
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use tokio::runtime::Runtime;
/// use tokio::task::JoinHandle;
///
/// fn function_that_spawns(msg: String) -> JoinHandle<()> {
///     // Had we not used `rt.enter` below, this would panic.
///     tokio::spawn(async move {
///         println!("{}", msg);
///     })
/// }
///
/// fn main() {
///     let rt = Runtime::new().unwrap();
///
///     let s = "Hello World!".to_string();
///
///     // By entering the context, we tie `tokio::spawn` to this executor.
///     let _guard = rt.enter();
///     let handle = function_that_spawns(s);
///
///     // Wait for the task before we end the test.
///     rt.block_on(handle).unwrap();
/// }
/// # }
/// ```
 Future<EnterGuard>  enter()=>RustLib.instance.api.tokioRuntimeRuntimeEnter(that: this, );


/// Returns a handle to the runtime's spawner.
///
/// The returned handle can be used to spawn tasks that run on this runtime, and can
/// be cloned to allow moving the `Handle` to other threads.
///
/// Calling [`Handle::block_on`] on a handle to a `current_thread` runtime is error-prone.
/// Refer to the documentation of [`Handle::block_on`] for more.
///
/// # Examples
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use tokio::runtime::Runtime;
///
/// let rt = Runtime::new()
///     .unwrap();
///
/// let handle = rt.handle();
///
/// // Use the handle...
/// # }
/// ```
 Future<void>  handle()=>RustLib.instance.api.tokioRuntimeRuntimeHandle(that: this, );


/// Returns a view that lets you get information about how the runtime
/// is performing.
 Future<RuntimeMetrics>  metrics()=>RustLib.instance.api.tokioRuntimeRuntimeMetrics(that: this, );


/// Shuts down the runtime, without waiting for any spawned work to stop.
///
/// This can be useful if you want to drop a runtime from within another runtime.
/// Normally, dropping a runtime will block indefinitely for spawned blocking tasks
/// to complete, which would normally not be permitted within an asynchronous context.
/// By calling `shutdown_background()`, you can drop the runtime from such a context.
///
/// Note however, that because we do not wait for any blocking tasks to complete, this
/// may result in a resource leak (in that any blocking tasks are still running until they
/// return.
///
/// See the [struct level documentation](Runtime#shutdown) for more details.
///
/// This function is equivalent to calling `shutdown_timeout(Duration::from_nanos(0))`.
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use tokio::runtime::Runtime;
///
/// fn main() {
///    let runtime = Runtime::new().unwrap();
///
///    runtime.block_on(async move {
///        let inner_runtime = Runtime::new().unwrap();
///        // ...
///        inner_runtime.shutdown_background();
///    });
/// }
/// # }
/// ```
 Future<void>  shutdownBackground()=>RustLib.instance.api.tokioRuntimeRuntimeShutdownBackground(that: this, );


            }
            @sealed class RuntimeMetricsImpl extends RustOpaque implements RuntimeMetrics {
                // Not to be used by end users
                RuntimeMetricsImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                RuntimeMetricsImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_RuntimeMetrics,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_RuntimeMetrics,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_RuntimeMetricsPtr,
                );

                /// Returns the number of tasks currently scheduled in the runtime's
/// global queue.
///
/// Tasks that are spawned or notified from a non-runtime thread are
/// scheduled using the runtime's global queue. This metric returns the
/// **current** number of tasks pending in the global queue. As such, the
/// returned value may increase or decrease as new tasks are scheduled and
/// processed.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
///
/// let n = metrics.global_queue_depth();
/// println!("{} tasks currently pending in the runtime's global queue", n);
/// # }
/// ```
 Future<BigInt>  globalQueueDepth()=>RustLib.instance.api.tokioRuntimeRuntimeMetricsGlobalQueueDepth(that: this, );


/// Returns the current number of alive tasks in the runtime.
///
/// This counter increases when a task is spawned and decreases when a
/// task exits.
///
/// Note: When using the multi-threaded runtime this number may not
/// not have strong consistency i.e. no tasks may be running but the metric
/// reports otherwise.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
///
/// let n = metrics.num_alive_tasks();
/// println!("Runtime has {} alive tasks", n);
/// # }
/// ```
 Future<BigInt>  numAliveTasks()=>RustLib.instance.api.tokioRuntimeRuntimeMetricsNumAliveTasks(that: this, );


/// Returns the number of worker threads used by the runtime.
///
/// The number of workers is set by configuring `worker_threads` on
/// `runtime::Builder`. When using the `current_thread` runtime, the return
/// value is always `1`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
///
/// let n = metrics.num_workers();
/// println!("Runtime is using {} workers", n);
/// # }
/// ```
 Future<BigInt>  numWorkers()=>RustLib.instance.api.tokioRuntimeRuntimeMetricsNumWorkers(that: this, );


/// Returns the total number of times the given worker thread has parked.
///
/// The worker park count starts at zero when the runtime is created and
/// increases by one each time the worker parks the thread waiting for new
/// inbound events to process. This usually means the worker has processed
/// all pending work and is currently idle.
///
/// The counter is monotonically increasing. It is never decremented or
/// reset to zero.
///
/// # Arguments
///
/// `worker` is the index of the worker being queried. The given value must
/// be between 0 and `num_workers()`. The index uniquely identifies a single
/// worker and will continue to identify the worker throughout the lifetime
/// of the runtime instance.
///
/// # Panics
///
/// The method panics when `worker` represents an invalid worker, i.e. is
/// greater than or equal to `num_workers()`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
///
/// let n = metrics.worker_park_count(0);
/// println!("worker 0 parked {} times", n);
/// # }
/// ```
 Future<BigInt>  workerParkCount({required BigInt worker })=>RustLib.instance.api.tokioRuntimeRuntimeMetricsWorkerParkCount(that: this, worker: worker);


/// Returns the total number of times the given worker thread has parked
/// and unparked.
///
/// The worker park/unpark count starts at zero when the runtime is created
/// and increases by one each time the worker parks the thread waiting for
/// new inbound events to process. This usually means the worker has processed
/// all pending work and is currently idle. When new work becomes available,
/// the worker is unparked and the park/unpark count is again increased by one.
///
/// An odd count means that the worker is currently parked.
/// An even count means that the worker is currently active.
///
/// The counter is monotonically increasing. It is never decremented or
/// reset to zero.
///
/// # Arguments
///
/// `worker` is the index of the worker being queried. The given value must
/// be between 0 and `num_workers()`. The index uniquely identifies a single
/// worker and will continue to identify the worker throughout the lifetime
/// of the runtime instance.
///
/// # Panics
///
/// The method panics when `worker` represents an invalid worker, i.e. is
/// greater than or equal to `num_workers()`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
/// let n = metrics.worker_park_unpark_count(0);
///
/// println!("worker 0 parked and unparked {} times", n);
///
/// if n % 2 == 0 {
///     println!("worker 0 is active");
/// } else {
///     println!("worker 0 is parked");
/// }
/// # }
/// ```
 Future<BigInt>  workerParkUnparkCount({required BigInt worker })=>RustLib.instance.api.tokioRuntimeRuntimeMetricsWorkerParkUnparkCount(that: this, worker: worker);


/// Returns the amount of time the given worker thread has been busy.
///
/// The worker busy duration starts at zero when the runtime is created and
/// increases whenever the worker is spending time processing work. Using
/// this value can indicate the load of the given worker. If a lot of time
/// is spent busy, then the worker is under load and will check for inbound
/// events less often.
///
/// The timer is monotonically increasing. It is never decremented or reset
/// to zero.
///
/// # Arguments
///
/// `worker` is the index of the worker being queried. The given value must
/// be between 0 and `num_workers()`. The index uniquely identifies a single
/// worker and will continue to identify the worker throughout the lifetime
/// of the runtime instance.
///
/// # Panics
///
/// The method panics when `worker` represents an invalid worker, i.e. is
/// greater than or equal to `num_workers()`.
///
/// # Examples
///
/// ```
/// use tokio::runtime::Handle;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let metrics = Handle::current().metrics();
///
/// let n = metrics.worker_total_busy_duration(0);
/// println!("worker 0 was busy for a total of {:?}", n);
/// # }
/// ```
 Future<Duration>  workerTotalBusyDuration({required BigInt worker })=>RustLib.instance.api.tokioRuntimeRuntimeMetricsWorkerTotalBusyDuration(that: this, worker: worker);


            }
            @sealed class SchemaFieldImpl extends RustOpaque implements SchemaField {
                // Not to be used by end users
                SchemaFieldImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SchemaFieldImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SchemaField,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SchemaField,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SchemaFieldPtr,
                );

                 double get boost=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetBoost(that: this, );


 bool get completionSource=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetCompletionSource(that: this, );


 bool get dictionarySource=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetDictionarySource(that: this, );


 bool get facet=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetFacet(that: this, );


 String get field=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetField(that: this, );


 FieldType get fieldType=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetFieldType(that: this, );


 bool get indexed=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetIndexed(that: this, );


 bool get longest=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetLongest(that: this, );


 bool get stored=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorGetStored(that: this, );


  set boost(double boost)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetBoost(that: this, boost: boost);


  set completionSource(bool completionSource)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetCompletionSource(that: this, completionSource: completionSource);


  set dictionarySource(bool dictionarySource)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetDictionarySource(that: this, dictionarySource: dictionarySource);


  set facet(bool facet)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetFacet(that: this, facet: facet);


  set field(String field)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetField(that: this, field: field);


  set fieldType(FieldType fieldType)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetFieldType(that: this, fieldType: fieldType);


  set indexed(bool indexed)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetIndexed(that: this, indexed: indexed);


  set longest(bool longest)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetLongest(that: this, longest: longest);


  set stored(bool stored)=>RustLib.instance.api.seekstormIndexSchemaFieldAutoAccessorSetStored(that: this, stored: stored);


            }
            @sealed class SeekFromImpl extends RustOpaque implements SeekFrom {
                // Not to be used by end users
                SeekFromImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SeekFromImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SeekFrom,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SeekFrom,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SeekFromPtr,
                );

                
            }
            @sealed class SeekSelfImpl extends RustOpaque implements SeekSelf {
                // Not to be used by end users
                SeekSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SeekSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SeekSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SeekSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SeekSelfPtr,
                );

                
            }
            @sealed class SemaphoreImpl extends RustOpaque implements Semaphore {
                // Not to be used by end users
                SemaphoreImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SemaphoreImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Semaphore,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Semaphore,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SemaphorePtr,
                );

                /// Acquires a permit from the semaphore.
///
/// If the semaphore has been closed, this returns an [`AcquireError`].
/// Otherwise, this returns a [`SemaphorePermit`] representing the
/// acquired permit.
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute permits in the order they
/// were requested. Cancelling a call to `acquire` makes you lose your place
/// in the queue.
///
/// # Examples
///
/// ```
/// use tokio::sync::Semaphore;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let semaphore = Semaphore::new(2);
///
/// let permit_1 = semaphore.acquire().await.unwrap();
/// assert_eq!(semaphore.available_permits(), 1);
///
/// let permit_2 = semaphore.acquire().await.unwrap();
/// assert_eq!(semaphore.available_permits(), 0);
///
/// drop(permit_1);
/// assert_eq!(semaphore.available_permits(), 1);
/// # }
/// ```
///
/// [`AcquireError`]: crate::sync::AcquireError
/// [`SemaphorePermit`]: crate::sync::SemaphorePermit
 Future<SemaphorePermit>  acquire()=>RustLib.instance.api.tokioSyncSemaphoreAcquire(that: this, );


/// Acquires `n` permits from the semaphore.
///
/// If the semaphore has been closed, this returns an [`AcquireError`].
/// Otherwise, this returns a [`SemaphorePermit`] representing the
/// acquired permits.
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute permits in the order they
/// were requested. Cancelling a call to `acquire_many` makes you lose your
/// place in the queue.
///
/// # Examples
///
/// ```
/// use tokio::sync::Semaphore;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let semaphore = Semaphore::new(5);
///
/// let permit = semaphore.acquire_many(3).await.unwrap();
/// assert_eq!(semaphore.available_permits(), 2);
/// # }
/// ```
///
/// [`AcquireError`]: crate::sync::AcquireError
/// [`SemaphorePermit`]: crate::sync::SemaphorePermit
 Future<SemaphorePermit>  acquireMany({required int n })=>RustLib.instance.api.tokioSyncSemaphoreAcquireMany(that: this, n: n);


/// Acquires `n` permits from the semaphore.
///
/// The semaphore must be wrapped in an [`Arc`] to call this method.
/// If the semaphore has been closed, this returns an [`AcquireError`].
/// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
/// acquired permit.
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute permits in the order they
/// were requested. Cancelling a call to `acquire_many_owned` makes you lose
/// your place in the queue.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::Semaphore;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let semaphore = Arc::new(Semaphore::new(10));
/// let mut join_handles = Vec::new();
///
/// for _ in 0..5 {
///     let permit = semaphore.clone().acquire_many_owned(2).await.unwrap();
///     join_handles.push(tokio::spawn(async move {
///         // perform task...
///         // explicitly own `permit` in the task
///         drop(permit);
///     }));
/// }
///
/// for handle in join_handles {
///     handle.await.unwrap();
/// }
/// # }
/// ```
///
/// [`Arc`]: std::sync::Arc
/// [`AcquireError`]: crate::sync::AcquireError
/// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
 Future<OwnedSemaphorePermit>  acquireManyOwned({required int n })=>RustLib.instance.api.tokioSyncSemaphoreAcquireManyOwned(that: this, n: n);


/// Acquires a permit from the semaphore.
///
/// The semaphore must be wrapped in an [`Arc`] to call this method.
/// If the semaphore has been closed, this returns an [`AcquireError`].
/// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
/// acquired permit.
///
/// # Cancel safety
///
/// This method uses a queue to fairly distribute permits in the order they
/// were requested. Cancelling a call to `acquire_owned` makes you lose your
/// place in the queue.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::Semaphore;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let semaphore = Arc::new(Semaphore::new(3));
/// let mut join_handles = Vec::new();
///
/// for _ in 0..5 {
///     let permit = semaphore.clone().acquire_owned().await.unwrap();
///     join_handles.push(tokio::spawn(async move {
///         // perform task...
///         // explicitly own `permit` in the task
///         drop(permit);
///     }));
/// }
///
/// for handle in join_handles {
///     handle.await.unwrap();
/// }
/// # }
/// ```
///
/// [`Arc`]: std::sync::Arc
/// [`AcquireError`]: crate::sync::AcquireError
/// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
 Future<OwnedSemaphorePermit>  acquireOwned()=>RustLib.instance.api.tokioSyncSemaphoreAcquireOwned(that: this, );


/// Adds `n` new permits to the semaphore.
///
/// The maximum number of permits is [`Semaphore::MAX_PERMITS`], and this function will panic if the limit is exceeded.
 Future<void>  addPermits({required BigInt n })=>RustLib.instance.api.tokioSyncSemaphoreAddPermits(that: this, n: n);


/// Returns the current number of available permits.
 Future<BigInt>  availablePermits()=>RustLib.instance.api.tokioSyncSemaphoreAvailablePermits(that: this, );


/// Closes the semaphore.
///
/// This prevents the semaphore from issuing new permits and notifies all pending waiters.
///
/// # Examples
///
/// ```
/// use tokio::sync::Semaphore;
/// use std::sync::Arc;
/// use tokio::sync::TryAcquireError;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let semaphore = Arc::new(Semaphore::new(1));
/// let semaphore2 = semaphore.clone();
///
/// tokio::spawn(async move {
///     let permit = semaphore.acquire_many(2).await;
///     assert!(permit.is_err());
///     println!("waiter received error");
/// });
///
/// println!("closing semaphore");
/// semaphore2.close();
///
/// // Cannot obtain more permits
/// assert_eq!(semaphore2.try_acquire().err(), Some(TryAcquireError::Closed))
/// # }
/// ```
 Future<void>  close()=>RustLib.instance.api.tokioSyncSemaphoreClose(that: this, );


/// Decrease a semaphore's permits by a maximum of `n`.
///
/// If there are insufficient permits and it's not possible to reduce by `n`,
/// return the number of permits that were actually reduced.
 Future<BigInt>  forgetPermits({required BigInt n })=>RustLib.instance.api.tokioSyncSemaphoreForgetPermits(that: this, n: n);


/// Returns true if the semaphore is closed
 Future<bool>  isClosed()=>RustLib.instance.api.tokioSyncSemaphoreIsClosed(that: this, );


/// Tries to acquire a permit from the semaphore.
///
/// If the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
/// and a [`TryAcquireError::NoPermits`] if there are no permits left. Otherwise,
/// this returns a [`SemaphorePermit`] representing the acquired permits.
///
/// # Examples
///
/// ```
/// use tokio::sync::{Semaphore, TryAcquireError};
///
/// # fn main() {
/// let semaphore = Semaphore::new(2);
///
/// let permit_1 = semaphore.try_acquire().unwrap();
/// assert_eq!(semaphore.available_permits(), 1);
///
/// let permit_2 = semaphore.try_acquire().unwrap();
/// assert_eq!(semaphore.available_permits(), 0);
///
/// let permit_3 = semaphore.try_acquire();
/// assert_eq!(permit_3.err(), Some(TryAcquireError::NoPermits));
/// # }
/// ```
///
/// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
/// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
/// [`SemaphorePermit`]: crate::sync::SemaphorePermit
 Future<SemaphorePermit>  tryAcquire()=>RustLib.instance.api.tokioSyncSemaphoreTryAcquire(that: this, );


/// Tries to acquire `n` permits from the semaphore.
///
/// If the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
/// and a [`TryAcquireError::NoPermits`] if there are not enough permits left.
/// Otherwise, this returns a [`SemaphorePermit`] representing the acquired permits.
///
/// # Examples
///
/// ```
/// use tokio::sync::{Semaphore, TryAcquireError};
///
/// # fn main() {
/// let semaphore = Semaphore::new(4);
///
/// let permit_1 = semaphore.try_acquire_many(3).unwrap();
/// assert_eq!(semaphore.available_permits(), 1);
///
/// let permit_2 = semaphore.try_acquire_many(2);
/// assert_eq!(permit_2.err(), Some(TryAcquireError::NoPermits));
/// # }
/// ```
///
/// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
/// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
/// [`SemaphorePermit`]: crate::sync::SemaphorePermit
 Future<SemaphorePermit>  tryAcquireMany({required int n })=>RustLib.instance.api.tokioSyncSemaphoreTryAcquireMany(that: this, n: n);


/// Tries to acquire `n` permits from the semaphore.
///
/// The semaphore must be wrapped in an [`Arc`] to call this method. If
/// the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
/// and a [`TryAcquireError::NoPermits`] if there are no permits left.
/// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
/// acquired permit.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::{Semaphore, TryAcquireError};
///
/// # fn main() {
/// let semaphore = Arc::new(Semaphore::new(4));
///
/// let permit_1 = Arc::clone(&semaphore).try_acquire_many_owned(3).unwrap();
/// assert_eq!(semaphore.available_permits(), 1);
///
/// let permit_2 = semaphore.try_acquire_many_owned(2);
/// assert_eq!(permit_2.err(), Some(TryAcquireError::NoPermits));
/// # }
/// ```
///
/// [`Arc`]: std::sync::Arc
/// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
/// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
/// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
 Future<OwnedSemaphorePermit>  tryAcquireManyOwned({required int n })=>RustLib.instance.api.tokioSyncSemaphoreTryAcquireManyOwned(that: this, n: n);


/// Tries to acquire a permit from the semaphore.
///
/// The semaphore must be wrapped in an [`Arc`] to call this method. If
/// the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
/// and a [`TryAcquireError::NoPermits`] if there are no permits left.
/// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
/// acquired permit.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use tokio::sync::{Semaphore, TryAcquireError};
///
/// # fn main() {
/// let semaphore = Arc::new(Semaphore::new(2));
///
/// let permit_1 = Arc::clone(&semaphore).try_acquire_owned().unwrap();
/// assert_eq!(semaphore.available_permits(), 1);
///
/// let permit_2 = Arc::clone(&semaphore).try_acquire_owned().unwrap();
/// assert_eq!(semaphore.available_permits(), 0);
///
/// let permit_3 = semaphore.try_acquire_owned();
/// assert_eq!(permit_3.err(), Some(TryAcquireError::NoPermits));
/// # }
/// ```
///
/// [`Arc`]: std::sync::Arc
/// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
/// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
/// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
 Future<OwnedSemaphorePermit>  tryAcquireOwned()=>RustLib.instance.api.tokioSyncSemaphoreTryAcquireOwned(that: this, );


            }
            @sealed class SemaphorePermitImpl extends RustOpaque implements SemaphorePermit {
                // Not to be used by end users
                SemaphorePermitImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SemaphorePermitImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SemaphorePermit,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SemaphorePermit,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SemaphorePermitPtr,
                );

                
            }
            @sealed class SendErrorImpl extends RustOpaque implements SendError {
                // Not to be used by end users
                SendErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SendErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SendError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SendError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SendErrorPtr,
                );

                
            }
            @sealed class SendErrorTImpl extends RustOpaque implements SendErrorT {
                // Not to be used by end users
                SendErrorTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SendErrorTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SendErrorT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SendErrorT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SendErrorTPtr,
                );

                
            }
            @sealed class SendTimeoutErrorTImpl extends RustOpaque implements SendTimeoutErrorT {
                // Not to be used by end users
                SendTimeoutErrorTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SendTimeoutErrorTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SendTimeoutErrorT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SendTimeoutErrorT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SendTimeoutErrorTPtr,
                );

                
            }
            @sealed class SenderImpl extends RustOpaque implements Sender {
                // Not to be used by end users
                SenderImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SenderImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Sender,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Sender,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SenderPtr,
                );

                /// Converts the pipe into an [`OwnedFd`] in blocking mode.
///
/// This function will deregister this pipe end from the event loop, set
/// it in blocking mode and perform the conversion.
 Future<OwnedFd>  intoBlockingFd()=>RustLib.instance.api.tokioNetUnixPipeSenderIntoBlockingFd(that: this, );


/// Converts the pipe into an [`OwnedFd`] in nonblocking mode.
///
/// This function will deregister this pipe end from the event loop and
/// perform the conversion. The returned file descriptor will be in nonblocking
/// mode.
 Future<OwnedFd>  intoNonblockingFd()=>RustLib.instance.api.tokioNetUnixPipeSenderIntoNonblockingFd(that: this, );


/// Polls for write readiness.
///
/// If the pipe is not currently ready for writing, this method will
/// store a clone of the `Waker` from the provided `Context`. When the pipe
/// becomes ready for writing, `Waker::wake` will be called on the waker.
///
/// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup.
///
/// This function is intended for cases where creating and pinning a future
/// via [`writable`] is not feasible. Where possible, using [`writable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// [`writable`]: Self::writable
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the pipe is not ready for writing.
/// * `Poll::Ready(Ok(()))` if the pipe is ready for writing.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
 Future<PollResult>  pollWriteReady({required Context cx })=>RustLib.instance.api.tokioNetUnixPipeSenderPollWriteReady(that: this, cx: cx);


/// Waits for any of the requested ready states.
///
/// This function can be used instead of [`writable()`] to check the returned
/// ready set for [`Ready::WRITABLE`] and [`Ready::WRITE_CLOSED`] events.
///
/// The function may complete without the pipe being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// [`writable()`]: Self::writable
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetUnixPipeSenderReady(that: this, interest: interest);


/// Tries to write a buffer to the pipe, returning how many bytes were
/// written.
///
/// The function will attempt to write the entire contents of `buf`, but
/// only part of the buffer may be written. If the length of `buf` is not
/// greater than `PIPE_BUF` (an OS constant, 4096 under Linux), then the
/// write is guaranteed to be atomic, i.e. either the entire content of
/// `buf` will be written or this method will fail with `WouldBlock`. There
/// is no such guarantee if `buf` is larger than `PIPE_BUF`.
///
/// This function is usually paired with [`writable`].
///
/// [`writable`]: Self::writable
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the pipe is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a writing end of a fifo
///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
///
///     loop {
///         // Wait for the pipe to be writable
///         tx.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match tx.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWrite({required List<int> buf })=>RustLib.instance.api.tokioNetUnixPipeSenderTryWrite(that: this, buf: buf);


/// Tries to write several buffers to the pipe, returning how many bytes
/// were written.
///
/// Data is written from each buffer in order, with the final buffer read
/// from possible being only partially consumed. This method behaves
/// equivalently to a single call to [`try_write()`] with concatenated
/// buffers.
///
/// If the total length of buffers is not greater than `PIPE_BUF` (an OS
/// constant, 4096 under Linux), then the write is guaranteed to be atomic,
/// i.e. either the entire contents of buffers will be written or this
/// method will fail with `WouldBlock`. There is no such guarantee if the
/// total length of buffers is greater than `PIPE_BUF`.
///
/// This function is usually paired with [`writable`].
///
/// [`try_write()`]: Self::try_write()
/// [`writable`]: Self::writable
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the pipe is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a writing end of a fifo
///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
///
///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
///
///     loop {
///         // Wait for the pipe to be writable
///         tx.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match tx.try_write_vectored(&bufs) {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWriteVectored({required List<IoSlice> buf })=>RustLib.instance.api.tokioNetUnixPipeSenderTryWriteVectored(that: this, buf: buf);


/// Waits for the pipe to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
/// paired with [`try_write()`].
///
/// [`try_write()`]: Self::try_write
///
/// # Examples
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Open a writing end of a fifo
///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
///
///     loop {
///         // Wait for the pipe to be writable
///         tx.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match tx.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  writable()=>RustLib.instance.api.tokioNetUnixPipeSenderWritable(that: this, );


            }
            @sealed class SenderTImpl extends RustOpaque implements SenderT {
                // Not to be used by end users
                SenderTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SenderTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SenderT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SenderT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SenderTPtr,
                );

                /// Blocking send to call outside of asynchronous contexts.
///
/// This method is intended for use cases where you are sending from
/// synchronous code to asynchronous code, and will work even if the
/// receiver is not using [`blocking_recv`] to receive the message.
///
/// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv
///
/// # Panics
///
/// This function panics if called within an asynchronous execution
/// context.
///
/// # Examples
///
/// ```
/// # #[cfg(not(target_family = "wasm"))]
/// # {
/// use std::thread;
/// use tokio::runtime::Runtime;
/// use tokio::sync::mpsc;
///
/// fn main() {
///     let (tx, mut rx) = mpsc::channel::<u8>(1);
///
///     let sync_code = thread::spawn(move || {
///         tx.blocking_send(10).unwrap();
///     });
///
///     Runtime::new().unwrap().block_on(async move {
///         assert_eq!(Some(10), rx.recv().await);
///     });
///     sync_code.join().unwrap()
/// }
/// # }
/// ```
 Future<void>  blockingSend({required T value })=>RustLib.instance.api.tokioNetUnixPipeSenderTBlockingSend(that: this, value: value);


/// Returns a reference to the most recently sent value
///
/// Outstanding borrows hold a read lock on the inner value. This means that
/// long-lived borrows could cause the producer half to block. It is recommended
/// to keep the borrow as short-lived as possible. Additionally, if you are
/// running in an environment that allows `!Send` futures, you must ensure that
/// the returned `Ref` type is never held alive across an `.await` point,
/// otherwise, it can lead to a deadlock.
///
/// # Examples
///
/// ```
/// use tokio::sync::watch;
///
/// let (tx, _) = watch::channel("hello");
/// assert_eq!(*tx.borrow(), "hello");
/// ```
 Future<RefT>  borrow()=>RustLib.instance.api.tokioNetUnixPipeSenderTBorrow(that: this, );


/// Returns the current capacity of the channel.
///
/// The capacity goes down when sending a value by calling [`send`] or by reserving capacity
/// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].
/// This is distinct from [`max_capacity`], which always returns buffer capacity initially
/// specified when calling [`channel`]
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel::<()>(5);
///
/// assert_eq!(tx.capacity(), 5);
///
/// // Making a reservation drops the capacity by one.
/// let permit = tx.reserve().await.unwrap();
/// assert_eq!(tx.capacity(), 4);
///
/// // Sending and receiving a value increases the capacity by one.
/// permit.send(());
/// rx.recv().await.unwrap();
/// assert_eq!(tx.capacity(), 5);
/// # }
/// ```
///
/// [`send`]: Sender::send
/// [`reserve`]: Sender::reserve
/// [`channel`]: channel
/// [`max_capacity`]: Sender::max_capacity
 Future<BigInt>  capacity()=>RustLib.instance.api.tokioNetUnixPipeSenderTCapacity(that: this, );


/// A future which completes when the number of [Receiver]s subscribed to this `Sender` reaches
/// zero.
///
/// # Examples
///
/// ```
/// use futures::FutureExt;
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel::<u32>(16);
/// let mut rx2 = tx.subscribe();
///
/// let _ = tx.send(10);
///
/// assert_eq!(rx1.recv().await.unwrap(), 10);
/// drop(rx1);
/// assert!(tx.closed().now_or_never().is_none());
///
/// assert_eq!(rx2.recv().await.unwrap(), 10);
/// drop(rx2);
/// assert!(tx.closed().now_or_never().is_some());
/// # }
/// ```
 Future<void>  closed()=>RustLib.instance.api.tokioNetUnixPipeSenderTClosed(that: this, );


/// Converts the `Sender` to a [`WeakSender`] that does not count
/// towards RAII semantics, i.e. if all `Sender` instances of the
/// channel were dropped and only `WeakSender` instances remain,
/// the channel is closed.
 Future<WeakSenderT>  downgrade()=>RustLib.instance.api.tokioNetUnixPipeSenderTDowngrade(that: this, );


/// Checks if the channel has been closed. This happens when the
/// [`Receiver`] is dropped, or when the [`Receiver::close`] method is
/// called.
///
/// [`Receiver`]: crate::sync::mpsc::Receiver
/// [`Receiver::close`]: crate::sync::mpsc::Receiver::close
///
/// ```
/// let (tx, rx) = tokio::sync::mpsc::channel::<()>(42);
/// assert!(!tx.is_closed());
///
/// let tx2 = tx.clone();
/// assert!(!tx2.is_closed());
///
/// drop(rx);
/// assert!(tx.is_closed());
/// assert!(tx2.is_closed());
/// ```
 Future<bool>  isClosed()=>RustLib.instance.api.tokioNetUnixPipeSenderTIsClosed(that: this, );


/// Returns true if there are no queued values.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
/// let mut rx2 = tx.subscribe();
///
/// assert!(tx.is_empty());
///
/// tx.send(10).unwrap();
///
/// assert!(!tx.is_empty());
///
/// rx1.recv().await.unwrap();
///
/// // The queue is still not empty since rx2 hasn't seen the value.
/// assert!(!tx.is_empty());
///
/// rx2.recv().await.unwrap();
///
/// assert!(tx.is_empty());
/// # }
/// ```
 Future<bool>  isEmpty()=>RustLib.instance.api.tokioNetUnixPipeSenderTIsEmpty(that: this, );


/// Returns the number of queued values.
///
/// A value is queued until it has either been seen by all receivers that were alive at the time
/// it was sent, or has been evicted from the queue by subsequent sends that exceeded the
/// queue's capacity.
///
/// # Note
///
/// In contrast to [`Receiver::len`], this method only reports queued values and not values that
/// have been evicted from the queue before being seen by all receivers.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
/// let mut rx2 = tx.subscribe();
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
/// tx.send(30).unwrap();
///
/// assert_eq!(tx.len(), 3);
///
/// rx1.recv().await.unwrap();
///
/// // The len is still 3 since rx2 hasn't seen the first value yet.
/// assert_eq!(tx.len(), 3);
///
/// rx2.recv().await.unwrap();
///
/// assert_eq!(tx.len(), 2);
/// # }
/// ```
 Future<BigInt>  len()=>RustLib.instance.api.tokioNetUnixPipeSenderTLen(that: this, );


/// Returns the maximum buffer capacity of the channel.
///
/// The maximum capacity is the buffer capacity initially specified when calling
/// [`channel`]. This is distinct from [`capacity`], which returns the *current*
/// available buffer capacity: as messages are sent and received, the
/// value returned by [`capacity`] will go up or down, whereas the value
/// returned by [`max_capacity`] will remain constant.
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, _rx) = mpsc::channel::<()>(5);
///
/// // both max capacity and capacity are the same at first
/// assert_eq!(tx.max_capacity(), 5);
/// assert_eq!(tx.capacity(), 5);
///
/// // Making a reservation doesn't change the max capacity.
/// let permit = tx.reserve().await.unwrap();
/// assert_eq!(tx.max_capacity(), 5);
/// // but drops the capacity by one
/// assert_eq!(tx.capacity(), 4);
/// # }
/// ```
///
/// [`channel`]: channel
/// [`max_capacity`]: Sender::max_capacity
/// [`capacity`]: Sender::capacity
 Future<BigInt>  maxCapacity()=>RustLib.instance.api.tokioNetUnixPipeSenderTMaxCapacity(that: this, );


/// Checks whether the `oneshot` channel has been closed, and if not, schedules the
/// `Waker` in the provided `Context` to receive a notification when the channel is
/// closed.
///
/// A [`Receiver`] is closed by either calling [`close`] explicitly, or when the
/// [`Receiver`] value is dropped.
///
/// Note that on multiple calls to poll, only the `Waker` from the `Context` passed
/// to the most recent call will be scheduled to receive a wakeup.
///
/// [`Receiver`]: struct@crate::sync::oneshot::Receiver
/// [`close`]: fn@crate::sync::oneshot::Receiver::close
///
/// # Return value
///
/// This function returns:
///
///  * `Poll::Pending` if the channel is still open.
///  * `Poll::Ready(())` if the channel is closed.
///
/// # Examples
///
/// ```
/// use tokio::sync::oneshot;
///
/// use std::future::poll_fn;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (mut tx, mut rx) = oneshot::channel::<()>();
///
/// tokio::spawn(async move {
///     rx.close();
/// });
///
/// poll_fn(|cx| tx.poll_closed(cx)).await;
///
/// println!("the receiver dropped");
/// # }
/// ```
 Future<Poll>  pollClosed({required Context cx })=>RustLib.instance.api.tokioNetUnixPipeSenderTPollClosed(that: this, cx: cx);


/// Returns the number of active receivers.
///
/// An active receiver is a [`Receiver`] handle returned from [`channel`] or
/// [`subscribe`]. These are the handles that will receive values sent on
/// this [`Sender`].
///
/// # Note
///
/// It is not guaranteed that a sent message will reach this number of
/// receivers. Active receivers may never call [`recv`] again before
/// dropping.
///
/// [`recv`]: crate::sync::broadcast::Receiver::recv
/// [`Receiver`]: crate::sync::broadcast::Receiver
/// [`Sender`]: crate::sync::broadcast::Sender
/// [`subscribe`]: crate::sync::broadcast::Sender::subscribe
/// [`channel`]: crate::sync::broadcast::channel
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, _rx1) = broadcast::channel(16);
///
/// assert_eq!(1, tx.receiver_count());
///
/// let mut _rx2 = tx.subscribe();
///
/// assert_eq!(2, tx.receiver_count());
///
/// tx.send(10).unwrap();
/// # }
/// ```
 Future<BigInt>  receiverCount()=>RustLib.instance.api.tokioNetUnixPipeSenderTReceiverCount(that: this, );


/// Waits for channel capacity. Once capacity to send one message is
/// available, it is reserved for the caller.
///
/// If the channel is full, the function waits for the number of unreceived
/// messages to become less than the channel capacity. Capacity to send one
/// message is reserved for the caller. A [`Permit`] is returned to track
/// the reserved capacity. The [`send`] function on [`Permit`] consumes the
/// reserved capacity.
///
/// Dropping [`Permit`] without sending a message releases the capacity back
/// to the channel.
///
/// [`Permit`]: Permit
/// [`send`]: Permit::send
///
/// # Cancel safety
///
/// This channel uses a queue to ensure that calls to `send` and `reserve`
/// complete in the order they were requested.  Cancelling a call to
/// `reserve` makes you lose your place in the queue.
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// // Reserve capacity
/// let permit = tx.reserve().await.unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Sending on the permit succeeds
/// permit.send(456);
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
/// # }
/// ```
 Future<PermitT>  reserve()=>RustLib.instance.api.tokioNetUnixPipeSenderTReserve(that: this, );


/// Waits for channel capacity. Once capacity to send `n` messages is
/// available, it is reserved for the caller.
///
/// If the channel is full or if there are fewer than `n` permits available, the function waits
/// for the number of unreceived messages to become `n` less than the channel capacity.
/// Capacity to send `n` message is then reserved for the caller.
///
/// A [`PermitIterator`] is returned to track the reserved capacity.
/// You can call this [`Iterator`] until it is exhausted to
/// get a [`Permit`] and then call [`Permit::send`]. This function is similar to
/// [`try_reserve_many`] except it waits for the slots to become available.
///
/// If the channel is closed, the function returns a [`SendError`].
///
/// Dropping [`PermitIterator`] without consuming it entirely releases the remaining
/// permits back to the channel.
///
/// [`PermitIterator`]: PermitIterator
/// [`Permit`]: Permit
/// [`send`]: Permit::send
/// [`try_reserve_many`]: Sender::try_reserve_many
///
/// # Cancel safety
///
/// This channel uses a queue to ensure that calls to `send` and `reserve_many`
/// complete in the order they were requested. Cancelling a call to
/// `reserve_many` makes you lose your place in the queue.
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(2);
///
/// // Reserve capacity
/// let mut permit = tx.reserve_many(2).await.unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Sending with the permit iterator succeeds
/// permit.next().unwrap().send(456);
/// permit.next().unwrap().send(457);
///
/// // The iterator should now be exhausted
/// assert!(permit.next().is_none());
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
/// assert_eq!(rx.recv().await.unwrap(), 457);
/// # }
/// ```
 Future<PermitIteratorT>  reserveMany({required BigInt n })=>RustLib.instance.api.tokioNetUnixPipeSenderTReserveMany(that: this, n: n);


/// Waits for channel capacity, moving the `Sender` and returning an owned
/// permit. Once capacity to send one message is available, it is reserved
/// for the caller.
///
/// This moves the sender _by value_, and returns an owned permit that can
/// be used to send a message into the channel. Unlike [`Sender::reserve`],
/// this method may be used in cases where the permit must be valid for the
/// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is
/// essentially a reference count increment, comparable to [`Arc::clone`]),
/// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be
/// moved, it can be cloned prior to calling `reserve_owned`.
///
/// If the channel is full, the function waits for the number of unreceived
/// messages to become less than the channel capacity. Capacity to send one
/// message is reserved for the caller. An [`OwnedPermit`] is returned to
/// track the reserved capacity. The [`send`] function on [`OwnedPermit`]
/// consumes the reserved capacity.
///
/// Dropping the [`OwnedPermit`] without sending a message releases the
/// capacity back to the channel.
///
/// # Cancel safety
///
/// This channel uses a queue to ensure that calls to `send` and `reserve`
/// complete in the order they were requested.  Cancelling a call to
/// `reserve_owned` makes you lose your place in the queue.
///
/// # Examples
/// Sending a message using an [`OwnedPermit`]:
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// // Reserve capacity, moving the sender.
/// let permit = tx.reserve_owned().await.unwrap();
///
/// // Send a message, consuming the permit and returning
/// // the moved sender.
/// let tx = permit.send(123);
///
/// // The value sent on the permit is received.
/// assert_eq!(rx.recv().await.unwrap(), 123);
///
/// // The sender can now be used again.
/// tx.send(456).await.unwrap();
/// # }
/// ```
///
/// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved
/// by value, it can be inexpensively cloned before calling `reserve_owned`:
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// // Clone the sender and reserve capacity.
/// let permit = tx.clone().reserve_owned().await.unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Sending on the permit succeeds.
/// permit.send(456);
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
/// # }
/// ```
///
/// [`Sender::reserve`]: Sender::reserve
/// [`OwnedPermit`]: OwnedPermit
/// [`send`]: OwnedPermit::send
/// [`Arc::clone`]: std::sync::Arc::clone
 Future<OwnedPermitT>  reserveOwned()=>RustLib.instance.api.tokioNetUnixPipeSenderTReserveOwned(that: this, );


/// Returns `true` if senders belong to the same channel.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, _rx) = broadcast::channel::<()>(16);
/// let tx2 = tx.clone();
///
/// assert!(tx.same_channel(&tx2));
///
/// let (tx3, _rx3) = broadcast::channel::<()>(16);
///
/// assert!(!tx3.same_channel(&tx2));
/// # }
/// ```
 Future<bool>  sameChannel({required SenderT other })=>RustLib.instance.api.tokioNetUnixPipeSenderTSameChannel(that: this, other: other);


/// Attempts to send a value to all active [`Receiver`] handles, returning
/// it back if it could not be sent.
///
/// A successful send occurs when there is at least one active [`Receiver`]
/// handle. An unsuccessful send would be one where all associated
/// [`Receiver`] handles have already been dropped.
///
/// # Return
///
/// On success, the number of subscribed [`Receiver`] handles is returned.
/// This does not mean that this number of receivers will see the message as
/// a receiver may drop or lag ([see lagging](self#lagging)) before receiving
/// the message.
///
/// # Note
///
/// A return value of `Ok` **does not** mean that the sent value will be
/// observed by all or any of the active [`Receiver`] handles. [`Receiver`]
/// handles may be dropped before receiving the sent message.
///
/// A return value of `Err` **does not** mean that future calls to `send`
/// will fail. New [`Receiver`] handles may be created by calling
/// [`subscribe`].
///
/// [`Receiver`]: crate::sync::broadcast::Receiver
/// [`subscribe`]: crate::sync::broadcast::Sender::subscribe
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx1) = broadcast::channel(16);
/// let mut rx2 = tx.subscribe();
///
/// tokio::spawn(async move {
///     assert_eq!(rx1.recv().await.unwrap(), 10);
///     assert_eq!(rx1.recv().await.unwrap(), 20);
/// });
///
/// tokio::spawn(async move {
///     assert_eq!(rx2.recv().await.unwrap(), 10);
///     assert_eq!(rx2.recv().await.unwrap(), 20);
/// });
///
/// tx.send(10).unwrap();
/// tx.send(20).unwrap();
/// # }
/// ```
 Future<BigInt>  send({required T value })=>RustLib.instance.api.tokioNetUnixPipeSenderTSend(that: this, value: value);


/// Sends a new value via the channel, notifying all receivers and returning
/// the previous value in the channel.
///
/// This can be useful for reusing the buffers inside a watched value.
/// Additionally, this method permits sending values even when there are no
/// receivers.
///
/// # Examples
///
/// ```
/// use tokio::sync::watch;
///
/// let (tx, _rx) = watch::channel(1);
/// assert_eq!(tx.send_replace(2), 1);
/// assert_eq!(tx.send_replace(3), 2);
/// ```
 Future<T>  sendReplace({required T value })=>RustLib.instance.api.tokioNetUnixPipeSenderTSendReplace(that: this, value: value);


/// Sends a value, waiting until there is capacity, but only for a limited time.
///
/// Shares the same success and error conditions as [`send`], adding one more
/// condition for an unsuccessful send, which is when the provided timeout has
/// elapsed, and there is no capacity available.
///
/// [`send`]: Sender::send
///
/// # Errors
///
/// If the receive half of the channel is closed, either due to [`close`]
/// being called or the [`Receiver`] having been dropped,
/// the function returns an error. The error includes the value passed to `send`.
///
/// [`close`]: Receiver::close
/// [`Receiver`]: Receiver
///
/// # Panics
///
/// This function panics if it is called outside the context of a Tokio
/// runtime [with time enabled](crate::runtime::Builder::enable_time).
///
/// # Examples
///
/// In the following example, each call to `send_timeout` will block until the
/// previously sent value was received, unless the timeout has elapsed.
///
/// ```rust
/// use tokio::sync::mpsc;
/// use tokio::time::{sleep, Duration};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// tokio::spawn(async move {
///     for i in 0..10 {
///         if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {
///             println!("send error: #{:?}", e);
///             return;
///         }
///     }
/// });
///
/// while let Some(i) = rx.recv().await {
///     println!("got = {}", i);
///     sleep(Duration::from_millis(200)).await;
/// }
/// # }
/// ```
 Future<void>  sendTimeout({required T value , required Duration timeout })=>RustLib.instance.api.tokioNetUnixPipeSenderTSendTimeout(that: this, value: value, timeout: timeout);


/// Returns the number of senders that currently exist.
///
/// # Examples
///
/// ```
/// use tokio::sync::watch;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx1, rx) = watch::channel("hello");
///
/// assert_eq!(1, tx1.sender_count());
///
/// let tx2 = tx1.clone();
///
/// assert_eq!(2, tx1.sender_count());
/// assert_eq!(2, tx2.sender_count());
/// # }
/// ```
 Future<BigInt>  senderCount()=>RustLib.instance.api.tokioNetUnixPipeSenderTSenderCount(that: this, );


/// Returns the number of [`Sender`] handles.
 Future<BigInt>  strongCount()=>RustLib.instance.api.tokioNetUnixPipeSenderTStrongCount(that: this, );


/// Creates a new [`Receiver`] handle that will receive values sent **after**
/// this call to `subscribe`.
///
/// # Examples
///
/// ```
/// use tokio::sync::broadcast;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, _rx) = broadcast::channel(16);
///
/// // Will not be seen
/// tx.send(10).unwrap();
///
/// let mut rx = tx.subscribe();
///
/// tx.send(20).unwrap();
///
/// let value = rx.recv().await.unwrap();
/// assert_eq!(20, value);
/// # }
/// ```
 Future<ReceiverT>  subscribe()=>RustLib.instance.api.tokioNetUnixPipeSenderTSubscribe(that: this, );


/// Tries to acquire a slot in the channel without waiting for the slot to become
/// available.
///
/// If the channel is full this function will return [`TrySendError`], otherwise
/// if there is a slot available it will return a [`Permit`] that will then allow you
/// to [`send`] on the channel with a guaranteed slot. This function is similar to
/// [`reserve`] except it does not await for the slot to become available.
///
/// Dropping [`Permit`] without sending a message releases the capacity back
/// to the channel.
///
/// [`Permit`]: Permit
/// [`send`]: Permit::send
/// [`reserve`]: Sender::reserve
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// // Reserve capacity
/// let permit = tx.try_reserve().unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Trying to reserve an additional slot on the `tx` will
/// // fail because there is no capacity.
/// assert!(tx.try_reserve().is_err());
///
/// // Sending on the permit succeeds
/// permit.send(456);
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
///
/// # }
/// ```
 Future<PermitT>  tryReserve()=>RustLib.instance.api.tokioNetUnixPipeSenderTTryReserve(that: this, );


/// Tries to acquire `n` slots in the channel without waiting for the slot to become
/// available.
///
/// A [`PermitIterator`] is returned to track the reserved capacity.
/// You can call this [`Iterator`] until it is exhausted to
/// get a [`Permit`] and then call [`Permit::send`]. This function is similar to
/// [`reserve_many`] except it does not await for the slots to become available.
///
/// If there are fewer than `n` permits available on the channel, then
/// this function will return a [`TrySendError::Full`]. If the channel is closed
/// this function will return a [`TrySendError::Closed`].
///
/// Dropping [`PermitIterator`] without consuming it entirely releases the remaining
/// permits back to the channel.
///
/// [`PermitIterator`]: PermitIterator
/// [`send`]: Permit::send
/// [`reserve_many`]: Sender::reserve_many
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(2);
///
/// // Reserve capacity
/// let mut permit = tx.try_reserve_many(2).unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Trying to reserve an additional slot on the `tx` will
/// // fail because there is no capacity.
/// assert!(tx.try_reserve().is_err());
///
/// // Sending with the permit iterator succeeds
/// permit.next().unwrap().send(456);
/// permit.next().unwrap().send(457);
///
/// // The iterator should now be exhausted
/// assert!(permit.next().is_none());
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
/// assert_eq!(rx.recv().await.unwrap(), 457);
///
/// // Trying to call try_reserve_many with 0 will return an empty iterator
/// let mut permit = tx.try_reserve_many(0).unwrap();
/// assert!(permit.next().is_none());
///
/// // Trying to call try_reserve_many with a number greater than the channel
/// // capacity will return an error
/// let permit = tx.try_reserve_many(3);
/// assert!(permit.is_err());
///
/// // Trying to call try_reserve_many on a closed channel will return an error
/// drop(rx);
/// let permit = tx.try_reserve_many(1);
/// assert!(permit.is_err());
///
/// let permit = tx.try_reserve_many(0);
/// assert!(permit.is_err());
/// # }
/// ```
 Future<PermitIteratorT>  tryReserveMany({required BigInt n })=>RustLib.instance.api.tokioNetUnixPipeSenderTTryReserveMany(that: this, n: n);


/// Tries to acquire a slot in the channel without waiting for the slot to become
/// available, returning an owned permit.
///
/// This moves the sender _by value_, and returns an owned permit that can
/// be used to send a message into the channel. Unlike [`Sender::try_reserve`],
/// this method may be used in cases where the permit must be valid for the
/// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is
/// essentially a reference count increment, comparable to [`Arc::clone`]),
/// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be
/// moved, it can be cloned prior to calling `try_reserve_owned`.
///
/// If the channel is full this function will return a [`TrySendError`].
/// Since the sender is taken by value, the `TrySendError` returned in this
/// case contains the sender, so that it may be used again. Otherwise, if
/// there is a slot available, this method will return an [`OwnedPermit`]
/// that can then be used to [`send`] on the channel with a guaranteed slot.
/// This function is similar to  [`reserve_owned`] except it does not await
/// for the slot to become available.
///
/// Dropping the [`OwnedPermit`] without sending a message releases the capacity back
/// to the channel.
///
/// [`OwnedPermit`]: OwnedPermit
/// [`send`]: OwnedPermit::send
/// [`reserve_owned`]: Sender::reserve_owned
/// [`Arc::clone`]: std::sync::Arc::clone
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let (tx, mut rx) = mpsc::channel(1);
///
/// // Reserve capacity
/// let permit = tx.clone().try_reserve_owned().unwrap();
///
/// // Trying to send directly on the `tx` will fail due to no
/// // available capacity.
/// assert!(tx.try_send(123).is_err());
///
/// // Trying to reserve an additional slot on the `tx` will
/// // fail because there is no capacity.
/// assert!(tx.try_reserve().is_err());
///
/// // Sending on the permit succeeds
/// permit.send(456);
///
/// // The value sent on the permit is received
/// assert_eq!(rx.recv().await.unwrap(), 456);
///
/// # }
/// ```
 Future<OwnedPermitT>  tryReserveOwned()=>RustLib.instance.api.tokioNetUnixPipeSenderTTryReserveOwned(that: this, );


/// Attempts to immediately send a message on this `Sender`.
///
/// This method differs from [`send`] by returning immediately if the channel's
/// buffer is full or no receiver is waiting to acquire some data. Compared
/// with [`send`], this function has two failure cases instead of one (one for
/// disconnection, one for a full buffer).
///
/// # Errors
///
/// If the channel capacity has been reached, i.e., the channel has `n`
/// buffered values where `n` is the argument passed to [`channel`], then an
/// error is returned.
///
/// If the receive half of the channel is closed, either due to [`close`]
/// being called or the [`Receiver`] handle dropping, the function returns
/// an error. The error includes the value passed to `send`.
///
/// [`send`]: Sender::send
/// [`channel`]: channel
/// [`close`]: Receiver::close
///
/// # Examples
///
/// ```
/// use tokio::sync::mpsc;
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// // Create a channel with buffer size 1
/// let (tx1, mut rx) = mpsc::channel(1);
/// let tx2 = tx1.clone();
///
/// tokio::spawn(async move {
///     tx1.send(1).await.unwrap();
///     tx1.send(2).await.unwrap();
///     // task waits until the receiver receives a value.
/// });
///
/// tokio::spawn(async move {
///     // This will return an error and send
///     // no message if the buffer is full
///     let _ = tx2.try_send(3);
/// });
///
/// let mut msg;
/// msg = rx.recv().await.unwrap();
/// println!("message {} received", msg);
///
/// msg = rx.recv().await.unwrap();
/// println!("message {} received", msg);
///
/// // Third message may have never been sent
/// match rx.recv().await {
///     Some(msg) => println!("message {} received", msg),
///     None => println!("the third message was never sent"),
/// }
/// # }
/// ```
 Future<void>  trySend({required T message })=>RustLib.instance.api.tokioNetUnixPipeSenderTTrySend(that: this, message: message);


/// Returns the number of [`WeakSender`] handles.
 Future<BigInt>  weakCount()=>RustLib.instance.api.tokioNetUnixPipeSenderTWeakCount(that: this, );


            }
            @sealed class ShutdownImpl extends RustOpaque implements Shutdown {
                // Not to be used by end users
                ShutdownImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ShutdownImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Shutdown,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Shutdown,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ShutdownPtr,
                );

                
            }
            @sealed class ShutdownSelfImpl extends RustOpaque implements ShutdownSelf {
                // Not to be used by end users
                ShutdownSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ShutdownSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ShutdownSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ShutdownSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ShutdownSelfPtr,
                );

                
            }
            @sealed class SignalImpl extends RustOpaque implements Signal {
                // Not to be used by end users
                SignalImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SignalImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Signal,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Signal,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SignalPtr,
                );

                 Future<PollOption>  pollRecv({required Context cx })=>RustLib.instance.api.tokioSignalUnixSignalPollRecv(that: this, cx: cx);


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by this stream.
///
/// # Cancel safety
///
/// This method is cancel safe. If you use it as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that no signal is lost.
///
/// # Examples
///
/// Wait for `SIGHUP`
///
/// ```rust,no_run
/// use tokio::signal::unix::{signal, SignalKind};
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // An infinite stream of hangup signals.
///     let mut stream = signal(SignalKind::hangup())?;
///
///     // Print whenever a HUP signal is received
///     loop {
///         stream.recv().await;
///         println!("got signal HUP");
///     }
/// }
/// ```
 Future<void?>  recv()=>RustLib.instance.api.tokioSignalUnixSignalRecv(that: this, );


            }
            @sealed class SignalKindImpl extends RustOpaque implements SignalKind {
                // Not to be used by end users
                SignalKindImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SignalKindImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SignalKind,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SignalKind,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SignalKindPtr,
                );

                /// Get the signal's numeric value.
///
/// ```rust
/// # use tokio::signal::unix::SignalKind;
/// let kind = SignalKind::interrupt();
/// assert_eq!(kind.as_raw_value(), libc::SIGINT);
/// ```
 Future<CInt>  asRawValue()=>RustLib.instance.api.tokioSignalUnixSignalKindAsRawValue(that: this, );


            }
            @sealed class SimplexStreamImpl extends RustOpaque implements SimplexStream {
                // Not to be used by end users
                SimplexStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SimplexStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SimplexStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SimplexStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SimplexStreamPtr,
                );

                
            }
            @sealed class SinkImpl extends RustOpaque implements Sink {
                // Not to be used by end users
                SinkImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SinkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Sink,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Sink,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SinkPtr,
                );

                
            }
            @sealed class SleepImpl extends RustOpaque implements Sleep {
                // Not to be used by end users
                SleepImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SleepImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Sleep,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Sleep,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SleepPtr,
                );

                /// Returns the instant at which the future will complete.
 Future<Instant>  deadline()=>RustLib.instance.api.tokioTimeSleepDeadline(that: this, );


/// Returns `true` if `Sleep` has elapsed.
///
/// A `Sleep` instance is elapsed when the requested duration has elapsed.
 Future<bool>  isElapsed()=>RustLib.instance.api.tokioTimeSleepIsElapsed(that: this, );


/// Resets the `Sleep` instance to a new deadline.
///
/// Calling this function allows changing the instant at which the `Sleep`
/// future completes without having to create new associated state.
///
/// This function can be called both before and after the future has
/// completed.
///
/// To call this method, you will usually combine the call with
/// [`Pin::as_mut`], which lets you call the method without consuming the
/// `Sleep` itself.
///
/// # Example
///
/// ```
/// use tokio::time::{Duration, Instant};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let sleep = tokio::time::sleep(Duration::from_millis(10));
/// tokio::pin!(sleep);
///
/// sleep.as_mut().reset(Instant::now() + Duration::from_millis(20));
/// # }
/// ```
///
/// See also the top-level examples.
///
/// [`Pin::as_mut`]: fn@std::pin::Pin::as_mut
 Future<void>  reset({required Instant deadline })=>RustLib.instance.api.tokioTimeSleepReset(that: this, deadline: deadline);


            }
            @sealed class SocketAddrImpl extends RustOpaque implements SocketAddr {
                // Not to be used by end users
                SocketAddrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SocketAddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SocketAddr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SocketAddr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SocketAddrPtr,
                );

                /// Returns the contents of this address if it is a `pathname` address.
///
/// Documentation reflected in [`SocketAddr`].
///
/// [`SocketAddr`]: std::os::unix::net::SocketAddr
 Future<Path?>  asPathname()=>RustLib.instance.api.tokioNetUnixSocketAddrAsPathname(that: this, );


/// Returns `true` if the address is unnamed.
///
/// Documentation reflected in [`SocketAddr`].
///
/// [`SocketAddr`]: std::os::unix::net::SocketAddr
 Future<bool>  isUnnamed()=>RustLib.instance.api.tokioNetUnixSocketAddrIsUnnamed(that: this, );


            }
            @sealed class SplitSelfImpl extends RustOpaque implements SplitSelf {
                // Not to be used by end users
                SplitSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                SplitSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_SplitSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_SplitSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_SplitSelfPtr,
                );

                
            }
            @sealed class StdCommandImpl extends RustOpaque implements StdCommand {
                // Not to be used by end users
                StdCommandImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                StdCommandImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_StdCommand,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_StdCommand,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_StdCommandPtr,
                );

                
            }
            @sealed class StderrImpl extends RustOpaque implements Stderr {
                // Not to be used by end users
                StderrImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                StderrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Stderr,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Stderr,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_StderrPtr,
                );

                
            }
            @sealed class StdinImpl extends RustOpaque implements Stdin {
                // Not to be used by end users
                StdinImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                StdinImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Stdin,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Stdin,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_StdinPtr,
                );

                
            }
            @sealed class StdoutImpl extends RustOpaque implements Stdout {
                // Not to be used by end users
                StdoutImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                StdoutImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Stdout,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Stdout,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_StdoutPtr,
                );

                
            }
            @sealed class StopwordTypeImpl extends RustOpaque implements StopwordType {
                // Not to be used by end users
                StopwordTypeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                StopwordTypeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_StopwordType,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_StopwordType,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_StopwordTypePtr,
                );

                
            }
            @sealed class TImpl extends RustOpaque implements T {
                // Not to be used by end users
                TImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_T,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_T,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TPtr,
                );

                
            }
            @sealed class TakeSelfImpl extends RustOpaque implements TakeSelf {
                // Not to be used by end users
                TakeSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TakeSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TakeSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TakeSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TakeSelfPtr,
                );

                
            }
            @sealed class TcpListenerImpl extends RustOpaque implements TcpListener {
                // Not to be used by end users
                TcpListenerImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TcpListenerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TcpListener,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TcpListener,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TcpListenerPtr,
                );

                /// Accepts a new incoming connection from this listener.
///
/// This function will yield once a new TCP connection is established. When
/// established, the corresponding [`TcpStream`] and the remote peer's
/// address will be returned.
///
/// # Cancel safety
///
/// This method is cancel safe. If the method is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that no new connections were
/// accepted by this method.
///
/// [`TcpStream`]: struct@crate::net::TcpStream
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpListener;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let listener = TcpListener::bind("127.0.0.1:8080").await?;
///
///     match listener.accept().await {
///         Ok((_socket, addr)) => println!("new client: {:?}", addr),
///         Err(e) => println!("couldn't get client: {:?}", e),
///     }
///
///     Ok(())
/// }
/// ```
 Future<(TcpStream,SocketAddr)>  accept()=>RustLib.instance.api.tokioNetTcpListenerAccept(that: this, );


/// Turns a [`tokio::net::TcpListener`] into a [`std::net::TcpListener`].
///
/// The returned [`std::net::TcpListener`] will have nonblocking mode set as
/// `true`.  Use [`set_nonblocking`] to change the blocking mode if needed.
///
/// # Examples
///
/// ```rust,no_run
/// use std::error::Error;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     let tokio_listener = tokio::net::TcpListener::bind("127.0.0.1:0").await?;
///     let std_listener = tokio_listener.into_std()?;
///     std_listener.set_nonblocking(false)?;
///     Ok(())
/// }
/// ```
///
/// [`tokio::net::TcpListener`]: TcpListener
/// [`std::net::TcpListener`]: std::net::TcpListener
/// [`set_nonblocking`]: fn@std::net::TcpListener::set_nonblocking
 Future<TcpListener>  intoStd()=>RustLib.instance.api.tokioNetTcpListenerIntoStd(that: this, );


/// Returns the local address that this listener is bound to.
///
/// This can be useful, for example, when binding to port 0 to figure out
/// which port was actually bound.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::net::TcpListener;
///
/// use std::io;
/// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let listener = TcpListener::bind("127.0.0.1:8080").await?;
///
///     assert_eq!(listener.local_addr()?,
///                SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));
///
///     Ok(())
/// }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetTcpListenerLocalAddr(that: this, );


/// Polls to accept a new incoming connection to this listener.
///
/// If there is no connection to accept, `Poll::Pending` is returned and the
/// current task will be notified by a waker.  Note that on multiple calls
/// to `poll_accept`, only the `Waker` from the `Context` passed to the most
/// recent call is scheduled to receive a wakeup.
 Future<PollResultTcpStreamSocketAddr>  pollAccept({required Context cx })=>RustLib.instance.api.tokioNetTcpListenerPollAccept(that: this, cx: cx);


/// Sets the value for the `IP_TTL` option on this socket.
///
/// This value sets the time-to-live field that is used in every packet sent
/// from this socket.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpListener;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let listener = TcpListener::bind("127.0.0.1:0").await?;
///
///     listener.set_ttl(100).expect("could not set TTL");
///
///     Ok(())
/// }
/// ```
 Future<void>  setTtl({required int ttl })=>RustLib.instance.api.tokioNetTcpListenerSetTtl(that: this, ttl: ttl);


/// Gets the value of the `IP_TTL` option for this socket.
///
/// For more information about this option, see [`set_ttl`].
///
/// [`set_ttl`]: method@Self::set_ttl
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpListener;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///    let listener = TcpListener::bind("127.0.0.1:0").await?;
///
///    listener.set_ttl(100).expect("could not set TTL");
///    assert_eq!(listener.ttl()?, 100);
///
///    Ok(())
/// }
/// ```
 Future<int>  ttl()=>RustLib.instance.api.tokioNetTcpListenerTtl(that: this, );


            }
            @sealed class TcpSocketImpl extends RustOpaque implements TcpSocket {
                // Not to be used by end users
                TcpSocketImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TcpSocketImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TcpSocket,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TcpSocket,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TcpSocketPtr,
                );

                /// Binds the socket to the given address.
///
/// This calls the `bind(2)` operating-system function. Behavior is
/// platform specific. Refer to the target platform's documentation for more
/// details.
///
/// # Examples
///
/// Bind a socket before listening.
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
/// # drop(listener);
///
///     Ok(())
/// }
/// ```
 Future<void>  bind({required SocketAddr addr })=>RustLib.instance.api.tokioNetTcpSocketBind(that: this, addr: addr);


/// Establishes a TCP connection with a peer at the specified socket address.
///
/// The `TcpSocket` is consumed. Once the connection is established, a
/// connected [`TcpStream`] is returned. If the connection fails, the
/// encountered error is returned.
///
/// [`TcpStream`]: TcpStream
///
/// This calls the `connect(2)` operating-system function. Behavior is
/// platform specific. Refer to the target platform's documentation for more
/// details.
///
/// # Examples
///
/// Connecting to a peer.
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     let stream = socket.connect(addr).await?;
/// # drop(stream);
///
///     Ok(())
/// }
/// ```
 Future<TcpStream>  connect({required SocketAddr addr })=>RustLib.instance.api.tokioNetTcpSocketConnect(that: this, addr: addr);


/// Gets the value of the `SO_KEEPALIVE` option on this socket.
 Future<bool>  keepalive()=>RustLib.instance.api.tokioNetTcpSocketKeepalive(that: this, );


/// Reads the linger duration for this socket by getting the `SO_LINGER`
/// option.
///
/// For more information about this option, see [`set_linger`].
///
/// [`set_linger`]: TcpSocket::set_linger
 Future<Duration?>  linger()=>RustLib.instance.api.tokioNetTcpSocketLinger(that: this, );


/// Converts the socket into a `TcpListener`.
///
/// `backlog` defines the maximum number of pending connections are queued
/// by the operating system at any given time. Connection are removed from
/// the queue with [`TcpListener::accept`]. When the queue is full, the
/// operating-system will start rejecting connections.
///
/// [`TcpListener::accept`]: TcpListener::accept
///
/// This calls the `listen(2)` operating-system function, marking the socket
/// as a passive socket. Behavior is platform specific. Refer to the target
/// platform's documentation for more details.
///
/// # Examples
///
/// Create a `TcpListener`.
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
/// # drop(listener);
///
///     Ok(())
/// }
/// ```
 Future<TcpListener>  listen({required int backlog })=>RustLib.instance.api.tokioNetTcpSocketListen(that: this, backlog: backlog);


/// Gets the local address of this socket.
///
/// Will fail on windows if called before `bind`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.bind(addr)?;
///     assert_eq!(socket.local_addr().unwrap().to_string(), "127.0.0.1:8080");
///     let listener = socket.listen(1024)?;
///     Ok(())
/// }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetTcpSocketLocalAddr(that: this, );


/// Gets the value of the `TCP_NODELAY` option on this socket.
///
/// For more information about this option, see [`set_nodelay`].
///
/// [`set_nodelay`]: TcpSocket::set_nodelay
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let socket = TcpSocket::new_v4()?;
///
/// println!("{:?}", socket.nodelay()?);
/// # Ok(())
/// # }
/// ```
 Future<bool>  nodelay()=>RustLib.instance.api.tokioNetTcpSocketNodelay(that: this, );


/// Returns the size of the TCP receive buffer for this socket.
///
/// On most operating systems, this is the value of the `SO_RCVBUF` socket
/// option.
///
/// Note that if [`set_recv_buffer_size`] has been called on this socket
/// previously, the value returned by this function may not be the same as
/// the argument provided to `set_recv_buffer_size`. This is for the
/// following reasons:
///
/// * Most operating systems have minimum and maximum allowed sizes for the
///   receive buffer, and will clamp the provided value if it is below the
///   minimum or above the maximum. The minimum and maximum buffer sizes are
///   OS-dependent.
/// * Linux will double the buffer size to account for internal bookkeeping
///   data, and returns the doubled value from `getsockopt(2)`. As per `man
///   7 socket`:
///   > Sets or gets the maximum socket send buffer in bytes. The
///   > kernel doubles this value (to allow space for bookkeeping
///   > overhead) when it is set using `setsockopt(2)`, and this doubled
///   > value is returned by `getsockopt(2)`.
///
/// [`set_recv_buffer_size`]: #method.set_recv_buffer_size
 Future<int>  recvBufferSize()=>RustLib.instance.api.tokioNetTcpSocketRecvBufferSize(that: this, );


/// Retrieves the value set for `SO_REUSEADDR` on this socket.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.set_reuseaddr(true)?;
///     assert!(socket.reuseaddr().unwrap());
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
///     Ok(())
/// }
/// ```
 Future<bool>  reuseaddr()=>RustLib.instance.api.tokioNetTcpSocketReuseaddr(that: this, );


/// Allows the socket to bind to an in-use port. Only available for unix systems
/// (excluding Solaris, Illumos, and Cygwin).
///
/// Behavior is platform specific. Refer to the target platform's
/// documentation for more details.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.set_reuseport(true)?;
///     assert!(socket.reuseport().unwrap());
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
///     Ok(())
/// }
/// ```
 Future<bool>  reuseport()=>RustLib.instance.api.tokioNetTcpSocketReuseport(that: this, );


/// Returns the size of the TCP send buffer for this socket.
///
/// On most operating systems, this is the value of the `SO_SNDBUF` socket
/// option.
///
/// Note that if [`set_send_buffer_size`] has been called on this socket
/// previously, the value returned by this function may not be the same as
/// the argument provided to `set_send_buffer_size`. This is for the
/// following reasons:
///
/// * Most operating systems have minimum and maximum allowed sizes for the
///   send buffer, and will clamp the provided value if it is below the
///   minimum or above the maximum. The minimum and maximum buffer sizes are
///   OS-dependent.
/// * Linux will double the buffer size to account for internal bookkeeping
///   data, and returns the doubled value from `getsockopt(2)`. As per `man
///   7 socket`:
///   > Sets or gets the maximum socket send buffer in bytes. The
///   > kernel doubles this value (to allow space for bookkeeping
///   > overhead) when it is set using `setsockopt(2)`, and this doubled
///   > value is returned by `getsockopt(2)`.
///
/// [`set_send_buffer_size`]: #method.set_send_buffer_size
 Future<int>  sendBufferSize()=>RustLib.instance.api.tokioNetTcpSocketSendBufferSize(that: this, );


/// Sets value for the `SO_KEEPALIVE` option on this socket.
 Future<void>  setKeepalive({required bool keepalive })=>RustLib.instance.api.tokioNetTcpSocketSetKeepalive(that: this, keepalive: keepalive);


/// Sets the linger duration of this socket by setting the `SO_LINGER` option.
///
/// This option controls the action taken when a stream has unsent messages and the stream is
/// closed. If `SO_LINGER` is set, the system shall block the process until it can transmit the
/// data or until the time expires.
///
/// If `SO_LINGER` is not specified, and the socket is closed, the system handles the call in a
/// way that allows the process to continue as quickly as possible.
///
/// This option is deprecated because setting `SO_LINGER` on a socket used with Tokio is always
/// incorrect as it leads to blocking the thread when the socket is closed. For more details,
/// please see:
///
/// > Volumes of communications have been devoted to the intricacies of `SO_LINGER` versus
/// > non-blocking (`O_NONBLOCK`) sockets. From what I can tell, the final word is: don't do
/// > it. Rely on the `shutdown()`-followed-by-`read()`-eof technique instead.
/// >
/// > From [The ultimate `SO_LINGER` page, or: why is my tcp not reliable](https://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable)
 Future<void>  setLinger({Duration? dur })=>RustLib.instance.api.tokioNetTcpSocketSetLinger(that: this, dur: dur);


/// Sets the value of the `TCP_NODELAY` option on this socket.
///
/// If set, this option disables the Nagle algorithm. This means that segments are always
/// sent as soon as possible, even if there is only a small amount of data. When not set,
/// data is buffered until there is a sufficient amount to send out, thereby avoiding
/// the frequent sending of small packets.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let socket = TcpSocket::new_v4()?;
///
/// socket.set_nodelay(true)?;
/// # Ok(())
/// # }
/// ```
 Future<void>  setNodelay({required bool nodelay })=>RustLib.instance.api.tokioNetTcpSocketSetNodelay(that: this, nodelay: nodelay);


/// Sets the size of the TCP receive buffer on this socket.
///
/// On most operating systems, this sets the `SO_RCVBUF` socket option.
 Future<void>  setRecvBufferSize({required int size })=>RustLib.instance.api.tokioNetTcpSocketSetRecvBufferSize(that: this, size: size);


/// Allows the socket to bind to an in-use address.
///
/// Behavior is platform specific. Refer to the target platform's
/// documentation for more details.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.set_reuseaddr(true)?;
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
/// # drop(listener);
///
///     Ok(())
/// }
/// ```
 Future<void>  setReuseaddr({required bool reuseaddr })=>RustLib.instance.api.tokioNetTcpSocketSetReuseaddr(that: this, reuseaddr: reuseaddr);


/// Allows the socket to bind to an in-use port. Only available for unix systems
/// (excluding Solaris, Illumos, and Cygwin).
///
/// Behavior is platform specific. Refer to the target platform's
/// documentation for more details.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpSocket;
///
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let addr = "127.0.0.1:8080".parse().unwrap();
///
///     let socket = TcpSocket::new_v4()?;
///     socket.set_reuseport(true)?;
///     socket.bind(addr)?;
///
///     let listener = socket.listen(1024)?;
///     Ok(())
/// }
/// ```
 Future<void>  setReuseport({required bool reuseport })=>RustLib.instance.api.tokioNetTcpSocketSetReuseport(that: this, reuseport: reuseport);


/// Sets the size of the TCP send buffer on this socket.
///
/// On most operating systems, this sets the `SO_SNDBUF` socket option.
 Future<void>  setSendBufferSize({required int size })=>RustLib.instance.api.tokioNetTcpSocketSetSendBufferSize(that: this, size: size);


/// Sets the value for the `IPV6_TCLASS` option on this socket.
///
/// Specifies the traffic class field that is used in every packet
/// sent from this socket.
///
/// # Note
///
/// This may not have any effect on IPv4 sockets.
 Future<void>  setTclassV6({required int tclass })=>RustLib.instance.api.tokioNetTcpSocketSetTclassV6(that: this, tclass: tclass);


/// Deprecated. Use [`set_tos_v4()`] instead.
///
/// [`set_tos_v4()`]: Self::set_tos_v4
 Future<void>  setTos({required int tos })=>RustLib.instance.api.tokioNetTcpSocketSetTos(that: this, tos: tos);


/// Sets the value for the `IP_TOS` option on this socket.
///
/// This value sets the type-of-service field that is used in every packet
/// sent from this socket.
///
/// # Note
///
/// - This may not have any effect on IPv6 sockets.
/// - On Windows, `IP_TOS` is only supported on [Windows 8+ or
///   Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
 Future<void>  setTosV4({required int tos })=>RustLib.instance.api.tokioNetTcpSocketSetTosV4(that: this, tos: tos);


/// Returns the value of the `SO_ERROR` option.
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetTcpSocketTakeError(that: this, );


/// Gets the value of the `IPV6_TCLASS` option for this socket.
///
/// For more information about this option, see [`set_tclass_v6`].
///
/// [`set_tclass_v6`]: Self::set_tclass_v6
 Future<int>  tclassV6()=>RustLib.instance.api.tokioNetTcpSocketTclassV6(that: this, );


/// Deprecated. Use [`tos_v4()`] instead.
///
/// [`tos_v4()`]: Self::tos_v4
 Future<int>  tos()=>RustLib.instance.api.tokioNetTcpSocketTos(that: this, );


/// Gets the value of the `IP_TOS` option for this socket.
///
/// For more information about this option, see [`set_tos_v4`].
///
/// [`set_tos_v4`]: Self::set_tos_v4
 Future<int>  tosV4()=>RustLib.instance.api.tokioNetTcpSocketTosV4(that: this, );


            }
            @sealed class TcpStreamImpl extends RustOpaque implements TcpStream {
                // Not to be used by end users
                TcpStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TcpStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TcpStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TcpStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TcpStreamPtr,
                );

                /// Splits a `TcpStream` into a read half and a write half, which can be used
/// to read and write the stream concurrently.
///
/// Unlike [`split`], the owned halves can be moved to separate tasks, however
/// this comes at the cost of a heap allocation.
///
/// **Note:** Dropping the write half will shut down the write half of the TCP
/// stream. This is equivalent to calling [`shutdown()`] on the `TcpStream`.
///
/// [`split`]: TcpStream::split()
/// [`shutdown()`]: fn@crate::io::AsyncWriteExt::shutdown
 Future<(OwnedReadHalf,OwnedWriteHalf)>  intoSplit()=>RustLib.instance.api.tokioNetTcpStreamIntoSplit(that: this, );


/// Turns a [`tokio::net::TcpStream`] into a [`std::net::TcpStream`].
///
/// The returned [`std::net::TcpStream`] will have nonblocking mode set as `true`.
/// Use [`set_nonblocking`] to change the blocking mode if needed.
///
/// # Examples
///
/// ```
/// use std::error::Error;
/// use std::io::Read;
/// use tokio::net::TcpListener;
/// # use tokio::net::TcpStream;
/// # use tokio::io::AsyncWriteExt;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
/// #   if cfg!(miri) { return Ok(()); } // No `socket` in miri.
///     let mut data = [0u8; 12];
/// #   if false {
///     let listener = TcpListener::bind("127.0.0.1:34254").await?;
/// #   }
/// #   let listener = TcpListener::bind("127.0.0.1:0").await?;
/// #   let addr = listener.local_addr().unwrap();
/// #   let handle = tokio::spawn(async move {
/// #       let mut stream: TcpStream = TcpStream::connect(addr).await.unwrap();
/// #       stream.write_all(b"Hello world!").await.unwrap();
/// #   });
///     let (tokio_tcp_stream, _) = listener.accept().await?;
///     let mut std_tcp_stream = tokio_tcp_stream.into_std()?;
/// #   handle.await.expect("The task being joined has panicked");
///     std_tcp_stream.set_nonblocking(false)?;
///     std_tcp_stream.read_exact(&mut data)?;
/// #   assert_eq!(b"Hello world!", &data);
///     Ok(())
/// }
/// ```
/// [`tokio::net::TcpStream`]: TcpStream
/// [`std::net::TcpStream`]: std::net::TcpStream
/// [`set_nonblocking`]: fn@std::net::TcpStream::set_nonblocking
 Future<TcpStream>  intoStd()=>RustLib.instance.api.tokioNetTcpStreamIntoStd(that: this, );


/// Reads the linger duration for this socket by getting the `SO_LINGER`
/// option.
///
/// For more information about this option, see [`set_linger`].
///
/// [`set_linger`]: TcpStream::set_linger
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// println!("{:?}", stream.linger()?);
/// # Ok(())
/// # }
/// ```
 Future<Duration?>  linger()=>RustLib.instance.api.tokioNetTcpStreamLinger(that: this, );


/// Returns the local address that this stream is bound to.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// println!("{:?}", stream.local_addr()?);
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetTcpStreamLocalAddr(that: this, );


/// Gets the value of the `TCP_NODELAY` option on this socket.
///
/// For more information about this option, see [`set_nodelay`].
///
/// [`set_nodelay`]: TcpStream::set_nodelay
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// println!("{:?}", stream.nodelay()?);
/// # Ok(())
/// # }
/// ```
 Future<bool>  nodelay()=>RustLib.instance.api.tokioNetTcpStreamNodelay(that: this, );


/// Receives data on the socket from the remote address to which it is
/// connected, without removing that data from the queue. On success,
/// returns the number of bytes peeked.
///
/// Successive calls return the same data. This is accomplished by passing
/// `MSG_PEEK` as a flag to the underlying `recv` system call.
///
/// # Cancel safety
///
/// This method is cancel safe. If the method is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that no peek was performed, and
/// that `buf` has not been modified.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use tokio::io::AsyncReadExt;
/// use std::error::Error;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     let mut b1 = [0; 10];
///     let mut b2 = [0; 10];
///
///     // Peek at the data
///     let n = stream.peek(&mut b1).await?;
///
///     // Read the data
///     assert_eq!(n, stream.read(&mut b2[..n]).await?);
///     assert_eq!(&b1[..n], &b2[..n]);
///
///     Ok(())
/// }
/// ```
///
/// The [`read`] method is defined on the [`AsyncReadExt`] trait.
///
/// [`read`]: fn@crate::io::AsyncReadExt::read
/// [`AsyncReadExt`]: trait@crate::io::AsyncReadExt
 Future<BigInt>  peek({required U8 buf })=>RustLib.instance.api.tokioNetTcpStreamPeek(that: this, buf: buf);


/// Returns the remote address that this stream is connected to.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// println!("{:?}", stream.peer_addr()?);
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetTcpStreamPeerAddr(that: this, );


/// Attempts to receive data on the socket, without removing that data from
/// the queue, registering the current task for wakeup if data is not yet
/// available.
///
/// Note that on multiple calls to `poll_peek`, `poll_read` or
/// `poll_read_ready`, only the `Waker` from the `Context` passed to the
/// most recent call is scheduled to receive a wakeup. (However,
/// `poll_write` retains a second, independent waker.)
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if data is not yet available.
/// * `Poll::Ready(Ok(n))` if data is available. `n` is the number of bytes peeked.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// # Examples
///
/// ```no_run
/// use tokio::io::{self, ReadBuf};
/// use tokio::net::TcpStream;
///
/// use std::future::poll_fn;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let stream = TcpStream::connect("127.0.0.1:8000").await?;
///     let mut buf = [0; 10];
///     let mut buf = ReadBuf::new(&mut buf);
///
///     poll_fn(|cx| {
///         stream.poll_peek(cx, &mut buf)
///     }).await?;
///
///     Ok(())
/// }
/// ```
 Future<PollResultUsize>  pollPeek({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetTcpStreamPollPeek(that: this, cx: cx, buf: buf);


/// Polls for read readiness.
///
/// If the tcp stream is not currently ready for reading, this method will
/// store a clone of the `Waker` from the provided `Context`. When the tcp
/// stream becomes ready for reading, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_read_ready`, `poll_read` or
/// `poll_peek`, only the `Waker` from the `Context` passed to the most
/// recent call is scheduled to receive a wakeup. (However,
/// `poll_write_ready` retains a second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`readable`] is not feasible. Where possible, using [`readable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the tcp stream is not ready for reading.
/// * `Poll::Ready(Ok(()))` if the tcp stream is ready for reading.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`readable`]: method@Self::readable
 Future<PollResult>  pollReadReady({required Context cx })=>RustLib.instance.api.tokioNetTcpStreamPollReadReady(that: this, cx: cx);


/// Polls for write readiness.
///
/// If the tcp stream is not currently ready for writing, this method will
/// store a clone of the `Waker` from the provided `Context`. When the tcp
/// stream becomes ready for writing, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup. (However, `poll_read_ready` retains a
/// second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`writable`] is not feasible. Where possible, using [`writable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the tcp stream is not ready for writing.
/// * `Poll::Ready(Ok(()))` if the tcp stream is ready for writing.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`writable`]: method@Self::writable
 Future<PollResult>  pollWriteReady({required Context cx })=>RustLib.instance.api.tokioNetTcpStreamPollWriteReady(that: this, cx: cx);


/// Waits for the socket to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with `try_read()`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     let mut msg = vec![0; 1024];
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read(&mut msg) {
///             Ok(n) => {
///                 msg.truncate(n);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     println!("GOT = {:?}", msg);
///     Ok(())
/// }
/// ```
 Future<void>  readable()=>RustLib.instance.api.tokioNetTcpStreamReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with `try_read()` or `try_write()`. It
/// can be used to concurrently read / write to the same socket on a single
/// task without splitting the socket.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// Concurrently read and write to the stream on the same task without
/// splitting.
///
/// ```no_run
/// use tokio::io::Interest;
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     loop {
///         let ready = stream.ready(Interest::READABLE | Interest::WRITABLE).await?;
///
///         if ready.is_readable() {
///             let mut data = vec![0; 1024];
///             // Try to read data, this may still fail with `WouldBlock`
///             // if the readiness event is a false positive.
///             match stream.try_read(&mut data) {
///                 Ok(n) => {
///                     println!("read {} bytes", n);
///                 }
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                     continue;
///                 }
///                 Err(e) => {
///                     return Err(e.into());
///                 }
///             }
///
///         }
///
///         if ready.is_writable() {
///             // Try to write data, this may still fail with `WouldBlock`
///             // if the readiness event is a false positive.
///             match stream.try_write(b"hello world") {
///                 Ok(n) => {
///                     println!("write {} bytes", n);
///                 }
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                     continue
///                 }
///                 Err(e) => {
///                     return Err(e.into());
///                 }
///             }
///         }
///     }
/// }
/// ```
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetTcpStreamReady(that: this, interest: interest);


/// Sets the linger duration of this socket by setting the `SO_LINGER` option.
///
/// This option controls the action taken when a stream has unsent messages and the stream is
/// closed. If `SO_LINGER` is set, the system shall block the process until it can transmit the
/// data or until the time expires.
///
/// If `SO_LINGER` is not specified, and the stream is closed, the system handles the call in a
/// way that allows the process to continue as quickly as possible.
///
/// This option is deprecated because setting `SO_LINGER` on a socket used with Tokio is
/// always incorrect as it leads to blocking the thread when the socket is closed. For more
/// details, please see:
///
/// > Volumes of communications have been devoted to the intricacies of `SO_LINGER` versus
/// > non-blocking (`O_NONBLOCK`) sockets. From what I can tell, the final word is: don't
/// > do it. Rely on the `shutdown()`-followed-by-`read()`-eof technique instead.
/// >
/// > From [The ultimate `SO_LINGER` page, or: why is my tcp not reliable](https://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable)
///
/// # Examples
///
/// ```no_run
/// # #![allow(deprecated)]
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// stream.set_linger(None)?;
/// # Ok(())
/// # }
/// ```
 Future<void>  setLinger({Duration? dur })=>RustLib.instance.api.tokioNetTcpStreamSetLinger(that: this, dur: dur);


/// Sets the value of the `TCP_NODELAY` option on this socket.
///
/// If set, this option disables the Nagle algorithm. This means that
/// segments are always sent as soon as possible, even if there is only a
/// small amount of data. When not set, data is buffered until there is a
/// sufficient amount to send out, thereby avoiding the frequent sending of
/// small packets.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// stream.set_nodelay(true)?;
/// # Ok(())
/// # }
/// ```
 Future<void>  setNodelay({required bool nodelay })=>RustLib.instance.api.tokioNetTcpStreamSetNodelay(that: this, nodelay: nodelay);


/// Sets the value for the `IP_TTL` option on this socket.
///
/// This value sets the time-to-live field that is used in every packet sent
/// from this socket.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// stream.set_ttl(123)?;
/// # Ok(())
/// # }
/// ```
 Future<void>  setTtl({required int ttl })=>RustLib.instance.api.tokioNetTcpStreamSetTtl(that: this, ttl: ttl);


/// Returns the value of the `SO_ERROR` option.
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetTcpStreamTakeError(that: this, );


/// Tries to read data from the stream into the provided buffer, returning how
/// many bytes were read.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read()` is non-blocking, the buffer does not have to be stored by
/// the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`readable()`]: TcpStream::readable()
/// [`ready()`]: TcpStream::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
///
/// 1. The stream's read half is closed and will no longer yield data.
/// 2. The specified buffer was 0 bytes in length.
///
/// If the stream is not ready to read data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Creating the buffer **after** the `await` prevents it from
///         // being stored in the async task.
///         let mut buf = [0; 4096];
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read(&mut buf) {
///             Ok(0) => break,
///             Ok(n) => {
///                 println!("read {} bytes", n);
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryRead({required U8 buf })=>RustLib.instance.api.tokioNetTcpStreamTryRead(that: this, buf: buf);


/// Tries to read data from the stream into the provided buffers, returning
/// how many bytes were read.
///
/// Data is copied to fill each buffer in order, with the final buffer
/// written to possibly being only partially filled. This method behaves
/// equivalently to a single call to [`try_read()`] with concatenated
/// buffers.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read_vectored()` is non-blocking, the buffer does not have to be
/// stored by the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`try_read()`]: TcpStream::try_read()
/// [`readable()`]: TcpStream::readable()
/// [`ready()`]: TcpStream::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. `Ok(0)` indicates the stream's read half is closed
/// and will no longer yield data. If the stream is not ready to read data
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io::{self, IoSliceMut};
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Creating the buffer **after** the `await` prevents it from
///         // being stored in the async task.
///         let mut buf_a = [0; 512];
///         let mut buf_b = [0; 1024];
///         let mut bufs = [
///             IoSliceMut::new(&mut buf_a),
///             IoSliceMut::new(&mut buf_b),
///         ];
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read_vectored(&mut bufs) {
///             Ok(0) => break,
///             Ok(n) => {
///                 println!("read {} bytes", n);
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryReadVectored({required IoSliceMut bufs })=>RustLib.instance.api.tokioNetTcpStreamTryReadVectored(that: this, bufs: bufs);


/// Try to write a buffer to the stream, returning how many bytes were
/// written.
///
/// The function will attempt to write the entire contents of `buf`, but
/// only part of the buffer may be written.
///
/// This function is usually paired with `writable()`.
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWrite({required List<int> buf })=>RustLib.instance.api.tokioNetTcpStreamTryWrite(that: this, buf: buf);


/// Tries to write several buffers to the stream, returning how many bytes
/// were written.
///
/// Data is written from each buffer in order, with the final buffer read
/// from possibly being only partially consumed. This method behaves
/// equivalently to a single call to [`try_write()`] with concatenated
/// buffers.
///
/// This function is usually paired with `writable()`.
///
/// [`try_write()`]: TcpStream::try_write()
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write_vectored(&bufs) {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWriteVectored({required List<IoSlice> bufs })=>RustLib.instance.api.tokioNetTcpStreamTryWriteVectored(that: this, bufs: bufs);


/// Gets the value of the `IP_TTL` option for this socket.
///
/// For more information about this option, see [`set_ttl`].
///
/// [`set_ttl`]: TcpStream::set_ttl
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
/// println!("{:?}", stream.ttl()?);
/// # Ok(())
/// # }
/// ```
 Future<int>  ttl()=>RustLib.instance.api.tokioNetTcpStreamTtl(that: this, );


/// Waits for the socket to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
/// paired with `try_write()`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::TcpStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  writable()=>RustLib.instance.api.tokioNetTcpStreamWritable(that: this, );


            }
            @sealed class TryCurrentErrorImpl extends RustOpaque implements TryCurrentError {
                // Not to be used by end users
                TryCurrentErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TryCurrentErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TryCurrentError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TryCurrentError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TryCurrentErrorPtr,
                );

                /// Returns true if the call failed because there is currently no runtime in
/// the Tokio context.
 Future<bool>  isMissingContext()=>RustLib.instance.api.tokioRuntimeTryCurrentErrorIsMissingContext(that: this, );


/// Returns true if the call failed because the Tokio context thread-local
/// had been destroyed. This can usually only happen if in the destructor of
/// other thread-locals.
 Future<bool>  isThreadLocalDestroyed()=>RustLib.instance.api.tokioRuntimeTryCurrentErrorIsThreadLocalDestroyed(that: this, );


            }
            @sealed class TryRecvErrorImpl extends RustOpaque implements TryRecvError {
                // Not to be used by end users
                TryRecvErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TryRecvErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TryRecvError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TryRecvError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TryRecvErrorPtr,
                );

                
            }
            @sealed class TrySendErrorImpl extends RustOpaque implements TrySendError {
                // Not to be used by end users
                TrySendErrorImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TrySendErrorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TrySendError,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendError,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendErrorPtr,
                );

                
            }
            @sealed class TrySendErrorSelfImpl extends RustOpaque implements TrySendErrorSelf {
                // Not to be used by end users
                TrySendErrorSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TrySendErrorSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TrySendErrorSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendErrorSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendErrorSelfPtr,
                );

                
            }
            @sealed class TrySendErrorTImpl extends RustOpaque implements TrySendErrorT {
                // Not to be used by end users
                TrySendErrorTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                TrySendErrorTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_TrySendErrorT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendErrorT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_TrySendErrorTPtr,
                );

                
            }
            @sealed class U8Impl extends RustOpaque implements U8 {
                // Not to be used by end users
                U8Impl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                U8Impl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_U8,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_U8,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_U8Ptr,
                );

                
            }
            @sealed class UCredImpl extends RustOpaque implements UCred {
                // Not to be used by end users
                UCredImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UCredImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UCred,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UCred,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UCredPtr,
                );

                /// Gets GID (group ID) of the process.
 Future<GidT>  gid()=>RustLib.instance.api.tokioNetUnixUCredGid(that: this, );


/// Gets PID (process ID) of the process.
///
/// This is only implemented under Linux, Android, iOS, macOS, Solaris,
/// Illumos and Cygwin. On other platforms this will always return `None`.
 Future<PidT?>  pid()=>RustLib.instance.api.tokioNetUnixUCredPid(that: this, );


/// Gets UID (user ID) of the process.
 Future<UidT>  uid()=>RustLib.instance.api.tokioNetUnixUCredUid(that: this, );


            }
            @sealed class UdpSocketImpl extends RustOpaque implements UdpSocket {
                // Not to be used by end users
                UdpSocketImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UdpSocketImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UdpSocket,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UdpSocket,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UdpSocketPtr,
                );

                /// Gets the value of the `SO_BROADCAST` option for this socket.
///
/// For more information about this option, see [`set_broadcast`].
///
/// [`set_broadcast`]: method@Self::set_broadcast
 Future<bool>  broadcast()=>RustLib.instance.api.tokioNetUdpSocketBroadcast(that: this, );


/// Turns a [`tokio::net::UdpSocket`] into a [`std::net::UdpSocket`].
///
/// The returned [`std::net::UdpSocket`] will have nonblocking mode set as
/// `true`.  Use [`set_nonblocking`] to change the blocking mode if needed.
///
/// # Examples
///
/// ```rust,no_run
/// use std::error::Error;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     let tokio_socket = tokio::net::UdpSocket::bind("127.0.0.1:0").await?;
///     let std_socket = tokio_socket.into_std()?;
///     std_socket.set_nonblocking(false)?;
///     Ok(())
/// }
/// ```
///
/// [`tokio::net::UdpSocket`]: UdpSocket
/// [`std::net::UdpSocket`]: std::net::UdpSocket
/// [`set_nonblocking`]: fn@std::net::UdpSocket::set_nonblocking
 Future<UdpSocket>  intoStd()=>RustLib.instance.api.tokioNetUdpSocketIntoStd(that: this, );


/// Executes an operation of the `IP_ADD_MEMBERSHIP` type.
///
/// This function specifies a new multicast group for this socket to join.
/// The address must be a valid multicast address, and `interface` is the
/// address of the local interface with which the system should join the
/// multicast group. If it's equal to `INADDR_ANY` then an appropriate
/// interface is chosen by the system.
 Future<void>  joinMulticastV4({required Ipv4Addr multiaddr , required Ipv4Addr interface_ })=>RustLib.instance.api.tokioNetUdpSocketJoinMulticastV4(that: this, multiaddr: multiaddr, interface_: interface_);


/// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.
///
/// This function specifies a new multicast group for this socket to join.
/// The address must be a valid multicast address, and `interface` is the
/// index of the interface to join/leave (or 0 to indicate any interface).
 Future<void>  joinMulticastV6({required Ipv6Addr multiaddr , required int interface_ })=>RustLib.instance.api.tokioNetUdpSocketJoinMulticastV6(that: this, multiaddr: multiaddr, interface_: interface_);


/// Executes an operation of the `IP_DROP_MEMBERSHIP` type.
///
/// For more information about this option, see [`join_multicast_v4`].
///
/// [`join_multicast_v4`]: method@Self::join_multicast_v4
 Future<void>  leaveMulticastV4({required Ipv4Addr multiaddr , required Ipv4Addr interface_ })=>RustLib.instance.api.tokioNetUdpSocketLeaveMulticastV4(that: this, multiaddr: multiaddr, interface_: interface_);


/// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.
///
/// For more information about this option, see [`join_multicast_v6`].
///
/// [`join_multicast_v6`]: method@Self::join_multicast_v6
 Future<void>  leaveMulticastV6({required Ipv6Addr multiaddr , required int interface_ })=>RustLib.instance.api.tokioNetUdpSocketLeaveMulticastV6(that: this, multiaddr: multiaddr, interface_: interface_);


/// Returns the local address that this socket is bound to.
///
/// # Example
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// # use std::{io, net::SocketAddr};
///
/// # #[tokio::main]
/// # async fn main() -> io::Result<()> {
/// let addr = "0.0.0.0:8080".parse::<SocketAddr>().unwrap();
/// let sock = UdpSocket::bind(addr).await?;
/// // the address the socket is bound to
/// let local_addr = sock.local_addr()?;
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetUdpSocketLocalAddr(that: this, );


/// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.
///
/// For more information about this option, see [`set_multicast_loop_v4`].
///
/// [`set_multicast_loop_v4`]: method@Self::set_multicast_loop_v4
 Future<bool>  multicastLoopV4()=>RustLib.instance.api.tokioNetUdpSocketMulticastLoopV4(that: this, );


/// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.
///
/// For more information about this option, see [`set_multicast_loop_v6`].
///
/// [`set_multicast_loop_v6`]: method@Self::set_multicast_loop_v6
 Future<bool>  multicastLoopV6()=>RustLib.instance.api.tokioNetUdpSocketMulticastLoopV6(that: this, );


/// Gets the value of the `IP_MULTICAST_TTL` option for this socket.
///
/// For more information about this option, see [`set_multicast_ttl_v4`].
///
/// [`set_multicast_ttl_v4`]: method@Self::set_multicast_ttl_v4
 Future<int>  multicastTtlV4()=>RustLib.instance.api.tokioNetUdpSocketMulticastTtlV4(that: this, );


/// Receives a single datagram from the connected address without removing it from the queue.
/// On success, returns the number of bytes read from whence the data came.
///
/// # Notes
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and peek returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     let mut buf = vec![0u8; 32];
///     let len = socket.peek(&mut buf).await?;
///
///     println!("peeked {:?} bytes", len);
///
///     Ok(())
/// }
/// ```
///
/// [`peek_sender`]: method@Self::peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<BigInt>  peek({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketPeek(that: this, buf: buf);


/// Receives data from the socket, without removing it from the input queue.
/// On success, returns the number of bytes read and the address from whence
/// the data came.
///
/// # Notes
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and `peek_from` returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     let mut buf = vec![0u8; 32];
///     let (len, addr) = socket.peek_from(&mut buf).await?;
///
///     println!("peeked {:?} bytes from {:?}", len, addr);
///
///     Ok(())
/// }
/// ```
///
/// [`peek_sender`]: method@Self::peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<(BigInt,SocketAddr)>  peekFrom({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketPeekFrom(that: this, buf: buf);


/// Retrieve the sender of the data at the head of the input queue, waiting if empty.
///
/// This is equivalent to calling [`peek_from`] with a zero-sized buffer,
/// but suppresses the `WSAEMSGSIZE` error on Windows and the "invalid argument" error on macOS.
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [`peek_from`]: method@Self::peek_from
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<SocketAddr>  peekSender()=>RustLib.instance.api.tokioNetUdpSocketPeekSender(that: this, );


/// Returns the socket address of the remote peer this socket was connected to.
///
/// # Example
///
/// ```
/// use tokio::net::UdpSocket;
///
/// # use std::{io, net::SocketAddr};
/// # #[tokio::main]
/// # async fn main() -> io::Result<()> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// let addr = "0.0.0.0:8080".parse::<SocketAddr>().unwrap();
/// let peer = "127.0.0.1:11100".parse::<SocketAddr>().unwrap();
/// let sock = UdpSocket::bind(addr).await?;
/// sock.connect(peer).await?;
/// assert_eq!(peer, sock.peer_addr()?);
/// #    Ok(())
/// # }
/// ```
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetUdpSocketPeerAddr(that: this, );


/// Receives data from the connected address, without removing it from the input queue.
///
/// # Notes
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and peek returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`poll_peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(()))` reads data into `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`poll_peek_sender`]: method@Self::poll_peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<PollResult>  pollPeek({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUdpSocketPollPeek(that: this, cx: cx, buf: buf);


/// Receives data from the socket, without removing it from the input queue.
/// On success, returns the sending address of the datagram.
///
/// # Notes
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and peek returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`poll_peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`poll_peek_sender`]: method@Self::poll_peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<PollResultSocketAddr>  pollPeekFrom({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUdpSocketPollPeekFrom(that: this, cx: cx, buf: buf);


/// Retrieve the sender of the data at the head of the input queue,
/// scheduling a wakeup if empty.
///
/// This is equivalent to calling [`poll_peek_from`] with a zero-sized buffer,
/// but suppresses the `WSAEMSGSIZE` error on Windows and the "invalid argument" error on macOS.
///
/// # Notes
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [`poll_peek_from`]: method@Self::poll_peek_from
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<PollResultSocketAddr>  pollPeekSender({required Context cx })=>RustLib.instance.api.tokioNetUdpSocketPollPeekSender(that: this, cx: cx);


/// Attempts to receive a single datagram message on the socket from the remote
/// address to which it is `connect`ed.
///
/// The [`connect`] method will connect this socket to a remote address. This method
/// resolves to an error if the socket is not connected.
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(()))` reads data `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`connect`]: method@Self::connect
 Future<PollResult>  pollRecv({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUdpSocketPollRecv(that: this, cx: cx, buf: buf);


/// Attempts to receive a single datagram on the socket.
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// # Notes
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<PollResultSocketAddr>  pollRecvFrom({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUdpSocketPollRecvFrom(that: this, cx: cx, buf: buf);


/// Polls for read/receive readiness.
///
/// If the udp stream is not currently ready for receiving, this method will
/// store a clone of the `Waker` from the provided `Context`. When the udp
/// socket becomes ready for reading, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_recv_ready`, `poll_recv` or
/// `poll_peek`, only the `Waker` from the `Context` passed to the most
/// recent call is scheduled to receive a wakeup. (However,
/// `poll_send_ready` retains a second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`readable`] is not feasible. Where possible, using [`readable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the udp stream is not ready for reading.
/// * `Poll::Ready(Ok(()))` if the udp stream is ready for reading.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`readable`]: method@Self::readable
 Future<PollResult>  pollRecvReady({required Context cx })=>RustLib.instance.api.tokioNetUdpSocketPollRecvReady(that: this, cx: cx);


/// Attempts to send data on the socket to the remote address to which it
/// was previously `connect`ed.
///
/// The [`connect`] method will connect this socket to a remote address.
/// This method will fail if the socket is not connected.
///
/// Note that on multiple calls to a `poll_*` method in the send direction,
/// only the `Waker` from the `Context` passed to the most recent call will
/// be scheduled to receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not available to write
/// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`connect`]: method@Self::connect
 Future<PollResultUsize>  pollSend({required Context cx , required List<int> buf })=>RustLib.instance.api.tokioNetUdpSocketPollSend(that: this, cx: cx, buf: buf);


/// Polls for write/send readiness.
///
/// If the udp stream is not currently ready for sending, this method will
/// store a clone of the `Waker` from the provided `Context`. When the udp
/// stream becomes ready for sending, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_send_ready` or `poll_send`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup. (However, `poll_recv_ready` retains a
/// second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`writable`] is not feasible. Where possible, using [`writable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the udp stream is not ready for writing.
/// * `Poll::Ready(Ok(()))` if the udp stream is ready for writing.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`writable`]: method@Self::writable
 Future<PollResult>  pollSendReady({required Context cx })=>RustLib.instance.api.tokioNetUdpSocketPollSendReady(that: this, cx: cx);


/// Attempts to send data on the socket to a given address.
///
/// Note that on multiple calls to a `poll_*` method in the send direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to write
/// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
 Future<PollResultUsize>  pollSendTo({required Context cx , required List<int> buf , required SocketAddr target })=>RustLib.instance.api.tokioNetUdpSocketPollSendTo(that: this, cx: cx, buf: buf, target: target);


/// Waits for the socket to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with `try_recv()`.
///
/// The function may complete without the socket being readable. This is a
/// false-positive and attempting a `try_recv()` will return with
/// `io::ErrorKind::WouldBlock`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv(&mut buf) {
///             Ok(n) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  readable()=>RustLib.instance.api.tokioNetUdpSocketReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with `try_recv()` or `try_send()`. It
/// can be used to concurrently `recv` / `send` to the same socket on a single
/// task without splitting the socket.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// Concurrently receive from and send to the socket on the same task
/// without splitting.
///
/// ```no_run
/// use tokio::io::{self, Interest};
/// use tokio::net::UdpSocket;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     loop {
///         let ready = socket.ready(Interest::READABLE | Interest::WRITABLE).await?;
///
///         if ready.is_readable() {
///             // The buffer is **not** included in the async task and will only exist
///             // on the stack.
///             let mut data = [0; 1024];
///             match socket.try_recv(&mut data[..]) {
///                 Ok(n) => {
///                     println!("received {:?}", &data[..n]);
///                 }
///                 // False-positive, continue
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
///                 Err(e) => {
///                     return Err(e);
///                 }
///             }
///         }
///
///         if ready.is_writable() {
///             // Write some data
///             match socket.try_send(b"hello world") {
///                 Ok(n) => {
///                     println!("sent {} bytes", n);
///                 }
///                 // False-positive, continue
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
///                 Err(e) => {
///                     return Err(e);
///                 }
///             }
///         }
///     }
/// }
/// ```
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetUdpSocketReady(that: this, interest: interest);


/// Receives a single datagram message on the socket from the remote address
/// to which it is connected. On success, returns the number of bytes read.
///
/// The function must be called with valid byte array `buf` of sufficient
/// size to hold the message bytes. If a message is too long to fit in the
/// supplied buffer, excess bytes may be discarded.
///
/// The [`connect`] method will connect this socket to a remote address.
/// This method will fail if the socket is not connected.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// socket.
///
/// [`connect`]: method@Self::connect
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Bind socket
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     let mut buf = vec![0; 10];
///     let n = socket.recv(&mut buf).await?;
///
///     println!("received {} bytes {:?}", n, &buf[..n]);
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  recv({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketRecv(that: this, buf: buf);


/// Receives a single datagram message on the socket. On success, returns
/// the number of bytes read and the origin.
///
/// The function must be called with valid byte array `buf` of sufficient
/// size to hold the message bytes. If a message is too long to fit in the
/// supplied buffer, excess bytes may be discarded.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv_from` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// socket.
///
/// # Example
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     let mut buf = vec![0u8; 32];
///     let (len, addr) = socket.recv_from(&mut buf).await?;
///
///     println!("received {:?} bytes from {:?}", len, addr);
///
///     Ok(())
/// }
/// ```
///
/// # Notes
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<(BigInt,SocketAddr)>  recvFrom({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketRecvFrom(that: this, buf: buf);


/// Sends data on the socket to the remote address that the socket is
/// connected to.
///
/// The [`connect`] method will connect this socket to a remote address.
/// This method will fail if the socket is not connected.
///
/// [`connect`]: method@Self::connect
///
/// # Return
///
/// On success, the number of bytes sent is returned, otherwise, the
/// encountered error is returned.
///
/// # Cancel safety
///
/// This method is cancel safe. If `send` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that the message was not sent.
///
/// # Examples
///
/// ```no_run
/// use tokio::io;
/// use tokio::net::UdpSocket;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Bind socket
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     // Send a message
///     socket.send(b"hello world").await?;
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  send({required List<int> buf })=>RustLib.instance.api.tokioNetUdpSocketSend(that: this, buf: buf);


/// Sets the value of the `SO_BROADCAST` option for this socket.
///
/// When enabled, this socket is allowed to send packets to a broadcast
/// address.
 Future<void>  setBroadcast({required bool on_ })=>RustLib.instance.api.tokioNetUdpSocketSetBroadcast(that: this, on_: on_);


/// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.
///
/// If enabled, multicast packets will be looped back to the local socket.
///
/// # Note
///
/// This may not have any effect on IPv6 sockets.
 Future<void>  setMulticastLoopV4({required bool on_ })=>RustLib.instance.api.tokioNetUdpSocketSetMulticastLoopV4(that: this, on_: on_);


/// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.
///
/// Controls whether this socket sees the multicast packets it sends itself.
///
/// # Note
///
/// This may not have any effect on IPv4 sockets.
 Future<void>  setMulticastLoopV6({required bool on_ })=>RustLib.instance.api.tokioNetUdpSocketSetMulticastLoopV6(that: this, on_: on_);


/// Sets the value of the `IP_MULTICAST_TTL` option for this socket.
///
/// Indicates the time-to-live value of outgoing multicast packets for
/// this socket. The default value is 1 which means that multicast packets
/// don't leave the local network unless explicitly requested.
///
/// # Note
///
/// This may not have any effect on IPv6 sockets.
 Future<void>  setMulticastTtlV4({required int ttl })=>RustLib.instance.api.tokioNetUdpSocketSetMulticastTtlV4(that: this, ttl: ttl);


/// Sets the value for the `IPV6_TCLASS` option on this socket.
///
/// Specifies the traffic class field that is used in every packet
/// sent from this socket.
///
/// # Note
///
/// This may not have any effect on IPv4 sockets.
 Future<void>  setTclassV6({required int tclass })=>RustLib.instance.api.tokioNetUdpSocketSetTclassV6(that: this, tclass: tclass);


/// Deprecated. Use [`set_tos_v4()`] instead.
///
/// [`set_tos_v4()`]: Self::set_tos_v4
 Future<void>  setTos({required int tos })=>RustLib.instance.api.tokioNetUdpSocketSetTos(that: this, tos: tos);


/// Sets the value for the `IP_TOS` option on this socket.
///
/// This value sets the type-of-service field that is used in every packet
/// sent from this socket.
///
/// # Note
///
/// - This may not have any effect on IPv6 sockets.
/// - On Windows, `IP_TOS` is only supported on [Windows 8+ or
///   Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
 Future<void>  setTosV4({required int tos })=>RustLib.instance.api.tokioNetUdpSocketSetTosV4(that: this, tos: tos);


/// Sets the value for the `IP_TTL` option on this socket.
///
/// This value sets the time-to-live field that is used in every packet sent
/// from this socket.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// # use std::io;
///
/// # async fn dox() -> io::Result<()> {
/// let sock = UdpSocket::bind("127.0.0.1:8080").await?;
/// sock.set_ttl(60)?;
///
/// # Ok(())
/// # }
/// ```
 Future<void>  setTtl({required int ttl })=>RustLib.instance.api.tokioNetUdpSocketSetTtl(that: this, ttl: ttl);


/// Returns the value of the `SO_ERROR` option.
///
/// # Examples
/// ```
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
/// #   if cfg!(miri) { return Ok(()); } // No `socket` in miri.
///     // Create a socket
///     let socket = UdpSocket::bind("0.0.0.0:8080").await?;
///
///     if let Ok(Some(err)) = socket.take_error() {
///         println!("Got error: {:?}", err);
///     }
///
///     Ok(())
/// }
/// ```
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetUdpSocketTakeError(that: this, );


/// Gets the value of the `IPV6_TCLASS` option for this socket.
///
/// For more information about this option, see [`set_tclass_v6`].
///
/// [`set_tclass_v6`]: Self::set_tclass_v6
 Future<int>  tclassV6()=>RustLib.instance.api.tokioNetUdpSocketTclassV6(that: this, );


/// Deprecated. Use [`tos_v4()`] instead.
///
/// [`tos_v4()`]: Self::tos_v4
 Future<int>  tos()=>RustLib.instance.api.tokioNetUdpSocketTos(that: this, );


/// Gets the value of the `IP_TOS` option for this socket.
///
/// For more information about this option, see [`set_tos_v4`].
///
/// [`set_tos_v4`]: Self::set_tos_v4
 Future<int>  tosV4()=>RustLib.instance.api.tokioNetUdpSocketTosV4(that: this, );


/// Tries to receive data on the connected address without removing it from the input queue.
/// On success, returns the number of bytes read.
///
/// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `readable()`.
///
/// # Notes
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and peek returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`try_peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [`try_peek_sender`]: method@Self::try_peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<BigInt>  tryPeek({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketTryPeek(that: this, buf: buf);


/// Tries to receive data on the socket without removing it from the input queue.
/// On success, returns the number of bytes read and the sending address of the
/// datagram.
///
/// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `readable()`.
///
/// # Notes
///
/// On Windows, if the data is larger than the buffer specified, the buffer
/// is filled with the first part of the data, and peek returns the error
/// `WSAEMSGSIZE(10040)`. The excess data is lost.
/// Make sure to always use a sufficiently large buffer to hold the
/// maximum UDP packet size, which can be up to 65536 bytes in size.
///
/// MacOS will return an error if you pass a zero-sized buffer.
///
/// If you're merely interested in learning the sender of the data at the head of the queue,
/// try [`try_peek_sender`].
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [`try_peek_sender`]: method@Self::try_peek_sender
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<(BigInt,SocketAddr)>  tryPeekFrom({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketTryPeekFrom(that: this, buf: buf);


/// Try to retrieve the sender of the data at the head of the input queue.
///
/// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `readable()`.
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
 Future<SocketAddr>  tryPeekSender()=>RustLib.instance.api.tokioNetUdpSocketTryPeekSender(that: this, );


/// Tries to receive a single datagram message on the socket from the remote
/// address to which it is connected. On success, returns the number of
/// bytes read.
///
/// This method must be called with valid byte array `buf` of sufficient size
/// to hold the message bytes. If a message is too long to fit in the
/// supplied buffer, excess bytes may be discarded.
///
/// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `readable()`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv(&mut buf) {
///             Ok(n) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryRecv({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketTryRecv(that: this, buf: buf);


/// Tries to receive a single datagram message on the socket. On success,
/// returns the number of bytes read and the origin.
///
/// This method must be called with valid byte array `buf` of sufficient size
/// to hold the message bytes. If a message is too long to fit in the
/// supplied buffer, excess bytes may be discarded.
///
/// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `readable()`.
///
/// # Notes
///
/// Note that the socket address **cannot** be implicitly trusted, because it is relatively
/// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
/// Because UDP is stateless and does not validate the origin of a packet,
/// the attacker does not need to be able to intercept traffic in order to interfere.
/// It is important to be aware of this when designing your application-level protocol.
///
/// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv_from(&mut buf) {
///             Ok((n, _addr)) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<(BigInt,SocketAddr)>  tryRecvFrom({required U8 buf })=>RustLib.instance.api.tokioNetUdpSocketTryRecvFrom(that: this, buf: buf);


/// Tries to send data on the socket to the remote address to which it is
/// connected.
///
/// When the socket buffer is full, `Err(io::ErrorKind::WouldBlock)` is
/// returned. This function is usually paired with `writable()`.
///
/// # Returns
///
/// If successful, `Ok(n)` is returned, where `n` is the number of bytes
/// sent. If the socket is not ready to send data,
/// `Err(ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Bind a UDP socket
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     // Connect to a peer
///     socket.connect("127.0.0.1:8081").await?;
///
///     loop {
///         // Wait for the socket to be writable
///         socket.writable().await?;
///
///         // Try to send data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_send(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  trySend({required List<int> buf })=>RustLib.instance.api.tokioNetUdpSocketTrySend(that: this, buf: buf);


/// Tries to send data on the socket to the given address, but if the send is
/// blocked this will return right away.
///
/// This function is usually paired with `writable()`.
///
/// # Returns
///
/// If successful, returns the number of bytes sent
///
/// Users should ensure that when the remote cannot receive, the
/// [`ErrorKind::WouldBlock`] is properly handled. An error can also occur
/// if the IP version of the socket does not match that of `target`.
///
/// [`ErrorKind::WouldBlock`]: std::io::ErrorKind::WouldBlock
///
/// # Example
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///
///     let dst = "127.0.0.1:8081".parse()?;
///
///     loop {
///         socket.writable().await?;
///
///         match socket.try_send_to(&b"hello world"[..], dst) {
///             Ok(sent) => {
///                 println!("sent {} bytes", sent);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 // Writable false positive.
///                 continue;
///             }
///             Err(e) => return Err(e.into()),
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  trySendTo({required List<int> buf , required SocketAddr target })=>RustLib.instance.api.tokioNetUdpSocketTrySendTo(that: this, buf: buf, target: target);


/// Gets the value of the `IP_TTL` option for this socket.
///
/// For more information about this option, see [`set_ttl`].
///
/// [`set_ttl`]: method@Self::set_ttl
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// # use std::io;
///
/// # async fn dox() -> io::Result<()> {
/// let sock = UdpSocket::bind("127.0.0.1:8080").await?;
///
/// println!("{:?}", sock.ttl()?);
/// # Ok(())
/// # }
/// ```
 Future<int>  ttl()=>RustLib.instance.api.tokioNetUdpSocketTtl(that: this, );


/// Waits for the socket to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is
/// usually paired with `try_send()` or `try_send_to()`.
///
/// The function may complete without the socket being writable. This is a
/// false-positive and attempting a `try_send()` will return with
/// `io::ErrorKind::WouldBlock`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UdpSocket;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Bind socket
///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
///     socket.connect("127.0.0.1:8081").await?;
///
///     loop {
///         // Wait for the socket to be writable
///         socket.writable().await?;
///
///         // Try to send data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_send(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  writable()=>RustLib.instance.api.tokioNetUdpSocketWritable(that: this, );


            }
            @sealed class UidTImpl extends RustOpaque implements UidT {
                // Not to be used by end users
                UidTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UidTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UidT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UidT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UidTPtr,
                );

                
            }
            @sealed class UnixDatagramImpl extends RustOpaque implements UnixDatagram {
                // Not to be used by end users
                UnixDatagramImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UnixDatagramImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UnixDatagram,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UnixDatagram,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UnixDatagramPtr,
                );

                /// Turns a [`tokio::net::UnixDatagram`] into a [`std::os::unix::net::UnixDatagram`].
///
/// The returned [`std::os::unix::net::UnixDatagram`] will have nonblocking
/// mode set as `true`. Use [`set_nonblocking`] to change the blocking mode
/// if needed.
///
/// # Examples
///
/// ```rust,no_run
/// # use std::error::Error;
/// # async fn dox() -> Result<(), Box<dyn Error>> {
/// let tokio_socket = tokio::net::UnixDatagram::bind("/path/to/the/socket")?;
/// let std_socket = tokio_socket.into_std()?;
/// std_socket.set_nonblocking(false)?;
/// # Ok(())
/// # }
/// ```
///
/// [`tokio::net::UnixDatagram`]: UnixDatagram
/// [`std::os::unix::net::UnixDatagram`]: std::os::unix::net::UnixDatagram
/// [`set_nonblocking`]: fn@std::os::unix::net::UnixDatagram::set_nonblocking
 Future<UnixDatagram>  intoStd()=>RustLib.instance.api.tokioNetUnixDatagramIntoStd(that: this, );


/// Returns the local address that this socket is bound to.
///
/// # Examples
/// For a socket bound to a local path
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// use tokio::net::UnixDatagram;
/// use tempfile::tempdir;
///
/// // We use a temporary directory so that the socket
/// // files left by the bound sockets will get cleaned up.
/// let tmp = tempdir()?;
///
/// // Bind socket to a filesystem path
/// let socket_path = tmp.path().join("socket");
/// let socket = UnixDatagram::bind(&socket_path)?;
///
/// assert_eq!(socket.local_addr()?.as_pathname().unwrap(), &socket_path);
///
/// # Ok(())
/// # }
/// ```
///
/// For an unbound socket
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// use tokio::net::UnixDatagram;
///
/// // Create an unbound socket
/// let socket = UnixDatagram::unbound()?;
///
/// assert!(socket.local_addr()?.is_unnamed());
///
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetUnixDatagramLocalAddr(that: this, );


/// Returns the address of this socket's peer.
///
/// The `connect` method will connect the socket to a peer.
///
/// # Examples
/// For a peer with a local path
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// use tokio::net::UnixDatagram;
/// use tempfile::tempdir;
///
/// // Create an unbound socket
/// let tx = UnixDatagram::unbound()?;
///
/// // Create another, bound socket
/// let tmp = tempdir()?;
/// let rx_path = tmp.path().join("rx");
/// let rx = UnixDatagram::bind(&rx_path)?;
///
/// // Connect to the bound socket
/// tx.connect(&rx_path)?;
///
/// assert_eq!(tx.peer_addr()?.as_pathname().unwrap(), &rx_path);
///
/// # Ok(())
/// # }
/// ```
///
/// For an unbound peer
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No SOCK_DGRAM for `socketpair` in miri.
/// use tokio::net::UnixDatagram;
///
/// // Create the pair of sockets
/// let (sock1, sock2) = UnixDatagram::pair()?;
///
/// assert!(sock1.peer_addr()?.is_unnamed());
///
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetUnixDatagramPeerAddr(that: this, );


/// Attempts to receive a single datagram message on the socket from the remote
/// address to which it is `connect`ed.
///
/// The [`connect`] method will connect this socket to a remote address. This method
/// resolves to an error if the socket is not connected.
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(()))` reads data `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`connect`]: method@Self::connect
 Future<PollResult>  pollRecv({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUnixDatagramPollRecv(that: this, cx: cx, buf: buf);


/// Attempts to receive a single datagram on the specified address.
///
/// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
/// `Waker` from the `Context` passed to the most recent call will be scheduled to
/// receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready to read
/// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
 Future<PollResultSocketAddr>  pollRecvFrom({required Context cx , required ReadBuf buf })=>RustLib.instance.api.tokioNetUnixDatagramPollRecvFrom(that: this, cx: cx, buf: buf);


/// Polls for read/receive readiness.
///
/// If the socket is not currently ready for receiving, this method will
/// store a clone of the `Waker` from the provided `Context`. When the
/// socket becomes ready for reading, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_recv_ready`, `poll_recv` or
/// `poll_peek`, only the `Waker` from the `Context` passed to the most
/// recent call is scheduled to receive a wakeup. (However,
/// `poll_send_ready` retains a second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`readable`] is not feasible. Where possible, using [`readable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready for reading.
/// * `Poll::Ready(Ok(()))` if the socket is ready for reading.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`readable`]: method@Self::readable
 Future<PollResult>  pollRecvReady({required Context cx })=>RustLib.instance.api.tokioNetUnixDatagramPollRecvReady(that: this, cx: cx);


/// Attempts to send data on the socket to the remote address to which it
/// was previously `connect`ed.
///
/// The [`connect`] method will connect this socket to a remote address.
/// This method will fail if the socket is not connected.
///
/// Note that on multiple calls to a `poll_*` method in the send direction,
/// only the `Waker` from the `Context` passed to the most recent call will
/// be scheduled to receive a wakeup.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not available to write
/// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`connect`]: method@Self::connect
 Future<PollResultUsize>  pollSend({required Context cx , required List<int> buf })=>RustLib.instance.api.tokioNetUnixDatagramPollSend(that: this, cx: cx, buf: buf);


/// Polls for write/send readiness.
///
/// If the socket is not currently ready for sending, this method will
/// store a clone of the `Waker` from the provided `Context`. When the socket
/// becomes ready for sending, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_send_ready` or `poll_send`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup. (However, `poll_recv_ready` retains a
/// second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`writable`] is not feasible. Where possible, using [`writable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the socket is not ready for writing.
/// * `Poll::Ready(Ok(()))` if the socket is ready for writing.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`writable`]: method@Self::writable
 Future<PollResult>  pollSendReady({required Context cx })=>RustLib.instance.api.tokioNetUnixDatagramPollSendReady(that: this, cx: cx);


/// Waits for the socket to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with `try_recv()`.
///
/// The function may complete without the socket being readable. This is a
/// false-positive and attempting a `try_recv()` will return with
/// `io::ErrorKind::WouldBlock`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///     socket.connect(&server_path)?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv(&mut buf) {
///             Ok(n) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  readable()=>RustLib.instance.api.tokioNetUnixDatagramReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with `try_recv()` or `try_send()`. It
/// can be used to concurrently `recv` / `send` to the same socket on a single
/// task without splitting the socket.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// Concurrently receive from and send to the socket on the same task
/// without splitting.
///
/// ```no_run
/// use tokio::io::Interest;
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///     socket.connect(&server_path)?;
///
///     loop {
///         let ready = socket.ready(Interest::READABLE | Interest::WRITABLE).await?;
///
///         if ready.is_readable() {
///             let mut data = [0; 1024];
///             match socket.try_recv(&mut data[..]) {
///                 Ok(n) => {
///                     println!("received {:?}", &data[..n]);
///                 }
///                 // False-positive, continue
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
///                 Err(e) => {
///                     return Err(e);
///                 }
///             }
///         }
///
///         if ready.is_writable() {
///             // Write some data
///             match socket.try_send(b"hello world") {
///                 Ok(n) => {
///                     println!("sent {} bytes", n);
///                 }
///                 // False-positive, continue
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
///                 Err(e) => {
///                     return Err(e);
///                 }
///             }
///         }
///     }
/// }
/// ```
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetUnixDatagramReady(that: this, interest: interest);


/// Receives data from the socket.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// socket.
///
/// # Examples
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No SOCK_DGRAM for `socketpair` in miri.
/// use tokio::net::UnixDatagram;
///
/// // Create the pair of sockets
/// let (sock1, sock2) = UnixDatagram::pair()?;
///
/// // Since the sockets are paired, the paired send/recv
/// // functions can be used
/// let bytes = b"hello world";
/// sock1.send(bytes).await?;
///
/// let mut buff = vec![0u8; 24];
/// let size = sock2.recv(&mut buff).await?;
///
/// let dgram = &buff[..size];
/// assert_eq!(dgram, bytes);
///
/// # Ok(())
/// # }
/// ```
 Future<BigInt>  recv({required U8 buf })=>RustLib.instance.api.tokioNetUnixDatagramRecv(that: this, buf: buf);


/// Receives data from the socket.
///
/// # Cancel safety
///
/// This method is cancel safe. If `recv_from` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, it is guaranteed that no messages were received on this
/// socket.
///
/// # Examples
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// use tokio::net::UnixDatagram;
/// use tempfile::tempdir;
///
/// // We use a temporary directory so that the socket
/// // files left by the bound sockets will get cleaned up.
/// let tmp = tempdir()?;
///
/// // Bind each socket to a filesystem path
/// let tx_path = tmp.path().join("tx");
/// let tx = UnixDatagram::bind(&tx_path)?;
/// let rx_path = tmp.path().join("rx");
/// let rx = UnixDatagram::bind(&rx_path)?;
///
/// let bytes = b"hello world";
/// tx.send_to(bytes, &rx_path).await?;
///
/// let mut buf = vec![0u8; 24];
/// let (size, addr) = rx.recv_from(&mut buf).await?;
///
/// let dgram = &buf[..size];
/// assert_eq!(dgram, bytes);
/// assert_eq!(addr.as_pathname().unwrap(), &tx_path);
///
/// # Ok(())
/// # }
/// ```
 Future<(BigInt,SocketAddr)>  recvFrom({required U8 buf })=>RustLib.instance.api.tokioNetUnixDatagramRecvFrom(that: this, buf: buf);


/// Sends data on the socket to the socket's peer.
///
/// # Cancel safety
///
/// This method is cancel safe. If `send` is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that the message was not sent.
///
/// # Examples
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No SOCK_DGRAM for `socketpair` in miri.
/// use tokio::net::UnixDatagram;
///
/// // Create the pair of sockets
/// let (sock1, sock2) = UnixDatagram::pair()?;
///
/// // Since the sockets are paired, the paired send/recv
/// // functions can be used
/// let bytes = b"hello world";
/// sock1.send(bytes).await?;
///
/// let mut buff = vec![0u8; 24];
/// let size = sock2.recv(&mut buff).await?;
///
/// let dgram = &buff[..size];
/// assert_eq!(dgram, bytes);
///
/// # Ok(())
/// # }
/// ```
 Future<BigInt>  send({required List<int> buf })=>RustLib.instance.api.tokioNetUnixDatagramSend(that: this, buf: buf);


/// Shuts down the read, write, or both halves of this connection.
///
/// This function will cause all pending and future I/O calls on the
/// specified portions to immediately return with an appropriate value
/// (see the documentation of `Shutdown`).
///
/// # Examples
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No SOCK_DGRAM for `socketpair` in miri.
/// use tokio::net::UnixDatagram;
/// use std::net::Shutdown;
///
/// // Create an unbound socket
/// let (socket, other) = UnixDatagram::pair()?;
///
/// socket.shutdown(Shutdown::Both)?;
///
/// // NOTE: the following commented out code does NOT work as expected.
/// // Due to an underlying issue, the recv call will block indefinitely.
/// // See: https://github.com/tokio-rs/tokio/issues/1679
/// //let mut buff = vec![0u8; 24];
/// //let size = socket.recv(&mut buff).await?;
/// //assert_eq!(size, 0);
///
/// let send_result = socket.send(b"hello world").await;
/// assert!(send_result.is_err());
///
/// # Ok(())
/// # }
/// ```
 Future<void>  shutdown({required Shutdown how })=>RustLib.instance.api.tokioNetUnixDatagramShutdown(that: this, how: how);


/// Returns the value of the `SO_ERROR` option.
///
/// # Examples
/// ```
/// # use std::error::Error;
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn Error>> {
/// # if cfg!(miri) { return Ok(()); } // No `socket` in miri.
/// use tokio::net::UnixDatagram;
///
/// // Create an unbound socket
/// let socket = UnixDatagram::unbound()?;
///
/// if let Ok(Some(err)) = socket.take_error() {
///     println!("Got error: {:?}", err);
/// }
///
/// # Ok(())
/// # }
/// ```
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetUnixDatagramTakeError(that: this, );


/// Tries to receive a datagram from the peer without waiting.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///     socket.connect(&server_path)?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv(&mut buf) {
///             Ok(n) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryRecv({required U8 buf })=>RustLib.instance.api.tokioNetUnixDatagramTryRecv(that: this, buf: buf);


/// Tries to receive data from the socket without waiting.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///
///     loop {
///         // Wait for the socket to be readable
///         socket.readable().await?;
///
///         // The buffer is **not** included in the async task and will
///         // only exist on the stack.
///         let mut buf = [0; 1024];
///
///         // Try to recv data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_recv_from(&mut buf) {
///             Ok((n, _addr)) => {
///                 println!("GOT {:?}", &buf[..n]);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<(BigInt,SocketAddr)>  tryRecvFrom({required U8 buf })=>RustLib.instance.api.tokioNetUnixDatagramTryRecvFrom(that: this, buf: buf);


/// Tries to send a datagram to the peer without waiting.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///     socket.connect(&server_path)?;
///
///     loop {
///         // Wait for the socket to be writable
///         socket.writable().await?;
///
///         // Try to send data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_send(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  trySend({required List<int> buf })=>RustLib.instance.api.tokioNetUnixDatagramTrySend(that: this, buf: buf);


/// Waits for the socket to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is
/// usually paired with `try_send()` or `try_send_to()`.
///
/// The function may complete without the socket being writable. This is a
/// false-positive and attempting a `try_send()` will return with
/// `io::ErrorKind::WouldBlock`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixDatagram;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let dir = tempfile::tempdir().unwrap();
///     let client_path = dir.path().join("client.sock");
///     let server_path = dir.path().join("server.sock");
///     let socket = UnixDatagram::bind(&client_path)?;
///     socket.connect(&server_path)?;
///
///     loop {
///         // Wait for the socket to be writable
///         socket.writable().await?;
///
///         // Try to send data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match socket.try_send(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e);
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  writable()=>RustLib.instance.api.tokioNetUnixDatagramWritable(that: this, );


            }
            @sealed class UnixListenerImpl extends RustOpaque implements UnixListener {
                // Not to be used by end users
                UnixListenerImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UnixListenerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UnixListener,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UnixListener,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UnixListenerPtr,
                );

                /// Accepts a new incoming connection to this listener.
///
/// # Cancel safety
///
/// This method is cancel safe. If the method is used as the event in a
/// [`tokio::select!`](crate::select) statement and some other branch
/// completes first, then it is guaranteed that no new connections were
/// accepted by this method.
 Future<(UnixStream,SocketAddr)>  accept()=>RustLib.instance.api.tokioNetUnixListenerAccept(that: this, );


/// Turns a [`tokio::net::UnixListener`] into a [`std::os::unix::net::UnixListener`].
///
/// The returned [`std::os::unix::net::UnixListener`] will have nonblocking mode
/// set as `true`. Use [`set_nonblocking`] to change the blocking mode if needed.
///
/// # Examples
///
/// ```rust,no_run
/// # use std::error::Error;
/// # async fn dox() -> Result<(), Box<dyn Error>> {
/// let tokio_listener = tokio::net::UnixListener::bind("/path/to/the/socket")?;
/// let std_listener = tokio_listener.into_std()?;
/// std_listener.set_nonblocking(false)?;
/// # Ok(())
/// # }
/// ```
///
/// [`tokio::net::UnixListener`]: UnixListener
/// [`std::os::unix::net::UnixListener`]: std::os::unix::net::UnixListener
/// [`set_nonblocking`]: fn@std::os::unix::net::UnixListener::set_nonblocking
 Future<UnixListener>  intoStd()=>RustLib.instance.api.tokioNetUnixListenerIntoStd(that: this, );


/// Returns the local socket address of this listener.
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetUnixListenerLocalAddr(that: this, );


/// Polls to accept a new incoming connection to this listener.
///
/// If there is no connection to accept, `Poll::Pending` is returned and the
/// current task will be notified by a waker.  Note that on multiple calls
/// to `poll_accept`, only the `Waker` from the `Context` passed to the most
/// recent call is scheduled to receive a wakeup.
 Future<PollResultUnixStreamSocketAddr>  pollAccept({required Context cx })=>RustLib.instance.api.tokioNetUnixListenerPollAccept(that: this, cx: cx);


/// Returns the value of the `SO_ERROR` option.
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetUnixListenerTakeError(that: this, );


            }
            @sealed class UnixSocketImpl extends RustOpaque implements UnixSocket {
                // Not to be used by end users
                UnixSocketImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UnixSocketImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UnixSocket,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UnixSocket,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UnixSocketPtr,
                );

                /// Converts the socket into a [`UnixDatagram`].
///
/// Calling this function on a socket created by [`new_stream`] will return an error.
///
/// [`new_stream`]: `UnixSocket::new_stream`
 Future<UnixDatagram>  datagram()=>RustLib.instance.api.tokioNetUnixSocketDatagram(that: this, );


/// Converts the socket into a `UnixListener`.
///
/// `backlog` defines the maximum number of pending connections are queued
/// by the operating system at any given time. Connection are removed from
/// the queue with [`UnixListener::accept`]. When the queue is full, the
/// operating-system will start rejecting connections.
///
/// Calling this function on a socket created by [`new_datagram`] will return an error.
///
/// This calls the `listen(2)` operating-system function, marking the socket
/// as a passive socket.
///
/// [`new_datagram`]: `UnixSocket::new_datagram`
 Future<UnixListener>  listen({required int backlog })=>RustLib.instance.api.tokioNetUnixSocketListen(that: this, backlog: backlog);


            }
            @sealed class UnixStreamImpl extends RustOpaque implements UnixStream {
                // Not to be used by end users
                UnixStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                UnixStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_UnixStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_UnixStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_UnixStreamPtr,
                );

                /// Splits a `UnixStream` into a read half and a write half, which can be used
/// to read and write the stream concurrently.
///
/// Unlike [`split`], the owned halves can be moved to separate tasks, however
/// this comes at the cost of a heap allocation.
///
/// **Note:** Dropping the write half will only shut down the write half of the
/// stream. This is equivalent to calling [`shutdown()`] on the `UnixStream`.
///
/// [`split`]: Self::split()
/// [`shutdown()`]: fn@crate::io::AsyncWriteExt::shutdown
 Future<(OwnedReadHalf,OwnedWriteHalf)>  intoSplit()=>RustLib.instance.api.tokioNetUnixStreamIntoSplit(that: this, );


/// Turns a [`tokio::net::UnixStream`] into a [`std::os::unix::net::UnixStream`].
///
/// The returned [`std::os::unix::net::UnixStream`] will have nonblocking
/// mode set as `true`.  Use [`set_nonblocking`] to change the blocking
/// mode if needed.
///
/// # Examples
///
/// ```
/// use std::error::Error;
/// use std::io::Read;
/// use tokio::net::UnixListener;
/// # use tokio::net::UnixStream;
/// # use tokio::io::AsyncWriteExt;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
/// #   if cfg!(miri) { return Ok(()); } // No `socket` in miri.
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///
///     let mut data = [0u8; 12];
///     let listener = UnixListener::bind(&bind_path)?;
/// #   let handle = tokio::spawn(async {
/// #       let mut stream = UnixStream::connect(bind_path).await.unwrap();
/// #       stream.write(b"Hello world!").await.unwrap();
/// #   });
///     let (tokio_unix_stream, _) = listener.accept().await?;
///     let mut std_unix_stream = tokio_unix_stream.into_std()?;
/// #   handle.await.expect("The task being joined has panicked");
///     std_unix_stream.set_nonblocking(false)?;
///     std_unix_stream.read_exact(&mut data)?;
/// #   assert_eq!(b"Hello world!", &data);
///     Ok(())
/// }
/// ```
/// [`tokio::net::UnixStream`]: UnixStream
/// [`std::os::unix::net::UnixStream`]: std::os::unix::net::UnixStream
/// [`set_nonblocking`]: fn@std::os::unix::net::UnixStream::set_nonblocking
 Future<UnixStream>  intoStd()=>RustLib.instance.api.tokioNetUnixStreamIntoStd(that: this, );


/// Returns the socket address of the local half of this connection.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let dir = tempfile::tempdir().unwrap();
/// let bind_path = dir.path().join("bind_path");
/// let stream = UnixStream::connect(bind_path).await?;
///
/// println!("{:?}", stream.local_addr()?);
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  localAddr()=>RustLib.instance.api.tokioNetUnixStreamLocalAddr(that: this, );


/// Returns the socket address of the remote half of this connection.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
///
/// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
/// let dir = tempfile::tempdir().unwrap();
/// let bind_path = dir.path().join("bind_path");
/// let stream = UnixStream::connect(bind_path).await?;
///
/// println!("{:?}", stream.peer_addr()?);
/// # Ok(())
/// # }
/// ```
 Future<SocketAddr>  peerAddr()=>RustLib.instance.api.tokioNetUnixStreamPeerAddr(that: this, );


/// Returns effective credentials of the process which called `connect` or `pair`.
 Future<UCred>  peerCred()=>RustLib.instance.api.tokioNetUnixStreamPeerCred(that: this, );


/// Polls for read readiness.
///
/// If the unix stream is not currently ready for reading, this method will
/// store a clone of the `Waker` from the provided `Context`. When the unix
/// stream becomes ready for reading, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_read_ready` or `poll_read`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup. (However, `poll_write_ready` retains a
/// second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`readable`] is not feasible. Where possible, using [`readable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the unix stream is not ready for reading.
/// * `Poll::Ready(Ok(()))` if the unix stream is ready for reading.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`readable`]: method@Self::readable
 Future<PollResult>  pollReadReady({required Context cx })=>RustLib.instance.api.tokioNetUnixStreamPollReadReady(that: this, cx: cx);


/// Polls for write readiness.
///
/// If the unix stream is not currently ready for writing, this method will
/// store a clone of the `Waker` from the provided `Context`. When the unix
/// stream becomes ready for writing, `Waker::wake` will be called on the
/// waker.
///
/// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
/// the `Waker` from the `Context` passed to the most recent call is
/// scheduled to receive a wakeup. (However, `poll_read_ready` retains a
/// second, independent waker.)
///
/// This function is intended for cases where creating and pinning a future
/// via [`writable`] is not feasible. Where possible, using [`writable`] is
/// preferred, as this supports polling from multiple tasks at once.
///
/// # Return value
///
/// The function returns:
///
/// * `Poll::Pending` if the unix stream is not ready for writing.
/// * `Poll::Ready(Ok(()))` if the unix stream is ready for writing.
/// * `Poll::Ready(Err(e))` if an error is encountered.
///
/// # Errors
///
/// This function may encounter any standard I/O error except `WouldBlock`.
///
/// [`writable`]: method@Self::writable
 Future<PollResult>  pollWriteReady({required Context cx })=>RustLib.instance.api.tokioNetUnixStreamPollWriteReady(that: this, cx: cx);


/// Waits for the socket to become readable.
///
/// This function is equivalent to `ready(Interest::READABLE)` and is usually
/// paired with `try_read()`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     let mut msg = vec![0; 1024];
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read(&mut msg) {
///             Ok(n) => {
///                 msg.truncate(n);
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     println!("GOT = {:?}", msg);
///     Ok(())
/// }
/// ```
 Future<void>  readable()=>RustLib.instance.api.tokioNetUnixStreamReadable(that: this, );


/// Waits for any of the requested ready states.
///
/// This function is usually paired with `try_read()` or `try_write()`. It
/// can be used to concurrently read / write to the same socket on a single
/// task without splitting the socket.
///
/// The function may complete without the socket being ready. This is a
/// false-positive and attempting an operation will return with
/// `io::ErrorKind::WouldBlock`. The function can also return with an empty
/// [`Ready`] set, so you should always check the returned value and possibly
/// wait again if the requested states are not set.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to read or write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// Concurrently read and write to the stream on the same task without
/// splitting.
///
/// ```no_run
/// use tokio::io::Interest;
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     loop {
///         let ready = stream.ready(Interest::READABLE | Interest::WRITABLE).await?;
///
///         if ready.is_readable() {
///             let mut data = vec![0; 1024];
///             // Try to read data, this may still fail with `WouldBlock`
///             // if the readiness event is a false positive.
///             match stream.try_read(&mut data) {
///                 Ok(n) => {
///                     println!("read {} bytes", n);
///                 }
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                     continue;
///                 }
///                 Err(e) => {
///                     return Err(e.into());
///                 }
///             }
///
///         }
///
///         if ready.is_writable() {
///             // Try to write data, this may still fail with `WouldBlock`
///             // if the readiness event is a false positive.
///             match stream.try_write(b"hello world") {
///                 Ok(n) => {
///                     println!("write {} bytes", n);
///                 }
///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                     continue;
///                 }
///                 Err(e) => {
///                     return Err(e.into());
///                 }
///             }
///         }
///     }
/// }
/// ```
 Future<Ready>  ready({required Interest interest })=>RustLib.instance.api.tokioNetUnixStreamReady(that: this, interest: interest);


/// Returns the value of the `SO_ERROR` option.
 Future<Error?>  takeError()=>RustLib.instance.api.tokioNetUnixStreamTakeError(that: this, );


/// Try to read data from the stream into the provided buffer, returning how
/// many bytes were read.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read()` is non-blocking, the buffer does not have to be stored by
/// the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`readable()`]: UnixStream::readable()
/// [`ready()`]: UnixStream::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
///
/// 1. The stream's read half is closed and will no longer yield data.
/// 2. The specified buffer was 0 bytes in length.
///
/// If the stream is not ready to read data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Creating the buffer **after** the `await` prevents it from
///         // being stored in the async task.
///         let mut buf = [0; 4096];
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read(&mut buf) {
///             Ok(0) => break,
///             Ok(n) => {
///                 println!("read {} bytes", n);
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryRead({required U8 buf })=>RustLib.instance.api.tokioNetUnixStreamTryRead(that: this, buf: buf);


/// Tries to read data from the stream into the provided buffers, returning
/// how many bytes were read.
///
/// Data is copied to fill each buffer in order, with the final buffer
/// written to possibly being only partially filled. This method behaves
/// equivalently to a single call to [`try_read()`] with concatenated
/// buffers.
///
/// Receives any pending data from the socket but does not wait for new data
/// to arrive. On success, returns the number of bytes read. Because
/// `try_read_vectored()` is non-blocking, the buffer does not have to be
/// stored by the async task and can exist entirely on the stack.
///
/// Usually, [`readable()`] or [`ready()`] is used with this function.
///
/// [`try_read()`]: UnixStream::try_read()
/// [`readable()`]: UnixStream::readable()
/// [`ready()`]: UnixStream::ready()
///
/// # Return
///
/// If data is successfully read, `Ok(n)` is returned, where `n` is the
/// number of bytes read. `Ok(0)` indicates the stream's read half is closed
/// and will no longer yield data. If the stream is not ready to read data
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io::{self, IoSliceMut};
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     loop {
///         // Wait for the socket to be readable
///         stream.readable().await?;
///
///         // Creating the buffer **after** the `await` prevents it from
///         // being stored in the async task.
///         let mut buf_a = [0; 512];
///         let mut buf_b = [0; 1024];
///         let mut bufs = [
///             IoSliceMut::new(&mut buf_a),
///             IoSliceMut::new(&mut buf_b),
///         ];
///
///         // Try to read data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_read_vectored(&mut bufs) {
///             Ok(0) => break,
///             Ok(n) => {
///                 println!("read {} bytes", n);
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryReadVectored({required IoSliceMut bufs })=>RustLib.instance.api.tokioNetUnixStreamTryReadVectored(that: this, bufs: bufs);


/// Tries to write a buffer to the stream, returning how many bytes were
/// written.
///
/// The function will attempt to write the entire contents of `buf`, but
/// only part of the buffer may be written.
///
/// This function is usually paired with `writable()`.
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWrite({required List<int> buf })=>RustLib.instance.api.tokioNetUnixStreamTryWrite(that: this, buf: buf);


/// Tries to write several buffers to the stream, returning how many bytes
/// were written.
///
/// Data is written from each buffer in order, with the final buffer read
/// from possible being only partially consumed. This method behaves
/// equivalently to a single call to [`try_write()`] with concatenated
/// buffers.
///
/// This function is usually paired with `writable()`.
///
/// [`try_write()`]: UnixStream::try_write()
///
/// # Return
///
/// If data is successfully written, `Ok(n)` is returned, where `n` is the
/// number of bytes written. If the stream is not ready to write data,
/// `Err(io::ErrorKind::WouldBlock)` is returned.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write_vectored(&bufs) {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<BigInt>  tryWriteVectored({required List<IoSlice> buf })=>RustLib.instance.api.tokioNetUnixStreamTryWriteVectored(that: this, buf: buf);


/// Waits for the socket to become writable.
///
/// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
/// paired with `try_write()`.
///
/// # Cancel safety
///
/// This method is cancel safe. Once a readiness event occurs, the method
/// will continue to return immediately until the readiness event is
/// consumed by an attempt to write that fails with `WouldBlock` or
/// `Poll::Pending`.
///
/// # Examples
///
/// ```no_run
/// use tokio::net::UnixStream;
/// use std::error::Error;
/// use std::io;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn Error>> {
///     // Connect to a peer
///     let dir = tempfile::tempdir().unwrap();
///     let bind_path = dir.path().join("bind_path");
///     let stream = UnixStream::connect(bind_path).await?;
///
///     loop {
///         // Wait for the socket to be writable
///         stream.writable().await?;
///
///         // Try to write data, this may still fail with `WouldBlock`
///         // if the readiness event is a false positive.
///         match stream.try_write(b"hello world") {
///             Ok(n) => {
///                 break;
///             }
///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
///                 continue;
///             }
///             Err(e) => {
///                 return Err(e.into());
///             }
///         }
///     }
///
///     Ok(())
/// }
/// ```
 Future<void>  writable()=>RustLib.instance.api.tokioNetUnixStreamWritable(that: this, );


            }
            @sealed class ValueImpl extends RustOpaque implements Value {
                // Not to be used by end users
                ValueImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ValueImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Value,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Value,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ValuePtr,
                );

                
            }
            @sealed class ValueTypeImpl extends RustOpaque implements ValueType {
                // Not to be used by end users
                ValueTypeImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ValueTypeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ValueType,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ValueType,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ValueTypePtr,
                );

                
            }
            @sealed class VecTImpl extends RustOpaque implements VecT {
                // Not to be used by end users
                VecTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                VecTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_VecT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_VecT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_VecTPtr,
                );

                
            }
            @sealed class WeakSenderTImpl extends RustOpaque implements WeakSenderT {
                // Not to be used by end users
                WeakSenderTImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WeakSenderTImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WeakSenderT,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WeakSenderT,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WeakSenderTPtr,
                );

                
            }
            @sealed class WriteF32LeMutSelfImpl extends RustOpaque implements WriteF32LeMutSelf {
                // Not to be used by end users
                WriteF32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteF32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteF32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF32LeMutSelfPtr,
                );

                
            }
            @sealed class WriteF32MutSelfImpl extends RustOpaque implements WriteF32MutSelf {
                // Not to be used by end users
                WriteF32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteF32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteF32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF32MutSelfPtr,
                );

                
            }
            @sealed class WriteF64LeMutSelfImpl extends RustOpaque implements WriteF64LeMutSelf {
                // Not to be used by end users
                WriteF64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteF64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteF64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF64LeMutSelfPtr,
                );

                
            }
            @sealed class WriteF64MutSelfImpl extends RustOpaque implements WriteF64MutSelf {
                // Not to be used by end users
                WriteF64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteF64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteF64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteF64MutSelfPtr,
                );

                
            }
            @sealed class WriteHalfSimplexStreamImpl extends RustOpaque implements WriteHalfSimplexStream {
                // Not to be used by end users
                WriteHalfSimplexStreamImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteHalfSimplexStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteHalfSimplexStream,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteHalfSimplexStream,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteHalfSimplexStreamPtr,
                );

                
            }
            @sealed class WriteI128LeMutSelfImpl extends RustOpaque implements WriteI128LeMutSelf {
                // Not to be used by end users
                WriteI128LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI128LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI128LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI128LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI128LeMutSelfPtr,
                );

                
            }
            @sealed class WriteI128MutSelfImpl extends RustOpaque implements WriteI128MutSelf {
                // Not to be used by end users
                WriteI128MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI128MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI128MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI128MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI128MutSelfPtr,
                );

                
            }
            @sealed class WriteI16LeMutSelfImpl extends RustOpaque implements WriteI16LeMutSelf {
                // Not to be used by end users
                WriteI16LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI16LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI16LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI16LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI16LeMutSelfPtr,
                );

                
            }
            @sealed class WriteI16MutSelfImpl extends RustOpaque implements WriteI16MutSelf {
                // Not to be used by end users
                WriteI16MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI16MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI16MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI16MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI16MutSelfPtr,
                );

                
            }
            @sealed class WriteI32LeMutSelfImpl extends RustOpaque implements WriteI32LeMutSelf {
                // Not to be used by end users
                WriteI32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI32LeMutSelfPtr,
                );

                
            }
            @sealed class WriteI32MutSelfImpl extends RustOpaque implements WriteI32MutSelf {
                // Not to be used by end users
                WriteI32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI32MutSelfPtr,
                );

                
            }
            @sealed class WriteI64LeMutSelfImpl extends RustOpaque implements WriteI64LeMutSelf {
                // Not to be used by end users
                WriteI64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI64LeMutSelfPtr,
                );

                
            }
            @sealed class WriteI64MutSelfImpl extends RustOpaque implements WriteI64MutSelf {
                // Not to be used by end users
                WriteI64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI64MutSelfPtr,
                );

                
            }
            @sealed class WriteI8MutSelfImpl extends RustOpaque implements WriteI8MutSelf {
                // Not to be used by end users
                WriteI8MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteI8MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteI8MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI8MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteI8MutSelfPtr,
                );

                
            }
            @sealed class WriteU128LeMutSelfImpl extends RustOpaque implements WriteU128LeMutSelf {
                // Not to be used by end users
                WriteU128LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU128LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU128LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU128LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU128LeMutSelfPtr,
                );

                
            }
            @sealed class WriteU128MutSelfImpl extends RustOpaque implements WriteU128MutSelf {
                // Not to be used by end users
                WriteU128MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU128MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU128MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU128MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU128MutSelfPtr,
                );

                
            }
            @sealed class WriteU16LeMutSelfImpl extends RustOpaque implements WriteU16LeMutSelf {
                // Not to be used by end users
                WriteU16LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU16LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU16LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU16LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU16LeMutSelfPtr,
                );

                
            }
            @sealed class WriteU16MutSelfImpl extends RustOpaque implements WriteU16MutSelf {
                // Not to be used by end users
                WriteU16MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU16MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU16MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU16MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU16MutSelfPtr,
                );

                
            }
            @sealed class WriteU32LeMutSelfImpl extends RustOpaque implements WriteU32LeMutSelf {
                // Not to be used by end users
                WriteU32LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU32LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU32LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU32LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU32LeMutSelfPtr,
                );

                
            }
            @sealed class WriteU32MutSelfImpl extends RustOpaque implements WriteU32MutSelf {
                // Not to be used by end users
                WriteU32MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU32MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU32MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU32MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU32MutSelfPtr,
                );

                
            }
            @sealed class WriteU64LeMutSelfImpl extends RustOpaque implements WriteU64LeMutSelf {
                // Not to be used by end users
                WriteU64LeMutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU64LeMutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU64LeMutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU64LeMutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU64LeMutSelfPtr,
                );

                
            }
            @sealed class WriteU64MutSelfImpl extends RustOpaque implements WriteU64MutSelf {
                // Not to be used by end users
                WriteU64MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU64MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU64MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU64MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU64MutSelfPtr,
                );

                
            }
            @sealed class WriteU8MutSelfImpl extends RustOpaque implements WriteU8MutSelf {
                // Not to be used by end users
                WriteU8MutSelfImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WriteU8MutSelfImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_WriteU8MutSelf,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU8MutSelf,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WriteU8MutSelfPtr,
                );

                
            }