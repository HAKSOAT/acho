// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FilterSparse`, `RangeF32`, `RangeF64`, `RangeI16`, `RangeI32`, `RangeI64`, `RangeI8`, `RangeU16`, `RangeU32`, `RangeU64`, `RangeU8`, `ResultSortIndex`, `SearchResult`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `search_shard`, `search`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FacetFilter>>
abstract class FacetFilter implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FacetValue>>
abstract class FacetValue implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QueryFacet>>
abstract class QueryFacet implements RustOpaqueInterface {
  static Future<QueryFacet> default_() =>
      RustLib.instance.api.seekstormSearchQueryFacetDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QueryRewriting>>
abstract class QueryRewriting implements RustOpaqueInterface {
  static Future<QueryRewriting> default_() =>
      RustLib.instance.api.seekstormSearchQueryRewritingDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ranges>>
abstract class Ranges implements RustOpaqueInterface {
  static Future<Ranges> default_() =>
      RustLib.instance.api.seekstormSearchRangesDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResultObject>>
abstract class ResultObject implements RustOpaqueInterface {
  AHashMapStringFacet get facets;

  String get originalQuery;

  String get query;

  List<String> get queryTerms;

  BigInt get resultCount;

  BigInt get resultCountTotal;

  List<Result> get results;

  List<String> get suggestions;

  set facets(AHashMapStringFacet facets);

  set originalQuery(String originalQuery);

  set query(String query);

  set queryTerms(List<String> queryTerms);

  set resultCount(BigInt resultCount);

  set resultCountTotal(BigInt resultCountTotal);

  set results(List<Result> results);

  set suggestions(List<String> suggestions);

  static Future<ResultObject> default_() =>
      RustLib.instance.api.seekstormSearchResultObjectDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResultSort>>
abstract class ResultSort implements RustOpaqueInterface {
  FacetValue get base;

  String get field;

  SortOrder get order;

  set base(FacetValue base);

  set field(String field);

  set order(SortOrder order);
}

abstract class Search {
  /// Search the index for all indexed documents, both for committed and uncommitted documents.
  /// The latter enables true realtime search: documents are available for search in exact the same millisecond they are indexed.
  /// Arguments:
  /// * `query_string`: query string `+` `-` `""` search operators are recognized.
  /// * `query_type_default`: Specifiy default QueryType:
  ///   * **Union**, disjunction, OR,
  ///   * **Intersection**,  conjunction, AND, `+`,
  ///   * **Phrase** `""`,
  ///   * **Not**, except, minus `-`.
  ///
  ///   The default QueryType is superseded if the query parser detects that a different query type is specified within the query string (`+` `-` `""`).
  ///
  ///   Boolean queries are specified in the search method either via the query_type parameter or via operator chars within the query parameter.
  ///   The interpretation of operator chars within the query string (set `query_type=QueryType::Union`) allows to specify advanced search operations via a simple search box.
  ///
  /// Intersection, AND `+`
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Union;
  /// let query_string="+red +apple".to_string();
  /// ```
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Intersection;
  /// let query_string="red apple".to_string();
  /// ```
  /// Union, OR
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Union;
  /// let query_string="red apple".to_string();
  /// ```
  /// Phrase `""`
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Union;
  /// let query_string="\"red apple\"".to_string();
  /// ```
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Phrase;
  /// let query_string="red apple".to_string();
  /// ```
  /// Except, minus, NOT `-`
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Union;
  /// let query_string="apple -red".to_string();
  /// ```
  /// Mixed phrase and intersection
  /// ```rust ,no_run
  /// use seekstorm::search::QueryType;
  /// let query_type=QueryType::Union;
  /// let query_string="+\"the who\" +uk".to_string();
  /// ```
  /// * `offset`: offset of search results to return.
  /// * `length`: number of search results to return.
  ///   With length=0, resultType::TopkCount will be automatically downgraded to resultType::Count, returning the number of results only, without returning the results itself.
  /// * `result_type`: type of search results to return: Count, Topk, TopkCount.
  /// * `include_uncommited`: true realtime search: include indexed documents which where not yet committed into search results.
  /// * `field_filter`: Specify field names where to search at querytime, whereas SchemaField.indexed is set at indextime. If set to Vec::new() then all indexed fields are searched.
  /// * `query_facets`: Must be set if facets should be returned in ResultObject. If set to Vec::new() then no facet fields are returned.
  ///   Facet fields are only collected, counted and returned for ResultType::Count and ResultType::TopkCount, but not for ResultType::Topk.
  ///   The prefix property of a QueryFacet allows at query time to filter the returned facet values to those matching a given prefix, if there are too many distinct values per facet field.
  ///   The length property of a QueryFacet allows at query time limiting the number of returned distinct values per facet field, if there are too many distinct values.  The QueryFacet can be used to improve the usability in an UI.
  ///   If the length property of a QueryFacet is set to 0 then no facet values for that facet are collected, counted and returned at query time. That decreases the query latency significantly.
  ///   The facet values are sorted by the frequency of the appearance of the value within the indexed documents matching the query in descending order.
  ///   Examples:
  ///   query_facets = vec![QueryFacet::String16 {field: "language".into(),prefix: "ger".into(),length: 5},QueryFacet::String16 {field: "brand".into(),prefix: "a".into(),length: 5}];
  ///   query_facets = vec![QueryFacet::U8 {field: "age".into(), range_type: RangeType::CountWithinRange, ranges: vec![("0-20".into(), 0),("20-40".into(), 20), ("40-60".into(), 40),("60-80".into(), 60), ("80-100".into(), 80)]}];
  ///   query_facets = vec![QueryFacet::Point {field: "location".into(),base:vec![38.8951, -77.0364],unit:DistanceUnit::Kilometers,range_type: RangeType::CountWithinRange,ranges: vec![ ("0-200".into(), 0.0),("200-400".into(), 200.0), ("400-600".into(), 400.0), ("600-800".into(), 600.0), ("800-1000".into(), 800.0)]}];
  /// * `facet_filter`: Search results are filtered to documents matching specific string values or numerical ranges in the facet fields. If set to Vec::new() then result are not facet filtered.
  ///   The filter parameter filters the returned results to those documents both matching the query AND matching for all (boolean AND) stated facet filter fields at least one (boolean OR) of the stated values.
  ///   If the query is changed then both facet counts and search results are changed. If the facet filter is changed then only the search results are changed, while facet counts remain unchanged.
  ///   The facet counts depend only from the query and not which facet filters are selected.
  ///   Examples:
  ///   facet_filter=vec![FacetFilter::String{field:"language".into(),filter:vec!["german".into()]},FacetFilter::String{field:"brand".into(),filter:vec!["apple".into(),"google".into()]}];
  ///   facet_filter=vec![FacetFilter::U8{field:"age".into(),filter: 21..65}];
  ///   facet_filter = vec![FacetFilter::Point {field: "location".into(),filter: (vec![38.8951, -77.0364], 0.0..1000.0, DistanceUnit::Kilometers)}];
  /// * `result_sort`: Sort field and order: Search results are sorted by the specified facet field, either in ascending or descending order.
  ///   If no sort field is specified, then the search results are sorted by rank in descending order per default.
  ///   Multiple sort fields are combined by a "sort by, then sort by"-method ("tie-breaking"-algorithm).
  ///   The results are sorted by the first field, and only for those results where the first field value is identical (tie) the results are sub-sorted by the second field,
  ///   until the n-th field value is either not equal or the last field is reached.
  ///   A special _score field (BM25x), reflecting how relevant the result is for a given search query (phrase match, match in title etc.) can be combined with any of the other sort fields as primary, secondary or n-th search criterium.
  ///   Sort is only enabled on facet fields that are defined in schema at create_index!
  ///   Examples:
  ///   result_sort = vec![ResultSort {field: "price".into(), order: SortOrder::Descending, base: FacetValue::None},ResultSort {field: "language".into(), order: SortOrder::Ascending, base: FacetValue::None}];
  ///   result_sort = vec![ResultSort {field: "location".into(),order: SortOrder::Ascending, base: FacetValue::Point(vec![38.8951, -77.0364])}];
  /// * `query_rewriting`: Enables query rewriting features such as spelling correction and query auto-completion (QAC).
  ///   The spelling correction of multi-term query strings handles three cases:
  ///     1. mistakenly inserted space into a correct term led to two incorrect terms: `hels inki` -> `helsinki`
  ///     2. mistakenly omitted space between two correct terms led to one incorrect combined term: `modernart` -> `modern art`
  ///     3. multiple independent input terms with/without spelling errors: `cinese indastrialication` -> `chinese industrialization`
  ///
  ///   Query correction/completion supports phrases "", but is disabled, if +- operators are used,  or if a opening quote is used after the first term, or if a closing quote is used before the last term.
  ///   See QueryRewriting enum for details.
  ///   ⚠️ In addition to setting the query_rewriting parameter per query, the incremental creation of the Symspell dictionary during the indexing of documents has to be enabled via the create_index parameter `meta.spelling_correction`.
  ///
  /// Facets:
  ///   If query_string is empty, then index facets (collected at index time) are returned, otherwise query facets (collected at query time) are returned.
  ///   Facets are defined in 3 different places:
  ///   the facet fields are defined in schema at create_index,
  ///   the facet field values are set in index_document at index time,
  ///   the query_facets/facet_filter search parameters are specified at query time.
  ///   Facets are then returned in the search result object.
  Future<ResultObject> search(
      {required String queryString,
      required QueryType queryTypeDefault,
      required BigInt offset,
      required BigInt length,
      required ResultType resultType,
      required bool includeUncommited,
      required List<String> fieldFilter,
      required List<QueryFacet> queryFacets,
      required List<FacetFilter> facetFilter,
      required List<ResultSort> resultSort,
      required QueryRewriting queryRewriting});
}

abstract class SearchShard {
  Future<ResultObject> searchShard(
      {required String queryString,
      required QueryType queryTypeDefault,
      required BigInt offset,
      required BigInt length,
      required ResultType resultType,
      required bool includeUncommited,
      required List<String> fieldFilter,
      required List<QueryFacet> queryFacets,
      required List<FacetFilter> facetFilter,
      required List<ResultSort> resultSort});
}

/// Specifies the default QueryType: The following query types are supported:
/// - **Union** (OR, disjunction),
/// - **Intersection** (AND, conjunction),
/// - **Phrase** (""),
/// - **Not** (-).
///
/// The default QueryType is superseded if the query parser detects that a different query type is specified within the query string (+ - "").
enum QueryType {
  /// Union (OR, disjunction)
  union,

  /// Intersection (AND, conjunction)
  intersection,

  /// Phrase ("")
  phrase,

  /// Not (-)
  not,
  ;

  static Future<QueryType> default_() =>
      RustLib.instance.api.seekstormSearchQueryTypeDefault();
}

/// specifies how to count the frequency of numerical facet field values
enum RangeType {
  /// within the specified range
  countWithinRange,

  /// within the range and all ranges above
  countAboveRange,

  /// within the range and all ranges below
  countBelowRange,
  ;

  static Future<RangeType> default_() =>
      RustLib.instance.api.seekstormSearchRangeTypeDefault();
}

/// The following result types are supported:
/// - **Count** (count all results that match the query, but returning top-k results is not required)
/// - **Topk** (returns the top-k results per query, but counting all results that match the query is not required)
/// - **TopkCount** (returns the top-k results per query + count all results that match the query)
enum ResultType {
  /// Count all results that match the query, without returning top-k results
  count,

  /// Return the top-k results per query, without counting all results that match the query
  topk,

  /// Return the top-k results per query and count all results that match the query
  topkCount,
  ;

  static Future<ResultType> default_() =>
      RustLib.instance.api.seekstormSearchResultTypeDefault();
}

/// Specifies the sort order for the search results.
enum SortOrder {
  /// Ascending sort order
  ascending,

  /// Descending sort order
  descending,
  ;
}
