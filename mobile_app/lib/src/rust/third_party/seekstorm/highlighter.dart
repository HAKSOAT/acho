// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Fragment`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `compose`, `fmt`, `fmt`, `name`, `schemas`

/// Returns the Highlighter object used as get_document parameter for highlighting fields in documents
Future<Highlighter> highlighter(
        {required ArcIndex indexArc,
        required List<Highlight> highlights,
        required List<String> queryTermsVec}) =>
    RustLib.instance.api.seekstormHighlighterHighlighter(
        indexArc: indexArc,
        highlights: highlights,
        queryTermsVec: queryTermsVec);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Highlighter>>
abstract class Highlighter implements RustOpaqueInterface {}

/// Specifies the number and size of fragments (snippets, summaries) to generate from each specified field to provide a "keyword in context" (KWIC) functionality.
/// With highlight_markup the matching query terms within the fragments can be highlighted with HTML markup.
class Highlight {
  /// Specifies the field from which the fragments  (snippets, summaries) are created.
  final String field;

  /// Allows to specifiy multiple highlight result fields from the same source field, leaving the original field intact,
  /// Default: if name is empty then field is used instead, i.e the original field is overwritten with the highlight.
  final String name;

  /// If 0/default then return the full original text without fragmenting.
  final BigInt fragmentNumber;

  /// Specifies the length of a highlight fragment.
  /// The default 0 returns the full original text without truncating, but still with highlighting if highlight_markup is enabled.
  final BigInt fragmentSize;

  /// if true, the matching query terms within the fragments are highlighted with HTML markup **\<b\>term\<\/b\>**.
  final bool highlightMarkup;

  /// Specifies the markup tags to insert **before** each highlighted term (e.g. \"\<b\>\" or \"\<em\>\"). This can be any string, but is most often an HTML or XML tag.
  /// Only used when **highlight_markup** is set to true.
  final String preTags;

  /// Specifies the markup tags to insert **after** each highlighted term. (e.g. \"\<\/b\>\" or \"\<\/em\>\"). This can be any string, but is most often an HTML or XML tag.
  /// Only used when **highlight_markup** is set to true.
  final String postTags;

  const Highlight({
    required this.field,
    required this.name,
    required this.fragmentNumber,
    required this.fragmentSize,
    required this.highlightMarkup,
    required this.preTags,
    required this.postTags,
  });

  static Future<Highlight> default_() =>
      RustLib.instance.api.seekstormHighlighterHighlightDefault();

  @override
  int get hashCode =>
      field.hashCode ^
      name.hashCode ^
      fragmentNumber.hashCode ^
      fragmentSize.hashCode ^
      highlightMarkup.hashCode ^
      preTags.hashCode ^
      postTags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Highlight &&
          runtimeType == other.runtimeType &&
          field == other.field &&
          name == other.name &&
          fragmentNumber == other.fragmentNumber &&
          fragmentSize == other.fragmentSize &&
          highlightMarkup == other.highlightMarkup &&
          preTags == other.preTags &&
          postTags == other.postTags;
}
