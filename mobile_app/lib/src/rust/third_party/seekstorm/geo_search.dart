// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'index.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'search.dart';

/// encode 2D-coordinate (lat/lon) into 64-bit Morton code
/// This method is lossy/quantized as two f64 coordinate values are mapped to a single u64 Morton code!
/// The z-value of a point in multidimensions is simply calculated by interleaving the binary representations of its coordinate values.
Future<BigInt> encodeMorton2D({required List<double> point}) =>
    RustLib.instance.api.seekstormGeoSearchEncodeMorton2D(point: point);

/// decode 64-bit Morton code into 2D-coordinate (lat/lon)
/// This method is lossy/quantized as a single u64 Morton code is converted to two f64 coordinate values!
Future<Float64List> decodeMorton2D({required BigInt code}) =>
    RustLib.instance.api.seekstormGeoSearchDecodeMorton2D(code: code);

/// Comparison of the distances between two morton encoded positions and a base position
Future<Ordering> mortonOrdering(
        {required BigInt morton1,
        required BigInt morton2,
        required List<double> basePoint,
        required SortOrder order}) =>
    RustLib.instance.api.seekstormGeoSearchMortonOrdering(
        morton1: morton1, morton2: morton2, basePoint: basePoint, order: order);

/// calculates distance in kilometers or miles between two 2D-coordinates using Euclidian distance (Pythagoras theorem) with Equirectangular approximation.
Future<double> euclidianDistance(
        {required List<double> point1,
        required List<double> point2,
        required DistanceUnit unit}) =>
    RustLib.instance.api.seekstormGeoSearchEuclidianDistance(
        point1: point1, point2: point2, unit: unit);

/// Converts a Point and a distance radius into a range of morton_codes for geo search range filtering.
/// The conversion is lossy due to coordinate to Morton code rounding errors and Equirectangular approximation of Euclidian distance.
Future<RangeU64> pointDistanceToMortonRange(
        {required List<double> point,
        required double distance,
        required DistanceUnit unit}) =>
    RustLib.instance.api.seekstormGeoSearchPointDistanceToMortonRange(
        point: point, distance: distance, unit: unit);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>
abstract class Ordering implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Range < u64 >>>
abstract class RangeU64 implements RustOpaqueInterface {}
