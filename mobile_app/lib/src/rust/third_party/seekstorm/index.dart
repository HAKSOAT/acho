// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'highlighter.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'search.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BlockObjectIndex`, `IndexedField`, `LevelIndex`, `NgramSet`, `NonUniquePostingListObjectQuery`, `NonUniqueTermObject`, `PostingListObject0`, `PostingListObjectIndex`, `PostingListObjectQuery`, `QueueObject`, `ResultFacet`, `SegmentIndex`, `SegmentLevel0`, `Shard`, `TermObject`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `compose`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `name`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`, `schemas`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `close`, `delete_document`, `delete_documents_by_query`, `delete_documents`, `index_document_2`, `index_document_shard`, `index_document`, `index_documents`, `update_document`, `update_documents`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`

/// Get the version of the SeekStorm search library
Future<void> version() => RustLib.instance.api.seekstormIndexVersion();

/// Create index in RAM.
/// Inner data structures for create index and open_index
/// * `index_path` - index path.
/// * `meta` - index meta object.
/// * `schema` - schema.
/// * `synonyms` - vector of synonyms.
/// * `segment_number_bits1` - number of index segments: e.g. 11 bits for 2048 segments.
/// * `mute` - prevent emitting status messages (e.g. when using pipes for data interprocess communication).
/// * `force_shard_number` - set number of shards manually or automatically.
///   - none: number of shards is set automatically = number of physical processor cores (default)
///   - small: slower indexing, higher latency, slightly higher throughput, faster realtime search, lower RAM consumption
///   - large: faster indexing, lower latency, slightly lower throughput, slower realtime search, higher RAM consumption
Future<ArcIndex> createIndex(
        {required Path indexPath,
        required IndexMetaObject meta,
        required List<SchemaField> schema,
        required List<Synonym> synonyms,
        required BigInt segmentNumberBits1,
        required bool mute,
        BigInt? forceShardNumber}) =>
    RustLib.instance.api.seekstormIndexCreateIndex(
        indexPath: indexPath,
        meta: meta,
        schema: schema,
        synonyms: synonyms,
        segmentNumberBits1: segmentNumberBits1,
        mute: mute,
        forceShardNumber: forceShardNumber);

/// Loads the index from disk into RAM or MMAP.
/// * `index_path` - index path.
/// * `mute` - prevent emitting status messages (e.g. when using pipes for data interprocess communication).
Future<ArcIndex> openIndex({required Path indexPath, required bool mute}) =>
    RustLib.instance.api
        .seekstormIndexOpenIndex(indexPath: indexPath, mute: mute);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DocumentItem>>
abstract class DocumentItem implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FacetField>>
abstract class FacetField implements RustOpaqueInterface {
  ValueType get max;

  ValueType get min;

  String get name;

  IndexMapStringVecStringUsize get values;

  set max(ValueType max);

  set min(ValueType min);

  set name(String name);

  set values(IndexMapStringVecStringUsize values);

  static Future<FacetField> default_() =>
      RustLib.instance.api.seekstormIndexFacetFieldDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FileType>>
abstract class FileType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrequentwordType>>
abstract class FrequentwordType implements RustOpaqueInterface {
  static Future<FrequentwordType> default_() =>
      RustLib.instance.api.seekstormIndexFrequentwordTypeDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Index>>
abstract class Index implements RustOpaqueInterface {
  /// Add/append/update/merge synonyms in index
  /// Affects only subsequently indexed documents
  Future<BigInt> addSynonyms({required List<Synonym> synonyms});

  int get indexFormatVersionMajor;

  int get indexFormatVersionMinor;

  IndexMetaObject get meta;

  Map<String, SchemaField> get schemaMap;

  List<String> get storedFieldNames;

  set indexFormatVersionMajor(int indexFormatVersionMajor);

  set indexFormatVersionMinor(int indexFormatVersionMinor);

  set meta(IndexMetaObject meta);

  set schemaMap(Map<String, SchemaField> schemaMap);

  set storedFieldNames(List<String> storedFieldNames);

  /// Reset index to empty, while maintaining schema
  Future<void> clearIndex();

  /// Get number of indexed documents.
  Future<BigInt> committedDocCount();

  /// Current document count: indexed document count - deleted document count
  Future<BigInt> currentDocCount();

  /// Delete index from disc and ram
  Future<void> deleteIndex();

  /// Get number of facets defined in the index schema.
  Future<BigInt> facetsCount();

  /// Get document for document id
  /// Arguments:
  /// * `doc_id`: Specifies which document to load from the document store of the index.
  /// * `include_uncommited`: Return also documents which have not yet been committed.
  /// * `highlighter_option`: Specifies the extraction of keyword-in-context (KWIC) fragments from fields in documents, and the highlighting of the query terms within.
  /// * `fields`: Specifies which of the stored fields to return with each document. Default: If empty return all stored fields
  /// * `distance_fields`: insert distance fields into result documents, calculating the distance between a specified facet field of type Point and a base Point, in kilometers or miles.
  ///   using Euclidian distance (Pythagoras theorem) with Equirectangular approximation.
  Future<Map<String, Value>> getDocument(
      {required BigInt docId,
      required bool includeUncommited,
      Highlighter? highlighterOption,
      required Set<String> fields,
      required List<DistanceField> distanceFields});

  /// get_facet_value: Returns value from facet field for a doc_id even if schema stored=false (field not stored in document JSON).
  /// Facet fields are more compact than fields stored in document JSON.
  /// Strings are stored more compact as indices to a unique term dictionary. Numbers are stored binary, not as strings.
  /// Facet fields are faster because no document loading, decompression and JSON decoding is required.
  /// Facet fields are always memory mapped, internally always stored with fixed byte length layout, regardless of string size.
  Future<FacetValue> getFacetValue(
      {required String field, required BigInt docId});

  /// Get file for document id
  /// Arguments:
  /// * `doc_id`: Specifies which document to load from the document store of the index.
  ///
  /// Returns:
  /// * `Vec<u8>`: The file content as a byte vector.
  ///
  Future<Uint8List> getFile({required BigInt docId});

  /// get_index_string_facets: list of string facet fields, each with field name and a map of unique values and their count (number of times the specific value appears in the whole index).
  /// values are sorted by their occurrence count within all indexed documents in descending order
  /// * `query_facets`: Must be set if facet fields should be returned in get_index_facets. If set to Vec::new() then no facet fields are returned.
  ///   The prefix property of a QueryFacet allows to filter the returned facet values to those matching a given prefix, if there are too many distinct values per facet field.
  ///   The length property of a QueryFacet allows limiting the number of returned distinct values per facet field, if there are too many distinct values.  The QueryFacet can be used to improve the usability in an UI.
  ///   If the length property of a QueryFacet is set to 0 then no facet values for that facet are returned.
  ///   The facet values are sorted by the frequency of the appearance of the value within the indexed documents matching the query in descending order.
  ///   Example: query_facets = vec![QueryFacet::String16 {field: "language".to_string(),prefix: "ger".to_string(),length: 5},QueryFacet::String16 {field: "brand".to_string(),prefix: "a".to_string(),length: 5}];
  Future<AHashMapStringFacet?> getIndexStringFacets(
      {required List<QueryFacet> queryFacets});

  /// Get synonyms from index
  Future<List<Synonym>> getSynonyms();

  /// get_index_facets_minmax: return map of numeric facet fields, each with field name and min/max values.
  Future<Map<String, MinMaxFieldJson>> indexFacetsMinmax();

  /// Get number of indexed documents.
  Future<BigInt> indexedDocCount();

  /// Get number of index levels. One index level comprises 64K documents.
  Future<BigInt> levelCount();

  /// Set/replace/overwrite synonyms in index
  /// Affects only subsequently indexed documents
  Future<BigInt> setSynonyms({required List<Synonym> synonyms});

  /// Get number of index shards.
  Future<BigInt> shardCount();

  /// are there uncommited documents?
  Future<BigInt> uncommittedDocCount();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IndexMetaObject>>
abstract class IndexMetaObject implements RustOpaqueInterface {
  AccessType get accessType;

  FrequentwordType get frequentWords;

  BigInt get id;

  String get name;

  int get ngramIndexing;

  QueryCompletion? get queryCompletion;

  SimilarityType get similarity;

  SpellingCorrection? get spellingCorrection;

  StemmerType get stemmer;

  StopwordType get stopWords;

  TokenizerType get tokenizer;

  set accessType(AccessType accessType);

  set frequentWords(FrequentwordType frequentWords);

  set id(BigInt id);

  set name(String name);

  set ngramIndexing(int ngramIndexing);

  set queryCompletion(QueryCompletion? queryCompletion);

  set similarity(SimilarityType similarity);

  set spellingCorrection(SpellingCorrection? spellingCorrection);

  set stemmer(StemmerType stemmer);

  set stopWords(StopwordType stopWords);

  set tokenizer(TokenizerType tokenizer);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MinMaxField>>
abstract class MinMaxField implements RustOpaqueInterface {
  ValueType get max;

  ValueType get min;

  set max(ValueType max);

  set min(ValueType min);

  static Future<MinMaxField> default_() =>
      RustLib.instance.api.seekstormIndexMinMaxFieldDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MinMaxFieldJson>>
abstract class MinMaxFieldJson implements RustOpaqueInterface {
  Value get max;

  Value get min;

  set max(Value max);

  set min(Value min);

  static Future<MinMaxFieldJson> default_() =>
      RustLib.instance.api.seekstormIndexMinMaxFieldJsonDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SchemaField>>
abstract class SchemaField implements RustOpaqueInterface {
  double get boost;

  bool get completionSource;

  bool get dictionarySource;

  bool get facet;

  String get field;

  FieldType get fieldType;

  bool get indexed;

  bool get longest;

  bool get stored;

  set boost(double boost);

  set completionSource(bool completionSource);

  set dictionarySource(bool dictionarySource);

  set facet(bool facet);

  set field(String field);

  set fieldType(FieldType fieldType);

  set indexed(bool indexed);

  set longest(bool longest);

  set stored(bool stored);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new SchemaField.
  /// Defines a field in index schema: field, stored, indexed , field_type, facet, boost.
  /// # Parameters
  /// - field: unique name of a field
  /// - stored: only stored fields are returned in the search results
  /// - indexed: only indexed fields can be searched
  /// - field_type: type of a field: u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, point
  /// - facet: enable faceting for a field: for sorting results by field values, for range filtering, for result count per field value or range
  /// - `longest`: This allows to annotate (manually set) the longest field in schema.
  ///   Otherwise the longest field will be automatically detected in first index_document.
  ///   Setting/detecting the longest field ensures efficient index encoding.
  /// - boost: optional custom weight factor for Bm25 ranking
  /// # Returns
  /// - SchemaField
  /// # Example
  /// ```rust
  /// use seekstorm::index::{SchemaField, FieldType};
  /// let schema_field = SchemaField::new("title".to_string(), true, true, FieldType::String16, false, false, 1.0, false, false);
  /// ```
  static Future<SchemaField> newInstance(
          {required String field,
          required bool stored,
          required bool indexed,
          required FieldType fieldType,
          required bool facet,
          required bool longest,
          required double boost,
          required bool dictionarySource,
          required bool completionSource}) =>
      RustLib.instance.api.seekstormIndexSchemaFieldNew(
          field: field,
          stored: stored,
          indexed: indexed,
          fieldType: fieldType,
          facet: facet,
          longest: longest,
          boost: boost,
          dictionarySource: dictionarySource,
          completionSource: completionSource);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StopwordType>>
abstract class StopwordType implements RustOpaqueInterface {
  static Future<StopwordType> default_() =>
      RustLib.instance.api.seekstormIndexStopwordTypeDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ValueType>>
abstract class ValueType implements RustOpaqueInterface {
  static Future<ValueType> default_() =>
      RustLib.instance.api.seekstormIndexValueTypeDefault();
}

abstract class Close {
  /// Remove index from RAM (Reverse of open_index)
  Future<void> close();
}

abstract class DeleteDocument {
  /// Delete document from index by document id
  Future<void> deleteDocument({required BigInt docid});
}

abstract class DeleteDocuments {
  /// Delete documents from index by document id
  Future<void> deleteDocuments({required Uint64List docidVec});
}

abstract class DeleteDocumentsByQuery {
  /// Delete documents from index by query
  /// Delete and search have identical parameters.
  /// It is recommended to test with search prior to delete to verify that only those documents are returned that you really want to delete.
  Future<void> deleteDocumentsByQuery(
      {required String queryString,
      required QueryType queryTypeDefault,
      required BigInt offset,
      required BigInt length,
      required bool includeUncommited,
      required List<String> fieldFilter,
      required List<FacetFilter> facetFilter,
      required List<ResultSort> resultSort});
}

abstract class IndexDocument {
  /// Indexes a single document
  /// May block, if the threshold of documents indexed in parallel is exceeded.
  Future<void> indexDocument(
      {required Map<String, Value> document, required FileType file});
}

abstract class IndexDocument2 {
  Future<void> indexDocument2(
      {required DocumentItem documentItem, required FileType file});
}

abstract class IndexDocumentShard {
  /// Indexes a single document
  /// May block, if the threshold of documents indexed in parallel is exceeded.
  Future<void> indexDocumentShard(
      {required Map<String, Value> document, required FileType file});
}

abstract class IndexDocuments {
  /// Indexes a list of documents
  /// May block, if the threshold of documents indexed in parallel is exceeded.
  Future<void> indexDocuments({required List<Map<String, Value>> documentVec});
}

abstract class UpdateDocument {
  /// Update document in index
  /// Update_document is a combination of delete_document and index_document.
  /// All current limitations of delete_document apply.
  Future<void> updateDocument(
      {required (BigInt, Map<String, Value>) idDocument});
}

abstract class UpdateDocuments {
  /// Update documents in index
  /// Update_document is a combination of delete_document and index_document.
  /// All current limitations of delete_document apply.
  Future<void> updateDocuments(
      {required List<(BigInt, Map<String, Value>)> idDocumentVec});
}

/// Defines where the index resides during search:
/// - Ram (the complete index is preloaded to Ram when opening the index)
/// - Mmap (the index is accessed via memory-mapped files). See architecture.md for details.
/// - At commit the data is serialized to disk for persistence both in Ram and Mmap mode.
/// - The serialization format is identical for Ram and Mmap mode, allowing to change it retrospectively.
enum AccessType {
  /// Ram (the complete index is preloaded to Ram when opening the index).
  /// - Index size is limited by available RAM size.
  /// - Slightly fastesr search speed.
  /// - Higher index loading time.
  /// - Higher RAM usage.
  ram,

  /// Mmap (the index is accessed via memory-mapped files). See architecture.md for details.
  /// - Enables index size scaling beyond RAM size.
  /// - Slightly slower search speed compared to Ram.
  /// - Faster index loading time compared to Ram.
  /// - Lower RAM usage.
  mmap,
  ;
}

/// Type of posting list compression.
enum CompressionType {
  delta,
  array,
  bitmap,
  rle,
  error,
  ;

  static Future<CompressionType> default_() =>
      RustLib.instance.api.seekstormIndexCompressionTypeDefault();
}

/// DistanceField defines a field for proximity search.
class DistanceField {
  /// field name of a numeric facet field (currently onyl Point field type supported)
  final String field;

  /// field name of the distance field we are deriving from the numeric facet field (Point type) and the base (Point type)
  final String distance;

  /// base point (lat,lon) for distance calculation
  final Float64List base;

  /// distance unit for the distance field: kilometers or miles
  final DistanceUnit unit;

  const DistanceField({
    required this.field,
    required this.distance,
    required this.base,
    required this.unit,
  });

  static Future<DistanceField> default_() =>
      RustLib.instance.api.seekstormIndexDistanceFieldDefault();

  @override
  int get hashCode =>
      field.hashCode ^ distance.hashCode ^ base.hashCode ^ unit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DistanceField &&
          runtimeType == other.runtimeType &&
          field == other.field &&
          distance == other.distance &&
          base == other.base &&
          unit == other.unit;
}

/// DistanceUnit defines the unit for distance calculation: kilometers or miles.
enum DistanceUnit {
  /// Kilometers
  kilometers,

  /// Miles
  miles,
  ;
}

/// FieldType defines the type of a field in the document: u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, point, string, stringset, text.
enum FieldType {
  /// Unsigned 8-bit integer
  u8,

  /// Unsigned 16-bit integer
  u16,

  /// Unsigned 32-bit integer
  u32,

  /// Unsigned 64-bit integer
  u64,

  /// Signed 8-bit integer
  i8,

  /// Signed 16-bit integer
  i16,

  /// Signed 32-bit integer
  i32,

  /// Signed 64-bit integer
  i64,

  /// Timestamp is identical to I64, but to be used for Unix timestamps <https://en.wikipedia.org/wiki/Unix_time>.
  /// The reason for a separate FieldType is to enable the UI to interpret I64 as timestamp without using the field name as indicator.
  /// For date facets and filtering.
  timestamp,

  /// Floating point 32-bit
  f32,

  /// Floating point 64-bit
  f64,

  /// Boolean
  bool,

  /// String16
  /// allows a maximum cardinality of 65_535 (16 bit) distinct values, is space-saving.
  string16,

  /// String32
  /// allows a maximum cardinality of 4_294_967_295 (32 bit) distinct values
  string32,

  /// StringSet16 is a set of strings, e.g. tags, categories, keywords, authors, genres, etc.
  /// allows a maximum cardinality of 65_535 (16 bit) distinct values, is space-saving.
  stringSet16,

  /// StringSet32 is a set of strings, e.g. tags, categories, keywords, authors, genres, etc.
  /// allows a maximum cardinality of 4_294_967_295 (32 bit) distinct values
  stringSet32,

  /// Point is a geographic field type: A `Vec<f64>` with two coordinate values (latitude and longitude) are internally encoded into a single u64 value (Morton code).
  /// Morton codes enable efficient range queries.
  /// Latitude and longitude are a pair of numbers (coordinates) used to describe a position on the plane of a geographic coordinate system.
  /// The numbers are in decimal degrees format and range from -90 to 90 for latitude and -180 to 180 for longitude.
  /// Coordinates are internally stored as u64 morton code: both f64 values are multiplied by 10_000_000, converted to i32 and bitwise interleaved into a single u64 morton code
  /// The conversion between longitude/latitude coordinates and Morton code is lossy due to rounding errors.
  point,

  /// Text is a text field, that will be tokenized by the selected Tokenizer into string tokens.
  text,
  ;

  static Future<FieldType> default_() =>
      RustLib.instance.api.seekstormIndexFieldTypeDefault();
}

enum NgramType {
  /// no n-grams, only single terms are indexed
  singleTerm,

  /// Ngram frequent frequent
  ngramFf,

  /// Ngram frequent rare
  ngramFr,

  /// Ngram rare frequent
  ngramRf,

  /// Ngram frequent frequent frequent
  ngramFff,

  /// Ngram rare frequent frequent
  ngramRff,

  /// Ngram frequent frequent rare
  ngramFfr,

  /// Ngram frequent rare frequent
  ngramFrf,
  ;

  static Future<NgramType> default_() =>
      RustLib.instance.api.seekstormIndexNgramTypeDefault();
}

/// Defines spelling correction (fuzzy search) settings for an index.
class QueryCompletion {
  /// Maximum number of completions to generate during indexing
  /// disabled if == 0
  final BigInt maxCompletionEntries;

  const QueryCompletion({
    required this.maxCompletionEntries,
  });

  @override
  int get hashCode => maxCompletionEntries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QueryCompletion &&
          runtimeType == other.runtimeType &&
          maxCompletionEntries == other.maxCompletionEntries;
}

/// Similarity type defines the scoring and ranking of the search results:
/// - Bm25f: considers documents composed from several fields, with different field lengths and importance
/// - Bm25fProximity: considers term proximity, e.g. for implicit phrase search with improved relevancy
enum SimilarityType {
  /// Bm25f considers documents composed from several fields, with different field lengths and importance
  bm25F,

  /// Bm25fProximity considers term proximity, e.g. for implicit phrase search with improved relevancy
  bm25FProximity,
  ;

  static Future<SimilarityType> default_() =>
      RustLib.instance.api.seekstormIndexSimilarityTypeDefault();
}

/// Defines spelling correction (fuzzy search) settings for an index.
class SpellingCorrection {
  /// The edit distance thresholds for suggestions: 1..2 recommended; higher values increase latency and memory consumption.
  final BigInt maxDictionaryEditDistance;

  /// Term length thresholds for each edit distance.
  ///   None:    max_dictionary_edit_distance for all terms lengths
  ///   Some(\[4\]):    max_dictionary_edit_distance for all terms lengths >= 4,
  ///   Some(\[2,8\]):    max_dictionary_edit_distance for all terms lengths >=2, max_dictionary_edit_distance +1 for all terms for lengths>=8
  final Uint64List? termLengthThreshold;

  /// The minimum frequency count for dictionary words to be considered eligible for spelling correction.
  /// Depends on the corpus size, 1..20 recommended.
  /// If count_threshold is too high, some correct words might be missed from the dictionary and deemed misspelled,
  /// if count_threshold is too low, some misspelled words from the corpus might be considered correct and added to the dictionary.
  /// Dictionary terms eligible for spelling correction (frequency count >= count_threshold) consume much more RAM, than the candidates (frequency count < count_threshold),
  /// but the terms below count_threshold will be included in dictionary.csv too.
  final BigInt countThreshold;

  /// Limits the maximum number of dictionary entries (terms >= count_threshold) to generate during indexing, preventing excessive RAM consumption.
  /// The number of terms in dictionary.csv will be higher, because it contains also the terms < count_threshold, to become eligible in the future during incremental dictionary updates.
  /// Dictionary terms eligible for spelling correction (frequency count >= count_threshold) consume much more RAM, than the candidates (frequency count < count_threshold).
  /// ⚠️ Above this threshold no new terms are added to the dictionary, causing them to be deemed incorrect during spelling correction and possibly changed to similar terms that are in the dictionary.
  final BigInt maxDictionaryEntries;

  const SpellingCorrection({
    required this.maxDictionaryEditDistance,
    this.termLengthThreshold,
    required this.countThreshold,
    required this.maxDictionaryEntries,
  });

  @override
  int get hashCode =>
      maxDictionaryEditDistance.hashCode ^
      termLengthThreshold.hashCode ^
      countThreshold.hashCode ^
      maxDictionaryEntries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpellingCorrection &&
          runtimeType == other.runtimeType &&
          maxDictionaryEditDistance == other.maxDictionaryEditDistance &&
          termLengthThreshold == other.termLengthThreshold &&
          countThreshold == other.countThreshold &&
          maxDictionaryEntries == other.maxDictionaryEntries;
}

/// Defines stemming behavior, reducing inflected words to their word stem, base or root form.
/// Stemming increases recall, but decreases precision. It can introduce false positive results.
enum StemmerType {
  /// No stemming
  none,

  /// Arabic stemmer
  arabic,

  /// Danish stemmer
  danish,

  /// Dutch stemmer
  dutch,

  /// English stemmer
  english,

  /// Finnish stemmer
  finnish,

  /// French stemmer
  french,

  /// German stemmer
  german,

  /// Hungarian stemmer
  greek,

  /// Hungarian stemmer
  hungarian,

  /// Italian stemmer
  italian,

  /// Norwegian stemmer
  norwegian,

  /// Portuguese stemmer
  portuguese,

  /// Romanian stemmer
  romanian,

  /// Russian stemmer
  russian,

  /// Spanish stemmer
  spanish,

  /// Swedish stemmer
  swedish,

  /// Tamil stemmer
  tamil,

  /// Turkish stemmer
  turkish,
  ;

  static Future<StemmerType> default_() =>
      RustLib.instance.api.seekstormIndexStemmerTypeDefault();
}

/// Defines synonyms for terms per index.
class Synonym {
  /// List of terms that are synonyms.
  final List<String> terms;

  /// Creates alternative versions of documents where in each copy a term is replaced with one of its synonyms.
  /// Doesn't impact the query latency, but does increase the index size.
  /// Multi-way synonyms (default): all terms are synonyms of each other.
  /// One-way synonyms: only the first term is a synonym of the following terms, but not vice versa.
  /// E.g. [street, avenue, road] will result in searches for street to return documents containing any of the terms street, avenue or road,
  /// but searches for avenue will only return documents containing avenue, but not documents containing street or road.
  /// Currently only single terms without spaces are supported.
  /// Synonyms are supported in result highlighting.
  /// The synonyms that were created with the synonyms parameter in create_index are stored in synonyms.json in the index directory contains
  /// Can be manually modified, but becomes effective only after restart and only for newly indexed documents.
  final bool multiway;

  const Synonym({
    required this.terms,
    required this.multiway,
  });

  @override
  int get hashCode => terms.hashCode ^ multiway.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Synonym &&
          runtimeType == other.runtimeType &&
          terms == other.terms &&
          multiway == other.multiway;
}

/// Defines tokenizer behavior:
/// AsciiAlphabetic
/// - Mainly for for benchmark compatibility
/// - Only ASCII alphabetic chars are recognized as token.
///
/// UnicodeAlphanumeric
/// - All Unicode alphanumeric chars are recognized as token.
/// - Allows '+' '-' '#' in middle or end of a token: c++, c#, block-max.
///
/// UnicodeAlphanumericFolded
/// - All Unicode alphanumeric chars are recognized as token.
/// - Allows '+' '-' '#' in middle or end of a token: c++, c#, block-max.
/// - Diacritics, accents, zalgo text, umlaut, bold, italic, full-width UTF-8 characters are converted into its basic representation.
/// - Apostroph handling prevents that short term parts preceding or following the apostroph get indexed (e.g. "s" in "someone's").
/// - Tokenizing might be slower due to folding and apostroph processing.
///
/// UnicodeAlphanumericZH
/// - Implements Chinese word segmentation to segment continuous Chinese text into tokens for indexing and search.
/// - Supports mixed Latin and Chinese texts
/// - Supports Chinese sentence boundary chars for KWIC snippets ahd highlighting.
/// - Requires feature #[cfg(feature = "zh")]
enum TokenizerType {
  /// Only ASCII alphabetic chars are recognized as token. Mainly for benchmark compatibility.
  asciiAlphabetic,

  /// All Unicode alphanumeric chars are recognized as token.
  /// Allow '+' '-' '#' in middle or end of a token: c++, c#, block-max.
  unicodeAlphanumeric,

  /// All Unicode alphanumeric chars are recognized as token.
  /// Allows '+' '-' '#' in middle or end of a token: c++, c#, block-max.
  /// Diacritics, accents, zalgo text, umlaut, bold, italic, full-width UTF-8 characters are converted into its basic representation.
  /// Apostroph handling prevents that short term parts preceding or following the apostroph get indexed (e.g. "s" in "someone's").
  /// Tokenizing might be slower due to folding and apostroph processing.
  unicodeAlphanumericFolded,

  /// Tokens are separated by whitespace. Mainly for benchmark compatibility.
  whitespace,

  /// Tokens are separated by whitespace. Token are converted to lowercase. Mainly for benchmark compatibility.
  whitespaceLowercase,

  /// Implements Chinese word segmentation to segment continuous Chinese text into tokens for indexing and search.
  /// Supports mixed Latin and Chinese texts
  /// Supports Chinese sentence boundary chars for KWIC snippets ahd highlighting.
  /// Requires feature #[cfg(feature = "zh")]
  unicodeAlphanumericZh,
  ;

  static Future<TokenizerType> default_() =>
      RustLib.instance.api.seekstormIndexTokenizerTypeDefault();
}
