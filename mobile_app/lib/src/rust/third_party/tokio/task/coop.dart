// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../signal/unix.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `cooperative`, `unconstrained`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BudgetDecrement`, `Budget`, `Coop`, `Unconstrained`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `drop`, `fmt`, `fmt`, `poll`

/// Consumes a unit of budget and returns the execution back to the Tokio
/// runtime *if* the task's coop budget was exhausted.
///
/// The task will only yield if its entire coop budget has been exhausted.
/// This function can be used in order to insert optional yield points into long
/// computations that do not use Tokio resources like sockets or semaphores,
/// without redundantly yielding to the runtime each time.
///
/// # Examples
///
/// Make sure that a function which returns a sum of (potentially lots of)
/// iterated values is cooperative.
///
/// ```
/// async fn sum_iterator(input: &mut impl std::iter::Iterator<Item=i64>) -> i64 {
///     let mut sum: i64 = 0;
///     while let Some(i) = input.next() {
///         sum += i;
///         tokio::task::consume_budget().await
///     }
///     sum
/// }
/// ```
Future<void> consumeBudget() =>
    RustLib.instance.api.tokioTaskCoopConsumeBudget();

/// Returns `true` if there is still budget left on the task.
///
/// # Examples
///
/// This example defines a `Timeout` future that requires a given `future` to complete before the
/// specified duration elapses. If it does, its result is returned; otherwise, an error is returned
/// and the future is canceled.
///
/// Note that the future could exhaust the budget before we evaluate the timeout. Using `has_budget_remaining`,
/// we can detect this scenario and ensure the timeout is always checked.
///
/// ```
/// # use std::future::Future;
/// # use std::pin::{pin, Pin};
/// # use std::task::{ready, Context, Poll};
/// # use tokio::task::coop;
/// # use tokio::time::Sleep;
/// pub struct Timeout<T> {
///     future: T,
///     delay: Pin<Box<Sleep>>,
/// }
///
/// impl<T> Future for Timeout<T>
/// where
///     T: Future + Unpin,
/// {
///     type Output = Result<T::Output, ()>;
///
///     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         let this = Pin::into_inner(self);
///         let future = Pin::new(&mut this.future);
///         let delay = Pin::new(&mut this.delay);
///
///         // check if the future is ready
///         let had_budget_before = coop::has_budget_remaining();
///         if let Poll::Ready(v) = future.poll(cx) {
///             return Poll::Ready(Ok(v));
///         }
///         let has_budget_now = coop::has_budget_remaining();
///
///         // evaluate the timeout
///         if let (true, false) = (had_budget_before, has_budget_now) {
///             // it is the underlying future that exhausted the budget
///             ready!(pin!(coop::unconstrained(delay)).poll(cx));
///         } else {
///             ready!(delay.poll(cx));
///         }
///         return Poll::Ready(Err(()));
///     }
/// }
///```
Future<bool> hasBudgetRemaining() =>
    RustLib.instance.api.tokioTaskCoopHasBudgetRemaining();

/// Decrements the task budget and returns [`Poll::Pending`] if the budget is depleted.
/// This indicates that the task should yield to the scheduler. Otherwise, returns
/// [`RestoreOnPending`] which can be used to commit the budget consumption.
///
/// The returned [`RestoreOnPending`] will revert the budget to its former
/// value when dropped unless [`RestoreOnPending::made_progress`]
/// is called. It is the caller's responsibility to do so when it _was_ able to
/// make progress after the call to [`poll_proceed`].
/// Restoring the budget automatically ensures the task can try to make progress in some other
/// way.
///
/// Note that [`RestoreOnPending`] restores the budget **as it was before [`poll_proceed`]**.
/// Therefore, if the budget is _further_ adjusted between when [`poll_proceed`] returns and
/// [`RestoreOnPending`] is dropped, those adjustments are erased unless the caller indicates
/// that progress was made.
///
/// # Examples
///
/// This example wraps the `futures::channel::mpsc::UnboundedReceiver` to
/// cooperate with the Tokio scheduler. Each time a value is received, task budget
/// is consumed. If no budget is available, the task yields to the scheduler.
///
/// ```
/// use std::pin::Pin;
/// use std::task::{ready, Context, Poll};
/// use tokio::task::coop;
/// use futures::stream::{Stream, StreamExt};
/// use futures::channel::mpsc::UnboundedReceiver;
///
/// struct CoopUnboundedReceiver<T> {
///    receiver: UnboundedReceiver<T>,
/// }
///
/// impl<T> Stream for CoopUnboundedReceiver<T> {
///     type Item = T;
///     fn poll_next(
///         mut self: Pin<&mut Self>,
///         cx: &mut Context<'_>
///     ) -> Poll<Option<T>> {
///         let coop = ready!(coop::poll_proceed(cx));
///         match self.receiver.poll_next_unpin(cx) {
///             Poll::Ready(v) => {
///                 // We received a value, so consume budget.
///                 coop.made_progress();
///                 Poll::Ready(v)
///             }
///             Poll::Pending => Poll::Pending,
///        }
///     }
/// }
/// ```
Future<PollRestoreOnPending> pollProceed({required Context cx}) =>
    RustLib.instance.api.tokioTaskCoopPollProceed(cx: cx);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Poll < RestoreOnPending >>>
abstract class PollRestoreOnPending implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RestoreOnPending>>
abstract class RestoreOnPending implements RustOpaqueInterface {
  /// Signals that the task that obtained this `RestoreOnPending` was able to make
  /// progress. This prevents the task budget from being restored to the value
  /// it had prior to obtaining this instance when it is dropped.
  Future<void> madeProgress();
}
