// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `TimerFlavor`, `Timer`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `eq`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnterGuard < 'static>>>
abstract class EnterGuard implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Handle>>
abstract class Handle implements RustOpaqueInterface {
  /// Returns a `Handle` view over the currently running `Runtime`.
  ///
  /// # Panics
  ///
  /// This will panic if called outside the context of a Tokio runtime. That means that you must
  /// call this on one of the threads **being run by the runtime**, or from a thread with an active
  /// `EnterGuard`. Calling this from within a thread created by `std::thread::spawn` (for example)
  /// will cause a panic unless that thread has an active `EnterGuard`.
  ///
  /// # Examples
  ///
  /// This can be used to obtain the handle of the surrounding runtime from an async
  /// block or function running on that runtime.
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// # use std::thread;
  /// # use tokio::runtime::Runtime;
  /// # fn dox() {
  /// # let rt = Runtime::new().unwrap();
  /// # rt.spawn(async {
  /// use tokio::runtime::Handle;
  ///
  /// // Inside an async block or function.
  /// let handle = Handle::current();
  /// handle.spawn(async {
  ///     println!("now running in the existing Runtime");
  /// });
  ///
  /// # let handle =
  /// thread::spawn(move || {
  ///     // Notice that the handle is created outside of this thread and then moved in
  ///     handle.spawn(async { /* ... */ });
  ///     // This next line would cause a panic because we haven't entered the runtime
  ///     // and created an EnterGuard
  ///     // let handle2 = Handle::current(); // panic
  ///     // So we create a guard here with Handle::enter();
  ///     let _guard = handle.enter();
  ///     // Now we can call Handle::current();
  ///     let handle2 = Handle::current();
  /// });
  /// # handle.join().unwrap();
  /// # });
  /// # }
  /// # }
  /// ```
  static Future<Handle> current() =>
      RustLib.instance.api.tokioRuntimeHandleCurrent();

  static Future<Handle> default_() =>
      RustLib.instance.api.tokioRuntimeHandleDefault();

  /// Enters the runtime context. This allows you to construct types that must
  /// have an executor available on creation such as [`Sleep`] or
  /// [`TcpStream`]. It will also allow you to call methods such as
  /// [`tokio::spawn`] and [`Handle::current`] without panicking.
  ///
  /// # Panics
  ///
  /// When calling `Handle::enter` multiple times, the returned guards
  /// **must** be dropped in the reverse order that they were acquired.
  /// Failure to do so will result in a panic and possible memory leaks.
  ///
  /// # Examples
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::runtime::Runtime;
  ///
  /// let rt = Runtime::new().unwrap();
  ///
  /// let _guard = rt.enter();
  /// tokio::spawn(async {
  ///     println!("Hello world!");
  /// });
  /// # }
  /// ```
  ///
  /// Do **not** do the following, this shows a scenario that will result in a
  /// panic and possible memory leak.
  ///
  /// ```should_panic,ignore-wasm
  /// use tokio::runtime::Runtime;
  ///
  /// let rt1 = Runtime::new().unwrap();
  /// let rt2 = Runtime::new().unwrap();
  ///
  /// let enter1 = rt1.enter();
  /// let enter2 = rt2.enter();
  ///
  /// drop(enter1);
  /// drop(enter2);
  /// ```
  ///
  /// [`Sleep`]: struct@crate::time::Sleep
  /// [`TcpStream`]: struct@crate::net::TcpStream
  /// [`tokio::spawn`]: fn@crate::spawn
  Future<EnterGuard> enter();

  /// Returns the [`Id`] of the current `Runtime`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// #[tokio::main(flavor = "current_thread")]
  /// async fn main() {
  ///   println!("Current runtime id: {}", Handle::current().id());
  /// }
  /// ```
  ///
  /// [`Id`]: struct@crate::runtime::Id
  Future<Id> id();

  /// Returns a view that lets you get information about how the runtime
  /// is performing.
  Future<RuntimeMetrics> metrics();

  /// Returns the flavor of the current `Runtime`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::{Handle, RuntimeFlavor};
  ///
  /// #[tokio::main(flavor = "current_thread")]
  /// async fn main() {
  ///   assert_eq!(RuntimeFlavor::CurrentThread, Handle::current().runtime_flavor());
  /// }
  /// ```
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::runtime::{Handle, RuntimeFlavor};
  ///
  /// #[tokio::main(flavor = "multi_thread", worker_threads = 4)]
  /// async fn main() {
  ///   assert_eq!(RuntimeFlavor::MultiThread, Handle::current().runtime_flavor());
  /// }
  /// # }
  /// ```
  Future<RuntimeFlavor> runtimeFlavor();

  /// Returns a Handle view over the currently running Runtime
  ///
  /// Returns an error if no Runtime has been started
  ///
  /// Contrary to `current`, this never panics
  static Future<Handle> tryCurrent() =>
      RustLib.instance.api.tokioRuntimeHandleTryCurrent();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Id>>
abstract class Id implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Runtime>>
abstract class Runtime implements RustOpaqueInterface {
  /// Enters the runtime context.
  ///
  /// This allows you to construct types that must have an executor
  /// available on creation such as [`Sleep`] or [`TcpStream`]. It will
  /// also allow you to call methods such as [`tokio::spawn`].
  ///
  /// [`Sleep`]: struct@crate::time::Sleep
  /// [`TcpStream`]: struct@crate::net::TcpStream
  /// [`tokio::spawn`]: fn@crate::spawn
  ///
  /// # Example
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::runtime::Runtime;
  /// use tokio::task::JoinHandle;
  ///
  /// fn function_that_spawns(msg: String) -> JoinHandle<()> {
  ///     // Had we not used `rt.enter` below, this would panic.
  ///     tokio::spawn(async move {
  ///         println!("{}", msg);
  ///     })
  /// }
  ///
  /// fn main() {
  ///     let rt = Runtime::new().unwrap();
  ///
  ///     let s = "Hello World!".to_string();
  ///
  ///     // By entering the context, we tie `tokio::spawn` to this executor.
  ///     let _guard = rt.enter();
  ///     let handle = function_that_spawns(s);
  ///
  ///     // Wait for the task before we end the test.
  ///     rt.block_on(handle).unwrap();
  /// }
  /// # }
  /// ```
  Future<EnterGuard> enter();

  /// Returns a handle to the runtime's spawner.
  ///
  /// The returned handle can be used to spawn tasks that run on this runtime, and can
  /// be cloned to allow moving the `Handle` to other threads.
  ///
  /// Calling [`Handle::block_on`] on a handle to a `current_thread` runtime is error-prone.
  /// Refer to the documentation of [`Handle::block_on`] for more.
  ///
  /// # Examples
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::runtime::Runtime;
  ///
  /// let rt = Runtime::new()
  ///     .unwrap();
  ///
  /// let handle = rt.handle();
  ///
  /// // Use the handle...
  /// # }
  /// ```
  Future<void> handle();

  /// Returns a view that lets you get information about how the runtime
  /// is performing.
  Future<RuntimeMetrics> metrics();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new runtime instance with default configuration values.
  ///
  /// This results in the multi threaded scheduler, I/O driver, and time driver being
  /// initialized.
  ///
  /// Most applications will not need to call this function directly. Instead,
  /// they will use the  [`#[tokio::main]` attribute][main]. When a more complex
  /// configuration is necessary, the [runtime builder] may be used.
  ///
  /// See [module level][mod] documentation for more details.
  ///
  /// # Examples
  ///
  /// Creating a new `Runtime` with default configuration values.
  ///
  /// ```
  /// use tokio::runtime::Runtime;
  ///
  /// let rt = Runtime::new()
  ///     .unwrap();
  ///
  /// // Use the runtime...
  /// ```
  ///
  /// [mod]: index.html
  /// [main]: ../attr.main.html
  /// [threaded scheduler]: index.html#threaded-scheduler
  /// [runtime builder]: crate::runtime::Builder
  static Future<Runtime> newInstance() =>
      RustLib.instance.api.tokioRuntimeRuntimeNew();

  /// Shuts down the runtime, without waiting for any spawned work to stop.
  ///
  /// This can be useful if you want to drop a runtime from within another runtime.
  /// Normally, dropping a runtime will block indefinitely for spawned blocking tasks
  /// to complete, which would normally not be permitted within an asynchronous context.
  /// By calling `shutdown_background()`, you can drop the runtime from such a context.
  ///
  /// Note however, that because we do not wait for any blocking tasks to complete, this
  /// may result in a resource leak (in that any blocking tasks are still running until they
  /// return.
  ///
  /// See the [struct level documentation](Runtime#shutdown) for more details.
  ///
  /// This function is equivalent to calling `shutdown_timeout(Duration::from_nanos(0))`.
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::runtime::Runtime;
  ///
  /// fn main() {
  ///    let runtime = Runtime::new().unwrap();
  ///
  ///    runtime.block_on(async move {
  ///        let inner_runtime = Runtime::new().unwrap();
  ///        // ...
  ///        inner_runtime.shutdown_background();
  ///    });
  /// }
  /// # }
  /// ```
  Future<void> shutdownBackground();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RuntimeMetrics>>
abstract class RuntimeMetrics implements RustOpaqueInterface {
  /// Returns the number of tasks currently scheduled in the runtime's
  /// global queue.
  ///
  /// Tasks that are spawned or notified from a non-runtime thread are
  /// scheduled using the runtime's global queue. This metric returns the
  /// **current** number of tasks pending in the global queue. As such, the
  /// returned value may increase or decrease as new tasks are scheduled and
  /// processed.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  ///
  /// let n = metrics.global_queue_depth();
  /// println!("{} tasks currently pending in the runtime's global queue", n);
  /// # }
  /// ```
  Future<BigInt> globalQueueDepth();

  /// Returns the current number of alive tasks in the runtime.
  ///
  /// This counter increases when a task is spawned and decreases when a
  /// task exits.
  ///
  /// Note: When using the multi-threaded runtime this number may not
  /// not have strong consistency i.e. no tasks may be running but the metric
  /// reports otherwise.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  ///
  /// let n = metrics.num_alive_tasks();
  /// println!("Runtime has {} alive tasks", n);
  /// # }
  /// ```
  Future<BigInt> numAliveTasks();

  /// Returns the number of worker threads used by the runtime.
  ///
  /// The number of workers is set by configuring `worker_threads` on
  /// `runtime::Builder`. When using the `current_thread` runtime, the return
  /// value is always `1`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  ///
  /// let n = metrics.num_workers();
  /// println!("Runtime is using {} workers", n);
  /// # }
  /// ```
  Future<BigInt> numWorkers();

  /// Returns the total number of times the given worker thread has parked.
  ///
  /// The worker park count starts at zero when the runtime is created and
  /// increases by one each time the worker parks the thread waiting for new
  /// inbound events to process. This usually means the worker has processed
  /// all pending work and is currently idle.
  ///
  /// The counter is monotonically increasing. It is never decremented or
  /// reset to zero.
  ///
  /// # Arguments
  ///
  /// `worker` is the index of the worker being queried. The given value must
  /// be between 0 and `num_workers()`. The index uniquely identifies a single
  /// worker and will continue to identify the worker throughout the lifetime
  /// of the runtime instance.
  ///
  /// # Panics
  ///
  /// The method panics when `worker` represents an invalid worker, i.e. is
  /// greater than or equal to `num_workers()`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  ///
  /// let n = metrics.worker_park_count(0);
  /// println!("worker 0 parked {} times", n);
  /// # }
  /// ```
  Future<BigInt> workerParkCount({required BigInt worker});

  /// Returns the total number of times the given worker thread has parked
  /// and unparked.
  ///
  /// The worker park/unpark count starts at zero when the runtime is created
  /// and increases by one each time the worker parks the thread waiting for
  /// new inbound events to process. This usually means the worker has processed
  /// all pending work and is currently idle. When new work becomes available,
  /// the worker is unparked and the park/unpark count is again increased by one.
  ///
  /// An odd count means that the worker is currently parked.
  /// An even count means that the worker is currently active.
  ///
  /// The counter is monotonically increasing. It is never decremented or
  /// reset to zero.
  ///
  /// # Arguments
  ///
  /// `worker` is the index of the worker being queried. The given value must
  /// be between 0 and `num_workers()`. The index uniquely identifies a single
  /// worker and will continue to identify the worker throughout the lifetime
  /// of the runtime instance.
  ///
  /// # Panics
  ///
  /// The method panics when `worker` represents an invalid worker, i.e. is
  /// greater than or equal to `num_workers()`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  /// let n = metrics.worker_park_unpark_count(0);
  ///
  /// println!("worker 0 parked and unparked {} times", n);
  ///
  /// if n % 2 == 0 {
  ///     println!("worker 0 is active");
  /// } else {
  ///     println!("worker 0 is parked");
  /// }
  /// # }
  /// ```
  Future<BigInt> workerParkUnparkCount({required BigInt worker});

  /// Returns the amount of time the given worker thread has been busy.
  ///
  /// The worker busy duration starts at zero when the runtime is created and
  /// increases whenever the worker is spending time processing work. Using
  /// this value can indicate the load of the given worker. If a lot of time
  /// is spent busy, then the worker is under load and will check for inbound
  /// events less often.
  ///
  /// The timer is monotonically increasing. It is never decremented or reset
  /// to zero.
  ///
  /// # Arguments
  ///
  /// `worker` is the index of the worker being queried. The given value must
  /// be between 0 and `num_workers()`. The index uniquely identifies a single
  /// worker and will continue to identify the worker throughout the lifetime
  /// of the runtime instance.
  ///
  /// # Panics
  ///
  /// The method panics when `worker` represents an invalid worker, i.e. is
  /// greater than or equal to `num_workers()`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::runtime::Handle;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let metrics = Handle::current().metrics();
  ///
  /// let n = metrics.worker_total_busy_duration(0);
  /// println!("worker 0 was busy for a total of {:?}", n);
  /// # }
  /// ```
  Future<Duration> workerTotalBusyDuration({required BigInt worker});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TryCurrentError>>
abstract class TryCurrentError implements RustOpaqueInterface {
  /// Returns true if the call failed because there is currently no runtime in
  /// the Tokio context.
  Future<bool> isMissingContext();

  /// Returns true if the call failed because the Tokio context thread-local
  /// had been destroyed. This can usually only happen if in the destructor of
  /// other thread-locals.
  Future<bool> isThreadLocalDestroyed();
}

/// The flavor of a `Runtime`.
///
/// This is the return type for [`Handle::runtime_flavor`](crate::runtime::Handle::runtime_flavor()).
enum RuntimeFlavor {
  /// The flavor that executes all tasks on the current thread.
  currentThread,

  /// The flavor that executes tasks across multiple threads.
  multiThread,
  ;
}
