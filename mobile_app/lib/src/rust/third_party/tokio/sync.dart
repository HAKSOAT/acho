// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MappedMutexGuard`, `MutexGuard`, `Mutex`, `OwnedMappedMutexGuard`, `OwnedMutexGuard`, `OwnedRwLockMappedWriteGuard`, `OwnedRwLockReadGuard`, `OwnedRwLockWriteGuard`, `RwLockMappedWriteGuard`, `RwLockReadGuard`, `RwLockWriteGuard`, `TryLockError`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AcquireError>>
abstract class AcquireError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Barrier>>
abstract class Barrier implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new barrier that can block a given number of tasks.
  ///
  /// A barrier will block `n`-1 tasks which call [`Barrier::wait`] and then wake up all
  /// tasks at once when the `n`th task calls `wait`.
  static Future<Barrier> newInstance({required BigInt n}) =>
      RustLib.instance.api.tokioSyncBarrierNew(n: n);

  /// Does not resolve until all tasks have rendezvoused here.
  ///
  /// Barriers are re-usable after all tasks have rendezvoused once, and can
  /// be used continuously.
  ///
  /// A single (arbitrary) future will receive a [`BarrierWaitResult`] that returns `true` from
  /// [`BarrierWaitResult::is_leader`] when returning from this function, and all other tasks
  /// will receive a result that will return `false` from `is_leader`.
  ///
  /// # Cancel safety
  ///
  /// This method is not cancel safe.
  Future<BarrierWaitResult> wait();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BarrierWaitResult>>
abstract class BarrierWaitResult implements RustOpaqueInterface {
  /// Returns `true` if this task from wait is the "leader task".
  ///
  /// Only one task will have `true` returned from their result, all other tasks will have
  /// `false` returned.
  Future<bool> isLeader();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Notify>>
abstract class Notify implements RustOpaqueInterface {
  /// Create a new `Notify`, initialized without a permit.
  ///
  /// When using the `tracing` [unstable feature], a `Notify` created with
  /// `const_new` will not be instrumented. As such, it will not be visible
  /// in [`tokio-console`]. Instead, [`Notify::new`] should be used to create
  /// an instrumented object if that is needed.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Notify;
  ///
  /// static NOTIFY: Notify = Notify::const_new();
  /// ```
  ///
  /// [`tokio-console`]: https://github.com/tokio-rs/console
  /// [unstable feature]: crate#unstable-features
  static Future<Notify> constNew() =>
      RustLib.instance.api.tokioSyncNotifyConstNew();

  static Future<Notify> default_() =>
      RustLib.instance.api.tokioSyncNotifyDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new `Notify`, initialized without a permit.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Notify;
  ///
  /// let notify = Notify::new();
  /// ```
  static Future<Notify> newInstance() =>
      RustLib.instance.api.tokioSyncNotifyNew();

  /// Wait for a notification.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn notified(&self);
  /// ```
  ///
  /// Each `Notify` value holds a single permit. If a permit is available from
  /// an earlier call to [`notify_one()`], then `notified().await` will complete
  /// immediately, consuming that permit. Otherwise, `notified().await` waits
  /// for a permit to be made available by the next call to `notify_one()`.
  ///
  /// The `Notified` future is not guaranteed to receive wakeups from calls to
  /// `notify_one()` if it has not yet been polled. See the documentation for
  /// [`Notified::enable()`] for more details.
  ///
  /// The `Notified` future is guaranteed to receive wakeups from
  /// `notify_waiters()` as soon as it has been created, even if it has not
  /// yet been polled.
  ///
  /// [`notify_one()`]: Notify::notify_one
  /// [`Notified::enable()`]: Notified::enable
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute notifications in the order
  /// they were requested. Cancelling a call to `notified` makes you lose your
  /// place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Notify;
  /// use std::sync::Arc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let notify = Arc::new(Notify::new());
  /// let notify2 = notify.clone();
  ///
  /// tokio::spawn(async move {
  ///     notify2.notified().await;
  ///     println!("received notification");
  /// });
  ///
  /// println!("sending notification");
  /// notify.notify_one();
  /// # }
  /// ```
  Future<Notified> notified();

  /// Wait for a notification with an owned `Future`.
  ///
  /// Unlike [`Self::notified`] which returns a future tied to the `Notify`'s
  /// lifetime, `notified_owned` creates a self-contained future that owns its
  /// notification state, making it safe to move between threads.
  ///
  /// See [`Self::notified`] for more details.
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute notifications in the order
  /// they were requested. Cancelling a call to `notified_owned` makes you lose your
  /// place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::Notify;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let notify = Arc::new(Notify::new());
  ///
  /// for _ in 0..10 {
  ///     let notified = notify.clone().notified_owned();
  ///     tokio::spawn(async move {
  ///         notified.await;
  ///         println!("received notification");
  ///     });
  /// }
  ///
  /// println!("sending notification");
  /// notify.notify_waiters();
  /// # }
  /// ```
  Future<OwnedNotified> notifiedOwned();

  /// Notifies the last waiting task.
  ///
  /// This function behaves similar to `notify_one`. The only difference is that it wakes
  /// the most recently added waiter instead of the oldest waiter.
  ///
  /// Check the [`notify_one()`] documentation for more info and
  /// examples.
  ///
  /// [`notify_one()`]: Notify::notify_one
  Future<void> notifyLast();

  /// Notifies the first waiting task.
  ///
  /// If a task is currently waiting, that task is notified. Otherwise, a
  /// permit is stored in this `Notify` value and the **next** call to
  /// [`notified().await`] will complete immediately consuming the permit made
  /// available by this call to `notify_one()`.
  ///
  /// At most one permit may be stored by `Notify`. Many sequential calls to
  /// `notify_one` will result in a single permit being stored. The next call to
  /// `notified().await` will complete immediately, but the one after that
  /// will wait.
  ///
  /// [`notified().await`]: Notify::notified()
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Notify;
  /// use std::sync::Arc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let notify = Arc::new(Notify::new());
  /// let notify2 = notify.clone();
  ///
  /// tokio::spawn(async move {
  ///     notify2.notified().await;
  ///     println!("received notification");
  /// });
  ///
  /// println!("sending notification");
  /// notify.notify_one();
  /// # }
  /// ```
  Future<void> notifyOne();

  /// Notifies all waiting tasks.
  ///
  /// If a task is currently waiting, that task is notified. Unlike with
  /// `notify_one()`, no permit is stored to be used by the next call to
  /// `notified().await`. The purpose of this method is to notify all
  /// already registered waiters. Registering for notification is done by
  /// acquiring an instance of the `Notified` future via calling `notified()`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Notify;
  /// use std::sync::Arc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let notify = Arc::new(Notify::new());
  /// let notify2 = notify.clone();
  ///
  /// let notified1 = notify.notified();
  /// let notified2 = notify.notified();
  ///
  /// let handle = tokio::spawn(async move {
  ///     println!("sending notifications");
  ///     notify2.notify_waiters();
  /// });
  ///
  /// notified1.await;
  /// notified2.await;
  /// println!("received notifications");
  /// # }
  /// ```
  Future<void> notifyWaiters();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OwnedSemaphorePermit>>
abstract class OwnedSemaphorePermit implements RustOpaqueInterface {
  /// Merge two [`OwnedSemaphorePermit`] instances together, consuming `other`
  /// without releasing the permits it holds.
  ///
  /// Permits held by both `self` and `other` are released when `self` drops.
  ///
  /// # Panics
  ///
  /// This function panics if permits from different [`Semaphore`] instances
  /// are merged.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::Semaphore;
  ///
  /// let sem = Arc::new(Semaphore::new(10));
  /// let mut permit = sem.clone().try_acquire_owned().unwrap();
  ///
  /// for _ in 0..9 {
  ///     let _permit = sem.clone().try_acquire_owned().unwrap();
  ///     // Merge individual permits into a single one.
  ///     permit.merge(_permit)
  /// }
  ///
  /// assert_eq!(sem.available_permits(), 0);
  ///
  /// // Release all permits in a single batch.
  /// drop(permit);
  ///
  /// assert_eq!(sem.available_permits(), 10);
  /// ```
  Future<void> merge({required OwnedSemaphorePermit other});

  /// Returns the number of permits held by `self`.
  Future<BigInt> numPermits();

  /// Returns the [`Semaphore`] from which this permit was acquired.
  Future<void> semaphore();

  /// Splits `n` permits from `self` and returns a new [`OwnedSemaphorePermit`] instance that holds `n` permits.
  ///
  /// If there are insufficient permits and it's not possible to reduce by `n`, returns `None`.
  ///
  /// # Note
  ///
  /// It will clone the owned `Arc<Semaphore>` to construct the new instance.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::Semaphore;
  ///
  /// let sem = Arc::new(Semaphore::new(3));
  ///
  /// let mut p1 = sem.try_acquire_many_owned(3).unwrap();
  /// let p2 = p1.split(1).unwrap();
  ///
  /// assert_eq!(p1.num_permits(), 2);
  /// assert_eq!(p2.num_permits(), 1);
  /// ```
  Future<OwnedSemaphorePermit?> split({required BigInt n});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Semaphore>>
abstract class Semaphore implements RustOpaqueInterface {
  /// Acquires a permit from the semaphore.
  ///
  /// If the semaphore has been closed, this returns an [`AcquireError`].
  /// Otherwise, this returns a [`SemaphorePermit`] representing the
  /// acquired permit.
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute permits in the order they
  /// were requested. Cancelling a call to `acquire` makes you lose your place
  /// in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Semaphore;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let semaphore = Semaphore::new(2);
  ///
  /// let permit_1 = semaphore.acquire().await.unwrap();
  /// assert_eq!(semaphore.available_permits(), 1);
  ///
  /// let permit_2 = semaphore.acquire().await.unwrap();
  /// assert_eq!(semaphore.available_permits(), 0);
  ///
  /// drop(permit_1);
  /// assert_eq!(semaphore.available_permits(), 1);
  /// # }
  /// ```
  ///
  /// [`AcquireError`]: crate::sync::AcquireError
  /// [`SemaphorePermit`]: crate::sync::SemaphorePermit
  Future<SemaphorePermit> acquire();

  /// Acquires `n` permits from the semaphore.
  ///
  /// If the semaphore has been closed, this returns an [`AcquireError`].
  /// Otherwise, this returns a [`SemaphorePermit`] representing the
  /// acquired permits.
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute permits in the order they
  /// were requested. Cancelling a call to `acquire_many` makes you lose your
  /// place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Semaphore;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let semaphore = Semaphore::new(5);
  ///
  /// let permit = semaphore.acquire_many(3).await.unwrap();
  /// assert_eq!(semaphore.available_permits(), 2);
  /// # }
  /// ```
  ///
  /// [`AcquireError`]: crate::sync::AcquireError
  /// [`SemaphorePermit`]: crate::sync::SemaphorePermit
  Future<SemaphorePermit> acquireMany({required int n});

  /// Acquires `n` permits from the semaphore.
  ///
  /// The semaphore must be wrapped in an [`Arc`] to call this method.
  /// If the semaphore has been closed, this returns an [`AcquireError`].
  /// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
  /// acquired permit.
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute permits in the order they
  /// were requested. Cancelling a call to `acquire_many_owned` makes you lose
  /// your place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::Semaphore;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let semaphore = Arc::new(Semaphore::new(10));
  /// let mut join_handles = Vec::new();
  ///
  /// for _ in 0..5 {
  ///     let permit = semaphore.clone().acquire_many_owned(2).await.unwrap();
  ///     join_handles.push(tokio::spawn(async move {
  ///         // perform task...
  ///         // explicitly own `permit` in the task
  ///         drop(permit);
  ///     }));
  /// }
  ///
  /// for handle in join_handles {
  ///     handle.await.unwrap();
  /// }
  /// # }
  /// ```
  ///
  /// [`Arc`]: std::sync::Arc
  /// [`AcquireError`]: crate::sync::AcquireError
  /// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
  Future<OwnedSemaphorePermit> acquireManyOwned({required int n});

  /// Acquires a permit from the semaphore.
  ///
  /// The semaphore must be wrapped in an [`Arc`] to call this method.
  /// If the semaphore has been closed, this returns an [`AcquireError`].
  /// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
  /// acquired permit.
  ///
  /// # Cancel safety
  ///
  /// This method uses a queue to fairly distribute permits in the order they
  /// were requested. Cancelling a call to `acquire_owned` makes you lose your
  /// place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::Semaphore;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let semaphore = Arc::new(Semaphore::new(3));
  /// let mut join_handles = Vec::new();
  ///
  /// for _ in 0..5 {
  ///     let permit = semaphore.clone().acquire_owned().await.unwrap();
  ///     join_handles.push(tokio::spawn(async move {
  ///         // perform task...
  ///         // explicitly own `permit` in the task
  ///         drop(permit);
  ///     }));
  /// }
  ///
  /// for handle in join_handles {
  ///     handle.await.unwrap();
  /// }
  /// # }
  /// ```
  ///
  /// [`Arc`]: std::sync::Arc
  /// [`AcquireError`]: crate::sync::AcquireError
  /// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
  Future<OwnedSemaphorePermit> acquireOwned();

  /// Adds `n` new permits to the semaphore.
  ///
  /// The maximum number of permits is [`Semaphore::MAX_PERMITS`], and this function will panic if the limit is exceeded.
  Future<void> addPermits({required BigInt n});

  /// Returns the current number of available permits.
  Future<BigInt> availablePermits();

  /// Closes the semaphore.
  ///
  /// This prevents the semaphore from issuing new permits and notifies all pending waiters.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Semaphore;
  /// use std::sync::Arc;
  /// use tokio::sync::TryAcquireError;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let semaphore = Arc::new(Semaphore::new(1));
  /// let semaphore2 = semaphore.clone();
  ///
  /// tokio::spawn(async move {
  ///     let permit = semaphore.acquire_many(2).await;
  ///     assert!(permit.is_err());
  ///     println!("waiter received error");
  /// });
  ///
  /// println!("closing semaphore");
  /// semaphore2.close();
  ///
  /// // Cannot obtain more permits
  /// assert_eq!(semaphore2.try_acquire().err(), Some(TryAcquireError::Closed))
  /// # }
  /// ```
  Future<void> close();

  /// Creates a new semaphore with the initial number of permits.
  ///
  /// When using the `tracing` [unstable feature], a `Semaphore` created with
  /// `const_new` will not be instrumented. As such, it will not be visible
  /// in [`tokio-console`]. Instead, [`Semaphore::new`] should be used to
  /// create an instrumented object if that is needed.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::Semaphore;
  ///
  /// static SEM: Semaphore = Semaphore::const_new(10);
  /// ```
  ///
  /// [`tokio-console`]: https://github.com/tokio-rs/console
  /// [unstable feature]: crate#unstable-features
  static Future<Semaphore> constNew({required BigInt permits}) =>
      RustLib.instance.api.tokioSyncSemaphoreConstNew(permits: permits);

  /// Decrease a semaphore's permits by a maximum of `n`.
  ///
  /// If there are insufficient permits and it's not possible to reduce by `n`,
  /// return the number of permits that were actually reduced.
  Future<BigInt> forgetPermits({required BigInt n});

  /// Returns true if the semaphore is closed
  Future<bool> isClosed();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new semaphore with the initial number of permits.
  ///
  /// Panics if `permits` exceeds [`Semaphore::MAX_PERMITS`].
  static Future<Semaphore> newInstance({required BigInt permits}) =>
      RustLib.instance.api.tokioSyncSemaphoreNew(permits: permits);

  /// Tries to acquire a permit from the semaphore.
  ///
  /// If the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
  /// and a [`TryAcquireError::NoPermits`] if there are no permits left. Otherwise,
  /// this returns a [`SemaphorePermit`] representing the acquired permits.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::{Semaphore, TryAcquireError};
  ///
  /// # fn main() {
  /// let semaphore = Semaphore::new(2);
  ///
  /// let permit_1 = semaphore.try_acquire().unwrap();
  /// assert_eq!(semaphore.available_permits(), 1);
  ///
  /// let permit_2 = semaphore.try_acquire().unwrap();
  /// assert_eq!(semaphore.available_permits(), 0);
  ///
  /// let permit_3 = semaphore.try_acquire();
  /// assert_eq!(permit_3.err(), Some(TryAcquireError::NoPermits));
  /// # }
  /// ```
  ///
  /// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
  /// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
  /// [`SemaphorePermit`]: crate::sync::SemaphorePermit
  Future<SemaphorePermit> tryAcquire();

  /// Tries to acquire `n` permits from the semaphore.
  ///
  /// If the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
  /// and a [`TryAcquireError::NoPermits`] if there are not enough permits left.
  /// Otherwise, this returns a [`SemaphorePermit`] representing the acquired permits.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::{Semaphore, TryAcquireError};
  ///
  /// # fn main() {
  /// let semaphore = Semaphore::new(4);
  ///
  /// let permit_1 = semaphore.try_acquire_many(3).unwrap();
  /// assert_eq!(semaphore.available_permits(), 1);
  ///
  /// let permit_2 = semaphore.try_acquire_many(2);
  /// assert_eq!(permit_2.err(), Some(TryAcquireError::NoPermits));
  /// # }
  /// ```
  ///
  /// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
  /// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
  /// [`SemaphorePermit`]: crate::sync::SemaphorePermit
  Future<SemaphorePermit> tryAcquireMany({required int n});

  /// Tries to acquire `n` permits from the semaphore.
  ///
  /// The semaphore must be wrapped in an [`Arc`] to call this method. If
  /// the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
  /// and a [`TryAcquireError::NoPermits`] if there are no permits left.
  /// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
  /// acquired permit.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::{Semaphore, TryAcquireError};
  ///
  /// # fn main() {
  /// let semaphore = Arc::new(Semaphore::new(4));
  ///
  /// let permit_1 = Arc::clone(&semaphore).try_acquire_many_owned(3).unwrap();
  /// assert_eq!(semaphore.available_permits(), 1);
  ///
  /// let permit_2 = semaphore.try_acquire_many_owned(2);
  /// assert_eq!(permit_2.err(), Some(TryAcquireError::NoPermits));
  /// # }
  /// ```
  ///
  /// [`Arc`]: std::sync::Arc
  /// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
  /// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
  /// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
  Future<OwnedSemaphorePermit> tryAcquireManyOwned({required int n});

  /// Tries to acquire a permit from the semaphore.
  ///
  /// The semaphore must be wrapped in an [`Arc`] to call this method. If
  /// the semaphore has been closed, this returns a [`TryAcquireError::Closed`]
  /// and a [`TryAcquireError::NoPermits`] if there are no permits left.
  /// Otherwise, this returns a [`OwnedSemaphorePermit`] representing the
  /// acquired permit.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::sync::Arc;
  /// use tokio::sync::{Semaphore, TryAcquireError};
  ///
  /// # fn main() {
  /// let semaphore = Arc::new(Semaphore::new(2));
  ///
  /// let permit_1 = Arc::clone(&semaphore).try_acquire_owned().unwrap();
  /// assert_eq!(semaphore.available_permits(), 1);
  ///
  /// let permit_2 = Arc::clone(&semaphore).try_acquire_owned().unwrap();
  /// assert_eq!(semaphore.available_permits(), 0);
  ///
  /// let permit_3 = semaphore.try_acquire_owned();
  /// assert_eq!(permit_3.err(), Some(TryAcquireError::NoPermits));
  /// # }
  /// ```
  ///
  /// [`Arc`]: std::sync::Arc
  /// [`TryAcquireError::Closed`]: crate::sync::TryAcquireError::Closed
  /// [`TryAcquireError::NoPermits`]: crate::sync::TryAcquireError::NoPermits
  /// [`OwnedSemaphorePermit`]: crate::sync::OwnedSemaphorePermit
  Future<OwnedSemaphorePermit> tryAcquireOwned();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SemaphorePermit < 'static>>>
abstract class SemaphorePermit implements RustOpaqueInterface {}

/// Error returned from the [`Semaphore::try_acquire`] function.
///
/// [`Semaphore::try_acquire`]: crate::sync::Semaphore::try_acquire
enum TryAcquireError {
  /// The semaphore has been [closed] and cannot issue new permits.
  ///
  /// [closed]: crate::sync::Semaphore::close
  closed,

  /// The semaphore has no available permits.
  noPermits,
  ;
}
