// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'runtime.dart';

// These functions are ignored because they have generic arguments: `block_in_place`, `spawn_blocking`, `spawn_local`, `spawn`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `JoinSet`, `LocalKey`

/// Yields execution back to the Tokio runtime.
///
/// A task yields by awaiting on `yield_now()`, and may resume when that future
/// completes (with no output.) The current task will be re-added as a pending
/// task at the _back_ of the pending queue. Any other pending tasks will be
/// scheduled. No other waking is required for the task to continue.
///
/// See also the usage example in the [task module](index.html#yield_now).
///
/// ## Non-guarantees
///
/// This function may not yield all the way up to the executor if there are any
/// special combinators above it in the call stack. For example, if a
/// [`tokio::select!`] has another branch complete during the same poll as the
/// `yield_now()`, then the yield is not propagated all the way up to the
/// runtime.
///
/// It is generally not guaranteed that the runtime behaves like you expect it
/// to when deciding which task to schedule next after a call to `yield_now()`.
/// In particular, the runtime may choose to poll the task that just ran
/// `yield_now()` again immediately without polling any other tasks first. For
/// example, the runtime will not drive the IO driver between every poll of a
/// task, and this could result in the runtime polling the current task again
/// immediately even if there is another task that could make progress if that
/// other task is waiting for a notification from the IO driver.
///
/// In general, changes to the order in which the runtime polls tasks is not
/// considered a breaking change, and your program should be correct no matter
/// which order the runtime polls your tasks in.
///
/// [`tokio::select!`]: macro@crate::select
Future<void> yieldNow() => RustLib.instance.api.tokioTaskYieldNow();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocalEnterGuard>>
abstract class LocalEnterGuard implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocalSet>>
abstract class LocalSet implements RustOpaqueInterface {
  static Future<LocalSet> default_() =>
      RustLib.instance.api.tokioTaskLocalSetDefault();

  /// Enters the context of this `LocalSet`.
  ///
  /// The [`spawn_local`] method will spawn tasks on the `LocalSet` whose
  /// context you are inside.
  ///
  /// [`spawn_local`]: fn@crate::task::spawn_local
  Future<LocalEnterGuard> enter();

  /// Returns the [`Id`] of the current [`LocalSet`] runtime.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use tokio::task;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let local_set = task::LocalSet::new();
  /// println!("Local set id: {}", local_set.id());
  /// # }
  /// ```
  ///
  /// [`Id`]: struct@crate::runtime::Id
  Future<Id> id();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Returns a new local task set.
  static Future<LocalSet> newInstance() =>
      RustLib.instance.api.tokioTaskLocalSetNew();
}
