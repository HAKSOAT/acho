// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'signal/unix.dart';
import 'time/interval.dart';

// These functions are ignored because they have generic arguments: `timeout_at`, `timeout`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Timeout`

/// Pauses time.
///
/// The current value of `Instant::now()` is saved and all subsequent calls
/// to `Instant::now()` will return the saved value. The saved value can be
/// changed by [`advance`] or by the time auto-advancing once the runtime
/// has no work to do. This only affects the `Instant` type in Tokio, and
/// the `Instant` in std continues to work as normal.
///
/// Pausing time requires the `current_thread` Tokio runtime. This is the
/// default runtime used by `#[tokio::test]`. The runtime can be initialized
/// with time in a paused state using the `Builder::start_paused` method.
///
/// For cases where time is immediately paused, it is better to pause
/// the time using the `main` or `test` macro:
/// ```
/// #[tokio::main(flavor = "current_thread", start_paused = true)]
/// async fn main() {
///    println!("Hello world");
/// }
/// ```
///
/// # Panics
///
/// Panics if time is already frozen or if called from outside of a
/// `current_thread` Tokio runtime.
///
/// # Auto-advance
///
/// If time is paused and the runtime has no work to do, the clock is
/// auto-advanced to the next pending timer. This means that [`Sleep`] or
/// other timer-backed primitives can cause the runtime to advance the
/// current time when awaited.
///
/// [`Sleep`]: crate::time::Sleep
/// [`advance`]: crate::time::advance
Future<void> pause() => RustLib.instance.api.tokioTimePause();

/// Resumes time.
///
/// Clears the saved `Instant::now()` value. Subsequent calls to
/// `Instant::now()` will return the value returned by the system call.
///
/// # Panics
///
/// Panics if time is not frozen or if called from outside of the Tokio
/// runtime.
Future<void> resume() => RustLib.instance.api.tokioTimeResume();

/// Advances time.
///
/// Increments the saved `Instant::now()` value by `duration`. Subsequent
/// calls to `Instant::now()` will return the result of the increment.
///
/// This function will make the current time jump forward by the given
/// duration in one jump. This means that all `sleep` calls with a deadline
/// before the new time will immediately complete "at the same time", and
/// the runtime is free to poll them in any order.  Additionally, this
/// method will not wait for the `sleep` calls it advanced past to complete.
/// If you want to do that, you should instead call [`sleep`] and rely on
/// the runtime's auto-advance feature.
///
/// Note that calls to `sleep` are not guaranteed to complete the first time
/// they are polled after a call to `advance`. For example, this can happen
/// if the runtime has not yet touched the timer driver after the call to
/// `advance`. However if they don't, the runtime will poll the task again
/// shortly.
///
/// # Panics
///
/// Panics if any of the following conditions are met:
///
/// - The clock is not frozen, which means that you must
///   call [`pause`] before calling this method.
/// - If called outside of the Tokio runtime.
/// - If the input `duration` is too large (such as [`Duration::MAX`])
///   to be safely added to the current time without causing an overflow.
///
/// # Caveats
///
/// Using a very large `duration` is not recommended,
/// as it may cause panicking due to overflow.
///
/// # Auto-advance
///
/// If the time is paused and there is no work to do, the runtime advances
/// time to the next timer. See [`pause`](pause#auto-advance) for more
/// details.
///
/// [`sleep`]: fn@crate::time::sleep
Future<void> advance({required Duration duration}) =>
    RustLib.instance.api.tokioTimeAdvance(duration: duration);

/// Creates new [`Interval`] that yields with interval of `period`. The first
/// tick completes immediately. The default [`MissedTickBehavior`] is
/// [`Burst`](MissedTickBehavior::Burst), but this can be configured
/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).
///
/// An interval will tick indefinitely. At any time, the [`Interval`] value can
/// be dropped. This cancels the interval.
///
/// This function is equivalent to
/// [`interval_at(Instant::now(), period)`](interval_at).
///
/// # Panics
///
/// This function panics if `period` is zero.
///
/// # Examples
///
/// ```
/// use tokio::time::{self, Duration};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(Duration::from_millis(10));
///
/// interval.tick().await; // ticks immediately
/// interval.tick().await; // ticks after 10ms
/// interval.tick().await; // ticks after 10ms
///
/// // approximately 20ms have elapsed.
/// # }
/// ```
///
/// A simple example using `interval` to execute a task every two seconds.
///
/// The difference between `interval` and [`sleep`] is that an [`Interval`]
/// measures the time since the last tick, which means that [`.tick().await`]
/// may wait for a shorter time than the duration specified for the interval
/// if some time has passed between calls to [`.tick().await`].
///
/// If the tick in the example below was replaced with [`sleep`], the task
/// would only be executed once every three seconds, and not every two
/// seconds.
///
/// ```
/// use tokio::time;
///
/// async fn task_that_takes_a_second() {
///     println!("hello");
///     time::sleep(time::Duration::from_secs(1)).await
/// }
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut interval = time::interval(time::Duration::from_secs(2));
/// for _i in 0..5 {
///     interval.tick().await;
///     task_that_takes_a_second().await;
/// }
/// # }
/// ```
///
/// [`sleep`]: crate::time::sleep()
/// [`.tick().await`]: Interval::tick
Future<Interval> interval({required Duration period}) =>
    RustLib.instance.api.tokioTimeInterval(period: period);

/// Creates new [`Interval`] that yields with interval of `period` with the
/// first tick completing at `start`. The default [`MissedTickBehavior`] is
/// [`Burst`](MissedTickBehavior::Burst), but this can be configured
/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).
///
/// An interval will tick indefinitely. At any time, the [`Interval`] value can
/// be dropped. This cancels the interval.
///
/// # Panics
///
/// This function panics if `period` is zero.
///
/// # Examples
///
/// ```
/// use tokio::time::{interval_at, Duration, Instant};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let start = Instant::now() + Duration::from_millis(50);
/// let mut interval = interval_at(start, Duration::from_millis(10));
///
/// interval.tick().await; // ticks after 50ms
/// interval.tick().await; // ticks after 10ms
/// interval.tick().await; // ticks after 10ms
///
/// // approximately 70ms have elapsed.
/// # }
/// ```
Future<Interval> intervalAt(
        {required Instant start, required Duration period}) =>
    RustLib.instance.api.tokioTimeIntervalAt(start: start, period: period);

/// Waits until `deadline` is reached.
///
/// No work is performed while awaiting on the sleep future to complete. `Sleep`
/// operates at millisecond granularity and should not be used for tasks that
/// require high-resolution timers.
///
/// To run something regularly on a schedule, see [`interval`].
///
/// # Cancellation
///
/// Canceling a sleep instance is done by dropping the returned future. No additional
/// cleanup work is required.
///
/// # Examples
///
/// Wait 100ms and print "100 ms have elapsed".
///
/// ```
/// use tokio::time::{sleep_until, Instant, Duration};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// sleep_until(Instant::now() + Duration::from_millis(100)).await;
/// println!("100 ms have elapsed");
/// # }
/// ```
///
/// See the documentation for the [`Sleep`] type for more examples.
///
/// # Panics
///
/// This function panics if there is no current timer set.
///
/// It can be triggered when [`Builder::enable_time`] or
/// [`Builder::enable_all`] are not included in the builder.
///
/// It can also panic whenever a timer is created outside of a
/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,
/// since the function is executed outside of the runtime.
/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.
/// And this is because wrapping the function on an async makes it lazy,
/// and so gets executed inside the runtime successfully without
/// panicking.
///
/// [`Sleep`]: struct@crate::time::Sleep
/// [`interval`]: crate::time::interval()
/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time
/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all
Future<Sleep> sleepUntil({required Instant deadline}) =>
    RustLib.instance.api.tokioTimeSleepUntil(deadline: deadline);

/// Waits until `duration` has elapsed.
///
/// Equivalent to `sleep_until(Instant::now() + duration)`. An asynchronous
/// analog to `std::thread::sleep`.
///
/// No work is performed while awaiting on the sleep future to complete. `Sleep`
/// operates at millisecond granularity and should not be used for tasks that
/// require high-resolution timers. The implementation is platform specific,
/// and some platforms (specifically Windows) will provide timers with a
/// larger resolution than 1 ms.
///
/// To run something regularly on a schedule, see [`interval`].
///
/// # Cancellation
///
/// Canceling a sleep instance is done by dropping the returned future. No additional
/// cleanup work is required.
///
/// # Examples
///
/// Wait 100ms and print "100 ms have elapsed".
///
/// ```
/// use tokio::time::{sleep, Duration};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// sleep(Duration::from_millis(100)).await;
/// println!("100 ms have elapsed");
/// # }
/// ```
///
/// See the documentation for the [`Sleep`] type for more examples.
///
/// # Panics
///
/// This function panics if there is no current timer set.
///
/// It can be triggered when [`Builder::enable_time`] or
/// [`Builder::enable_all`] are not included in the builder.
///
/// It can also panic whenever a timer is created outside of a
/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,
/// since the function is executed outside of the runtime.
/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.
/// And this is because wrapping the function on an async makes it lazy,
/// and so gets executed inside the runtime successfully without
/// panicking.
///
/// [`Sleep`]: struct@crate::time::Sleep
/// [`interval`]: crate::time::interval()
/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time
/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all
Future<Sleep> sleep({required Duration duration}) =>
    RustLib.instance.api.tokioTimeSleep(duration: duration);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Interval>>
abstract class Interval implements RustOpaqueInterface {
  /// Returns the [`MissedTickBehavior`] strategy currently being used.
  Future<MissedTickBehavior> missedTickBehavior();

  /// Returns the period of the interval.
  Future<Duration> period();

  /// Polls for the next instant in the interval to be reached.
  ///
  /// This method can return the following values:
  ///
  ///  * `Poll::Pending` if the next instant has not yet been reached.
  ///  * `Poll::Ready(instant)` if the next instant has been reached.
  ///
  /// When this method returns `Poll::Pending`, the current task is scheduled
  /// to receive a wakeup when the instant has elapsed. Note that on multiple
  /// calls to `poll_tick`, only the [`Waker`](std::task::Waker) from the
  /// [`Context`] passed to the most recent call is scheduled to receive a
  /// wakeup.
  Future<PollInstant> pollTick({required Context cx});

  /// Resets the interval to complete one period after the current time.
  ///
  /// This method ignores [`MissedTickBehavior`] strategy.
  ///
  /// This is equivalent to calling `reset_at(Instant::now() + period)`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::time;
  ///
  /// use std::time::Duration;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = time::interval(Duration::from_millis(100));
  ///
  /// interval.tick().await;
  ///
  /// time::sleep(Duration::from_millis(50)).await;
  /// interval.reset();
  ///
  /// interval.tick().await;
  /// interval.tick().await;
  ///
  /// // approximately 250ms have elapsed.
  /// # }
  /// ```
  Future<void> reset();

  /// Resets the interval after the specified [`std::time::Duration`].
  ///
  /// This method ignores [`MissedTickBehavior`] strategy.
  ///
  /// This is equivalent to calling `reset_at(Instant::now() + after)`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::time;
  ///
  /// use std::time::Duration;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = time::interval(Duration::from_millis(100));
  /// interval.tick().await;
  ///
  /// time::sleep(Duration::from_millis(50)).await;
  ///
  /// let after = Duration::from_millis(20);
  /// interval.reset_after(after);
  ///
  /// interval.tick().await;
  /// interval.tick().await;
  ///
  /// // approximately 170ms have elapsed.
  /// # }
  /// ```
  Future<void> resetAfter({required Duration after});

  /// Resets the interval to a [`crate::time::Instant`] deadline.
  ///
  /// Sets the next tick to expire at the given instant. If the instant is in
  /// the past, then the [`MissedTickBehavior`] strategy will be used to
  /// catch up. If the instant is in the future, then the next tick will
  /// complete at the given instant, even if that means that it will sleep for
  /// longer than the duration of this [`Interval`]. If the [`Interval`] had
  /// any missed ticks before calling this method, then those are discarded.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::time::{self, Instant};
  ///
  /// use std::time::Duration;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = time::interval(Duration::from_millis(100));
  /// interval.tick().await;
  ///
  /// time::sleep(Duration::from_millis(50)).await;
  ///
  /// let deadline = Instant::now() + Duration::from_millis(30);
  /// interval.reset_at(deadline);
  ///
  /// interval.tick().await;
  /// interval.tick().await;
  ///
  /// // approximately 180ms have elapsed.
  /// # }
  /// ```
  Future<void> resetAt({required Instant deadline});

  /// Resets the interval immediately.
  ///
  /// This method ignores [`MissedTickBehavior`] strategy.
  ///
  /// This is equivalent to calling `reset_at(Instant::now())`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::time;
  ///
  /// use std::time::Duration;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = time::interval(Duration::from_millis(100));
  ///
  /// interval.tick().await;
  ///
  /// time::sleep(Duration::from_millis(50)).await;
  /// interval.reset_immediately();
  ///
  /// interval.tick().await;
  /// interval.tick().await;
  ///
  /// // approximately 150ms have elapsed.
  /// # }
  /// ```
  Future<void> resetImmediately();

  /// Sets the [`MissedTickBehavior`] strategy that should be used.
  Future<void> setMissedTickBehavior({required MissedTickBehavior behavior});

  /// Completes when the next instant in the interval has been reached.
  ///
  /// # Cancel safety
  ///
  /// This method is cancellation safe. If `tick` is used as the branch in a `tokio::select!` and
  /// another branch completes first, then no tick has been consumed.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::time;
  ///
  /// use std::time::Duration;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = time::interval(Duration::from_millis(10));
  ///
  /// interval.tick().await;
  /// // approximately 0ms have elapsed. The first tick completes immediately.
  /// interval.tick().await;
  /// interval.tick().await;
  ///
  /// // approximately 20ms have elapsed.
  /// # }
  /// ```
  Future<Instant> tick();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sleep>>
abstract class Sleep implements RustOpaqueInterface {
  /// Returns the instant at which the future will complete.
  Future<Instant> deadline();

  /// Returns `true` if `Sleep` has elapsed.
  ///
  /// A `Sleep` instance is elapsed when the requested duration has elapsed.
  Future<bool> isElapsed();

  /// Resets the `Sleep` instance to a new deadline.
  ///
  /// Calling this function allows changing the instant at which the `Sleep`
  /// future completes without having to create new associated state.
  ///
  /// This function can be called both before and after the future has
  /// completed.
  ///
  /// To call this method, you will usually combine the call with
  /// [`Pin::as_mut`], which lets you call the method without consuming the
  /// `Sleep` itself.
  ///
  /// # Example
  ///
  /// ```
  /// use tokio::time::{Duration, Instant};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let sleep = tokio::time::sleep(Duration::from_millis(10));
  /// tokio::pin!(sleep);
  ///
  /// sleep.as_mut().reset(Instant::now() + Duration::from_millis(20));
  /// # }
  /// ```
  ///
  /// See also the top-level examples.
  ///
  /// [`Pin::as_mut`]: fn@std::pin::Pin::as_mut
  Future<void> reset({required Instant deadline});
}

/// Defines the behavior of an [`Interval`] when it misses a tick.
///
/// Sometimes, an [`Interval`]'s tick is missed. For example, consider the
/// following:
///
/// ```
/// use tokio::time::{self, Duration};
/// # async fn task_that_takes_one_to_three_millis() {}
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// // ticks every 2 milliseconds
/// let mut interval = time::interval(Duration::from_millis(2));
/// for _ in 0..5 {
///     interval.tick().await;
///     // if this takes more than 2 milliseconds, a tick will be delayed
///     task_that_takes_one_to_three_millis().await;
/// }
/// # }
/// ```
///
/// Generally, a tick is missed if too much time is spent without calling
/// [`Interval::tick()`].
///
/// By default, when a tick is missed, [`Interval`] fires ticks as quickly as it
/// can until it is "caught up" in time to where it should be.
/// `MissedTickBehavior` can be used to specify a different behavior for
/// [`Interval`] to exhibit. Each variant represents a different strategy.
///
/// Note that because the executor cannot guarantee exact precision with timers,
/// these strategies will only apply when the delay is greater than 5
/// milliseconds.
enum MissedTickBehavior {
  /// Ticks as fast as possible until caught up.
  ///
  /// When this strategy is used, [`Interval`] schedules ticks "normally" (the
  /// same as it would have if the ticks hadn't been delayed), which results
  /// in it firing ticks as fast as possible until it is caught up in time to
  /// where it should be. Unlike [`Delay`] and [`Skip`], the ticks yielded
  /// when `Burst` is used (the [`Instant`]s that [`tick`](Interval::tick)
  /// yields) aren't different than they would have been if a tick had not
  /// been missed. Like [`Skip`], and unlike [`Delay`], the ticks may be
  /// shortened.
  ///
  /// This looks something like this:
  /// ```text
  /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |
  /// Actual ticks:   | work -----|          delay          | work | work | work -| work -----|
  /// ```
  ///
  /// In code:
  ///
  /// ```
  /// use tokio::time::{interval, Duration};
  /// # async fn task_that_takes_200_millis() {}
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = interval(Duration::from_millis(50));
  ///
  /// // First tick resolves immediately after creation
  /// interval.tick().await;
  ///
  /// task_that_takes_200_millis().await;
  /// // The `Interval` has missed a tick
  ///
  /// // Since we have exceeded our timeout, this will resolve immediately
  /// interval.tick().await;
  ///
  /// // Since we are more than 100ms after the start of `interval`, this will
  /// // also resolve immediately.
  /// interval.tick().await;
  ///
  /// // Also resolves immediately, because it was supposed to resolve at
  /// // 150ms after the start of `interval`
  /// interval.tick().await;
  ///
  /// // Resolves immediately
  /// interval.tick().await;
  ///
  /// // Since we have gotten to 200ms after the start of `interval`, this
  /// // will resolve after 50ms
  /// interval.tick().await;
  /// # }
  /// ```
  ///
  /// This is the default behavior when [`Interval`] is created with
  /// [`interval`] and [`interval_at`].
  ///
  /// [`Delay`]: MissedTickBehavior::Delay
  /// [`Skip`]: MissedTickBehavior::Skip
  burst,

  /// Tick at multiples of `period` from when [`tick`] was called, rather than
  /// from `start`.
  ///
  /// When this strategy is used and [`Interval`] has missed a tick, instead
  /// of scheduling ticks to fire at multiples of `period` from `start` (the
  /// time when the first tick was fired), it schedules all future ticks to
  /// happen at a regular `period` from the point when [`tick`] was called.
  /// Unlike [`Burst`] and [`Skip`], ticks are not shortened, and they aren't
  /// guaranteed to happen at a multiple of `period` from `start` any longer.
  ///
  /// This looks something like this:
  /// ```text
  /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |
  /// Actual ticks:   | work -----|          delay          | work -----| work -----| work -----|
  /// ```
  ///
  /// In code:
  ///
  /// ```
  /// use tokio::time::{interval, Duration, MissedTickBehavior};
  /// # async fn task_that_takes_more_than_50_millis() {}
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = interval(Duration::from_millis(50));
  /// interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
  ///
  /// task_that_takes_more_than_50_millis().await;
  /// // The `Interval` has missed a tick
  ///
  /// // Since we have exceeded our timeout, this will resolve immediately
  /// interval.tick().await;
  ///
  /// // But this one, rather than also resolving immediately, as might happen
  /// // with the `Burst` or `Skip` behaviors, will not resolve until
  /// // 50ms after the call to `tick` up above. That is, in `tick`, when we
  /// // recognize that we missed a tick, we schedule the next tick to happen
  /// // 50ms (or whatever the `period` is) from right then, not from when
  /// // were *supposed* to tick
  /// interval.tick().await;
  /// # }
  /// ```
  ///
  /// [`Burst`]: MissedTickBehavior::Burst
  /// [`Skip`]: MissedTickBehavior::Skip
  /// [`tick`]: Interval::tick
  delay,

  /// Skips missed ticks and tick on the next multiple of `period` from
  /// `start`.
  ///
  /// When this strategy is used, [`Interval`] schedules the next tick to fire
  /// at the next-closest tick that is a multiple of `period` away from
  /// `start` (the point where [`Interval`] first ticked). Like [`Burst`], all
  /// ticks remain multiples of `period` away from `start`, but unlike
  /// [`Burst`], the ticks may not be *one* multiple of `period` away from the
  /// last tick. Like [`Delay`], the ticks are no longer the same as they
  /// would have been if ticks had not been missed, but unlike [`Delay`], and
  /// like [`Burst`], the ticks may be shortened to be less than one `period`
  /// away from each other.
  ///
  /// This looks something like this:
  /// ```text
  /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |
  /// Actual ticks:   | work -----|          delay          | work ---| work -----| work -----|
  /// ```
  ///
  /// In code:
  ///
  /// ```
  /// use tokio::time::{interval, Duration, MissedTickBehavior};
  /// # async fn task_that_takes_75_millis() {}
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut interval = interval(Duration::from_millis(50));
  /// interval.set_missed_tick_behavior(MissedTickBehavior::Skip);
  ///
  /// task_that_takes_75_millis().await;
  /// // The `Interval` has missed a tick
  ///
  /// // Since we have exceeded our timeout, this will resolve immediately
  /// interval.tick().await;
  ///
  /// // This one will resolve after 25ms, 100ms after the start of
  /// // `interval`, which is the closest multiple of `period` from the start
  /// // of `interval` after the call to `tick` up above.
  /// interval.tick().await;
  /// # }
  /// ```
  ///
  /// [`Burst`]: MissedTickBehavior::Burst
  /// [`Delay`]: MissedTickBehavior::Delay
  skip,
  ;

  /// Returns [`MissedTickBehavior::Burst`].
  ///
  /// For most usecases, the [`Burst`] strategy is what is desired.
  /// Additionally, to preserve backwards compatibility, the [`Burst`]
  /// strategy must be the default. For these reasons,
  /// [`MissedTickBehavior::Burst`] is the default for [`MissedTickBehavior`].
  /// See [`Burst`] for more details.
  ///
  /// [`Burst`]: MissedTickBehavior::Burst
  static Future<MissedTickBehavior> default_() =>
      RustLib.instance.api.tokioTimeMissedTickBehaviorDefault();
}
