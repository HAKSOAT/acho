// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `chain`, `chain`, `copy_bidirectional_with_sizes`, `copy_bidirectional`, `copy_buf`, `copy`, `join`, `read_buf`, `read_buf`, `read_exact`, `read_exact`, `read_line`, `read_line`, `read_to_end`, `read_to_end`, `read_to_string`, `read_to_string`, `read_until`, `read_until`, `read`, `read`, `split`, `write_all_buf`, `write_all_buf`, `write_all`, `write_all`, `write_buf`, `write_buf`, `write_vectored`, `write_vectored`, `write`, `write`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BufReader`, `BufStream`, `BufWriter`, `Chain`, `Join`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `consume`, `fill_buf`, `flush`, `lines`, `read_f32_le`, `read_f32`, `read_f64_le`, `read_f64`, `read_i128_le`, `read_i128`, `read_i16_le`, `read_i16`, `read_i32_le`, `read_i32`, `read_i64_le`, `read_i64`, `read_i8`, `read_u128_le`, `read_u128`, `read_u16_le`, `read_u16`, `read_u32_le`, `read_u32`, `read_u64_le`, `read_u64`, `read_u8`, `rewind`, `seek`, `shutdown`, `split`, `stream_position`, `take`, `write_f32_le`, `write_f32`, `write_f64_le`, `write_f64`, `write_i128_le`, `write_i128`, `write_i16_le`, `write_i16`, `write_i32_le`, `write_i32`, `write_i64_le`, `write_i64`, `write_i8`, `write_u128_le`, `write_u128`, `write_u16_le`, `write_u16`, `write_u32_le`, `write_u32`, `write_u64_le`, `write_u64`, `write_u8`

/// Constructs a new handle to the standard error of the current process.
///
/// The returned handle allows writing to standard error from the within the
/// Tokio runtime.
///
/// Concurrent writes to stderr must be executed with care: Only individual
/// writes to this [`AsyncWrite`] are guaranteed to be intact. In particular
/// you should be aware that writes using [`write_all`] are not guaranteed
/// to occur as a single write, so multiple threads writing data with
/// [`write_all`] may result in interleaved output.
///
/// [`AsyncWrite`]: AsyncWrite
/// [`write_all`]: crate::io::AsyncWriteExt::write_all()
///
/// # Examples
///
/// ```
/// use tokio::io::{self, AsyncWriteExt};
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let mut stderr = io::stderr();
///     stderr.write_all(b"Print some error here.").await?;
///     Ok(())
/// }
/// ```
Future<Stderr> stderr() => RustLib.instance.api.tokioIoStderr();

/// Constructs a new handle to the standard input of the current process.
///
/// This handle is best used for non-interactive uses, such as when a file
/// is piped into the application. For technical reasons, `stdin` is
/// implemented by using an ordinary blocking read on a separate thread, and
/// it is impossible to cancel that read. This can make shutdown of the
/// runtime hang until the user presses enter.
///
/// For interactive uses, it is recommended to spawn a thread dedicated to
/// user input and use blocking IO directly in that thread.
Future<Stdin> stdin() => RustLib.instance.api.tokioIoStdin();

/// Constructs a new handle to the standard output of the current process.
///
/// The returned handle allows writing to standard out from the within the
/// Tokio runtime.
///
/// Concurrent writes to stdout must be executed with care: Only individual
/// writes to this [`AsyncWrite`] are guaranteed to be intact. In particular
/// you should be aware that writes using [`write_all`] are not guaranteed
/// to occur as a single write, so multiple threads writing data with
/// [`write_all`] may result in interleaved output.
///
/// [`AsyncWrite`]: AsyncWrite
/// [`write_all`]: crate::io::AsyncWriteExt::write_all()
///
/// # Examples
///
/// ```
/// use tokio::io::{self, AsyncWriteExt};
///
/// #[tokio::main]
/// async fn main() -> io::Result<()> {
///     let mut stdout = io::stdout();
///     stdout.write_all(b"Hello world!").await?;
///     Ok(())
/// }
/// ```
///
/// The following is an example of using `stdio` with loop.
///
/// ```
/// use tokio::io::{self, AsyncWriteExt};
///
/// #[tokio::main]
/// async fn main() {
///     let messages = vec!["hello", " world\n"];
///
///     // When you use `stdio` in a loop, it is recommended to create
///     // a single `stdio` instance outside the loop and call a write
///     // operation against that instance on each loop.
///     //
///     // Repeatedly creating `stdout` instances inside the loop and
///     // writing to that handle could result in mangled output since
///     // each write operation is handled by a different blocking thread.
///     let mut stdout = io::stdout();
///
///     for message in &messages {
///         stdout.write_all(message.as_bytes()).await.unwrap();
///         stdout.flush().await.unwrap();
///     }
/// }
/// ```
Future<Stdout> stdout() => RustLib.instance.api.tokioIoStdout();

/// Creates a value that is always at EOF for reads, and ignores all data written.
///
/// All writes on the returned instance will return `Poll::Ready(Ok(buf.len()))`
/// and the contents of the buffer will not be inspected.
///
/// All reads from the returned instance will return `Poll::Ready(Ok(0))`.
///
/// This is an asynchronous version of [`std::io::empty`][std].
///
/// [std]: std::io::empty
///
/// # Examples
///
/// A slightly sad example of not reading anything into a buffer:
///
/// ```
/// use tokio::io::{self, AsyncReadExt};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
///     let mut buffer = String::new();
///     io::empty().read_to_string(&mut buffer).await.unwrap();
///     assert!(buffer.is_empty());
/// # }
/// ```
///
/// A convoluted way of getting the length of a buffer:
///
/// ```
/// use tokio::io::{self, AsyncWriteExt};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let buffer = vec![1, 2, 3, 5, 8];
/// let num_bytes = io::empty().write(&buffer).await.unwrap();
/// assert_eq!(num_bytes, 5);
/// # }
/// ```
Future<Empty> empty() => RustLib.instance.api.tokioIoEmpty();

/// Create a new pair of `DuplexStream`s that act like a pair of connected sockets.
///
/// The `max_buf_size` argument is the maximum amount of bytes that can be
/// written to a side before the write returns `Poll::Pending`.
Future<(DuplexStream, DuplexStream)> duplex({required BigInt maxBufSize}) =>
    RustLib.instance.api.tokioIoDuplex(maxBufSize: maxBufSize);

/// Creates unidirectional buffer that acts like in memory pipe.
///
/// The `max_buf_size` argument is the maximum amount of bytes that can be
/// written to a buffer before the it returns `Poll::Pending`.
///
/// # Unify reader and writer
///
/// The reader and writer half can be unified into a single structure
/// of `SimplexStream` that supports both reading and writing or
/// the `SimplexStream` can be already created as unified structure
/// using [`SimplexStream::new_unsplit()`].
///
/// ```
/// # async fn ex() -> std::io::Result<()> {
/// # use tokio::io::{AsyncReadExt, AsyncWriteExt};
/// let (reader, writer) = tokio::io::simplex(64);
/// let mut simplex_stream = reader.unsplit(writer);
/// simplex_stream.write_all(b"hello").await?;
///
/// let mut buf = [0u8; 5];
/// simplex_stream.read_exact(&mut buf).await?;
/// assert_eq!(&buf, b"hello");
/// # Ok(())
/// # }
/// ```
Future<(ReadHalfSimplexStream, WriteHalfSimplexStream)> simplex(
        {required BigInt maxBufSize}) =>
    RustLib.instance.api.tokioIoSimplex(maxBufSize: maxBufSize);

/// Creates an instance of an async reader that infinitely repeats one byte.
///
/// All reads from this reader will succeed by filling the specified buffer with
/// the given byte.
///
/// This is an asynchronous version of [`std::io::repeat`][std].
///
/// [std]: std::io::repeat
///
/// # Examples
///
/// ```
/// use tokio::io::{self, AsyncReadExt};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() {
/// let mut buffer = [0; 3];
/// io::repeat(0b101).read_exact(&mut buffer).await.unwrap();
/// assert_eq!(buffer, [0b101, 0b101, 0b101]);
/// # }
/// ```
Future<Repeat> repeat({required int byte}) =>
    RustLib.instance.api.tokioIoRepeat(byte: byte);

/// Creates an instance of an async writer which will successfully consume all
/// data.
///
/// All calls to [`poll_write`] on the returned instance will return
/// `Poll::Ready(Ok(buf.len()))` and the contents of the buffer will not be
/// inspected.
///
/// This is an asynchronous version of [`std::io::sink`][std].
///
/// [`poll_write`]: crate::io::AsyncWrite::poll_write()
/// [std]: std::io::sink
///
/// # Examples
///
/// ```
/// use tokio::io::{self, AsyncWriteExt};
///
/// # #[tokio::main(flavor = "current_thread")]
/// # async fn main() -> io::Result<()> {
/// let buffer = vec![1, 2, 3, 5, 8];
/// let num_bytes = io::sink().write(&buffer).await?;
/// assert_eq!(num_bytes, 5);
/// Ok(())
/// # }
/// ```
Future<Sink> sink() => RustLib.instance.api.tokioIoSink();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DuplexStream>>
abstract class DuplexStream implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Empty>>
abstract class Empty implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FillBuf < 'static, Self >>>
abstract class FillBufSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Flush < 'static, Self >>>
abstract class FlushSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Interest>>
abstract class Interest implements RustOpaqueInterface {
  /// Add together two `Interest` values.
  ///
  /// This function works from a `const` context.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// const BOTH: Interest = Interest::READABLE.add(Interest::WRITABLE);
  ///
  /// assert!(BOTH.is_readable());
  /// assert!(BOTH.is_writable());
  Future<Interest> add({required Interest other});

  /// Returns true if the value includes error interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(Interest::ERROR.is_error());
  /// assert!(!Interest::WRITABLE.is_error());
  ///
  /// let combined = Interest::READABLE | Interest::ERROR;
  /// assert!(combined.is_error());
  /// ```
  Future<bool> isError();

  /// Returns true if the value includes readable interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(Interest::READABLE.is_readable());
  /// assert!(!Interest::WRITABLE.is_readable());
  ///
  /// let both = Interest::READABLE | Interest::WRITABLE;
  /// assert!(both.is_readable());
  /// ```
  Future<bool> isReadable();

  /// Returns true if the value includes writable interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(!Interest::READABLE.is_writable());
  /// assert!(Interest::WRITABLE.is_writable());
  ///
  /// let both = Interest::READABLE | Interest::WRITABLE;
  /// assert!(both.is_writable());
  /// ```
  Future<bool> isWritable();

  /// Remove `Interest` from `self`.
  ///
  /// Interests present in `other` but *not* in `self` are ignored.
  ///
  /// Returns `None` if the set would be empty after removing `Interest`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// const RW_INTEREST: Interest = Interest::READABLE.add(Interest::WRITABLE);
  ///
  /// let w_interest = RW_INTEREST.remove(Interest::READABLE).unwrap();
  /// assert!(!w_interest.is_readable());
  /// assert!(w_interest.is_writable());
  ///
  /// // Removing all interests from the set returns `None`.
  /// assert_eq!(w_interest.remove(Interest::WRITABLE), None);
  ///
  /// // Remove all interests at once.
  /// assert_eq!(RW_INTEREST.remove(RW_INTEREST), None);
  /// ```
  Future<Interest?> remove({required Interest other});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Lines < Self >>>
abstract class LinesSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadF32Le < & mut Self >>>
abstract class ReadF32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadF32 < & mut Self >>>
abstract class ReadF32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadF64Le < & mut Self >>>
abstract class ReadF64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadF64 < & mut Self >>>
abstract class ReadF64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadHalf < SimplexStream >>>
abstract class ReadHalfSimplexStream implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI128Le < & mut Self >>>
abstract class ReadI128LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI128 < & mut Self >>>
abstract class ReadI128MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI16Le < & mut Self >>>
abstract class ReadI16LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI16 < & mut Self >>>
abstract class ReadI16MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI32Le < & mut Self >>>
abstract class ReadI32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI32 < & mut Self >>>
abstract class ReadI32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI64Le < & mut Self >>>
abstract class ReadI64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI64 < & mut Self >>>
abstract class ReadI64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadI8 < & mut Self >>>
abstract class ReadI8MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU128Le < & mut Self >>>
abstract class ReadU128LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU128 < & mut Self >>>
abstract class ReadU128MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU16Le < & mut Self >>>
abstract class ReadU16LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU16 < & mut Self >>>
abstract class ReadU16MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU32Le < & mut Self >>>
abstract class ReadU32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU32 < & mut Self >>>
abstract class ReadU32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU64Le < & mut Self >>>
abstract class ReadU64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU64 < & mut Self >>>
abstract class ReadU64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReadU8 < & mut Self >>>
abstract class ReadU8MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ready>>
abstract class Ready implements RustOpaqueInterface {
  /// Returns true if `Ready` is the empty set.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(Ready::EMPTY.is_empty());
  /// assert!(!Ready::READABLE.is_empty());
  /// ```
  Future<bool> isEmpty();

  /// Returns `true` if the value includes error `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_error());
  /// assert!(!Ready::WRITABLE.is_error());
  /// assert!(Ready::ERROR.is_error());
  /// ```
  Future<bool> isError();

  /// Returns `true` if the value includes read-closed `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_read_closed());
  /// assert!(!Ready::READABLE.is_read_closed());
  /// assert!(Ready::READ_CLOSED.is_read_closed());
  /// ```
  Future<bool> isReadClosed();

  /// Returns `true` if the value includes `readable`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_readable());
  /// assert!(Ready::READABLE.is_readable());
  /// assert!(Ready::READ_CLOSED.is_readable());
  /// assert!(!Ready::WRITABLE.is_readable());
  /// ```
  Future<bool> isReadable();

  /// Returns `true` if the value includes writable `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_writable());
  /// assert!(!Ready::READABLE.is_writable());
  /// assert!(Ready::WRITABLE.is_writable());
  /// assert!(Ready::WRITE_CLOSED.is_writable());
  /// ```
  Future<bool> isWritable();

  /// Returns `true` if the value includes write-closed `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_write_closed());
  /// assert!(!Ready::WRITABLE.is_write_closed());
  /// assert!(Ready::WRITE_CLOSED.is_write_closed());
  /// ```
  Future<bool> isWriteClosed();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Repeat>>
abstract class Repeat implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SeekFrom>>
abstract class SeekFrom implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Seek < 'static, Self >>>
abstract class SeekSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Shutdown < 'static, Self >>>
abstract class ShutdownSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SimplexStream>>
abstract class SimplexStream implements RustOpaqueInterface {
  /// Creates unidirectional buffer that acts like in memory pipe. To create split
  /// version with separate reader and writer you can use [`simplex`] function.
  ///
  /// The `max_buf_size` argument is the maximum amount of bytes that can be
  /// written to a buffer before the it returns `Poll::Pending`.
  static Future<SimplexStream> newUnsplit({required BigInt maxBufSize}) =>
      RustLib.instance.api
          .tokioIoSimplexStreamNewUnsplit(maxBufSize: maxBufSize);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sink>>
abstract class Sink implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Split < Self >>>
abstract class SplitSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stderr>>
abstract class Stderr implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stdin>>
abstract class Stdin implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stdout>>
abstract class Stdout implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Take < Self >>>
abstract class TakeSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteF32Le < & mut Self >>>
abstract class WriteF32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteF32 < & mut Self >>>
abstract class WriteF32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteF64Le < & mut Self >>>
abstract class WriteF64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteF64 < & mut Self >>>
abstract class WriteF64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteHalf < SimplexStream >>>
abstract class WriteHalfSimplexStream implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI128Le < & mut Self >>>
abstract class WriteI128LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI128 < & mut Self >>>
abstract class WriteI128MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI16Le < & mut Self >>>
abstract class WriteI16LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI16 < & mut Self >>>
abstract class WriteI16MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI32Le < & mut Self >>>
abstract class WriteI32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI32 < & mut Self >>>
abstract class WriteI32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI64Le < & mut Self >>>
abstract class WriteI64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI64 < & mut Self >>>
abstract class WriteI64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteI8 < & mut Self >>>
abstract class WriteI8MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU128Le < & mut Self >>>
abstract class WriteU128LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU128 < & mut Self >>>
abstract class WriteU128MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU16Le < & mut Self >>>
abstract class WriteU16LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU16 < & mut Self >>>
abstract class WriteU16MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU32Le < & mut Self >>>
abstract class WriteU32LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU32 < & mut Self >>>
abstract class WriteU32MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU64Le < & mut Self >>>
abstract class WriteU64LeMutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU64 < & mut Self >>>
abstract class WriteU64MutSelf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WriteU8 < & mut Self >>>
abstract class WriteU8MutSelf implements RustOpaqueInterface {}

abstract class AsyncBufReadExt {
  /// Tells this buffer that `amt` bytes have been consumed from the
  /// buffer, so they should no longer be returned in calls to [`read`].
  ///
  /// This function is a lower-level call. It needs to be paired with the
  /// [`fill_buf`] method to function properly. This function does not
  /// perform any I/O, it simply informs this object that some amount of
  /// its buffer, returned from [`fill_buf`], has been consumed and should
  /// no longer be returned. As such, this function may do odd things if
  /// [`fill_buf`] isn't called before calling it.
  ///
  /// The `amt` must be less than the number of bytes in the buffer
  /// returned by [`fill_buf`].
  ///
  /// [`read`]: crate::io::AsyncReadExt::read
  /// [`fill_buf`]: crate::io::AsyncBufReadExt::fill_buf
  Future<void> consume({required BigInt amt});

  /// Returns the contents of the internal buffer, filling it with more
  /// data from the inner reader if it is empty.
  ///
  /// This function is a lower-level call. It needs to be paired with the
  /// [`consume`] method to function properly. When calling this method,
  /// none of the contents will be "read" in the sense that later calling
  /// `read` may return the same contents. As such, [`consume`] must be
  /// called with the number of bytes that are consumed from this buffer
  /// to ensure that the bytes are never returned twice.
  ///
  /// An empty buffer returned indicates that the stream has reached EOF.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn fill_buf(&mut self) -> io::Result<&[u8]>;
  /// ```
  ///
  /// # Errors
  ///
  /// This function will return an I/O error if the underlying reader was
  /// read, but returned an error.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If you use it as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, then it is guaranteed that no data was read.
  ///
  /// [`consume`]: crate::io::AsyncBufReadExt::consume
  Future<FillBufSelf> fillBuf();

  /// Returns a stream over the lines of this reader.
  /// This method is the async equivalent to [`BufRead::lines`](std::io::BufRead::lines).
  ///
  /// The stream returned from this function will yield instances of
  /// [`io::Result`]`<`[`Option`]`<`[`String`]`>>`. Each string returned will *not* have a newline
  /// byte (the 0xA byte) or `CRLF` (0xD, 0xA bytes) at the end.
  ///
  /// [`io::Result`]: std::io::Result
  /// [`Option`]: core::option::Option
  /// [`String`]: String
  ///
  /// # Errors
  ///
  /// Each line of the stream has the same error semantics as [`AsyncBufReadExt::read_line`].
  ///
  /// # Examples
  ///
  /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In
  /// this example, we use [`Cursor`] to iterate over all the lines in a byte
  /// slice.
  ///
  /// [`Cursor`]: std::io::Cursor
  ///
  /// ```
  /// use tokio::io::AsyncBufReadExt;
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let cursor = Cursor::new(b"lorem\nipsum\r\ndolor");
  ///
  /// let mut lines = cursor.lines();
  ///
  /// assert_eq!(lines.next_line().await.unwrap(), Some(String::from("lorem")));
  /// assert_eq!(lines.next_line().await.unwrap(), Some(String::from("ipsum")));
  /// assert_eq!(lines.next_line().await.unwrap(), Some(String::from("dolor")));
  /// assert_eq!(lines.next_line().await.unwrap(), None);
  /// # }
  /// ```
  ///
  /// [`AsyncBufReadExt::read_line`]: AsyncBufReadExt::read_line
  Future<LinesSelf> lines();

  /// Returns a stream of the contents of this reader split on the byte
  /// `byte`.
  ///
  /// This method is the asynchronous equivalent to
  /// [`BufRead::split`](std::io::BufRead::split).
  ///
  /// The stream returned from this function will yield instances of
  /// [`io::Result`]`<`[`Option`]`<`[`Vec<u8>`]`>>`. Each vector returned will *not* have
  /// the delimiter byte at the end.
  ///
  /// [`io::Result`]: std::io::Result
  /// [`Option`]: core::option::Option
  /// [`Vec<u8>`]: std::vec::Vec
  ///
  /// # Errors
  ///
  /// Each item of the stream has the same error semantics as
  /// [`AsyncBufReadExt::read_until`](AsyncBufReadExt::read_until).
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncBufRead;
  /// use tokio::io::AsyncBufReadExt;
  ///
  /// # async fn dox(my_buf_read: impl AsyncBufRead + Unpin) -> std::io::Result<()> {
  /// let mut segments = my_buf_read.split(b'f');
  ///
  /// while let Some(segment) = segments.next_segment().await? {
  ///     println!("length = {}", segment.len())
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<SplitSelf> split({required int byte});
}

abstract class AsyncReadExt {
  /// Reads an 32-bit floating point type in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_f32(&mut self) -> io::Result<f32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read 32-bit floating point type from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0xff, 0x7f, 0xff, 0xff]);
  ///
  /// assert_eq!(f32::MIN, reader.read_f32().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadF32MutSelf> readF32();

  /// Reads an 32-bit floating point type in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_f32_le(&mut self) -> io::Result<f32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read 32-bit floating point type from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7f, 0xff]);
  ///
  /// assert_eq!(f32::MIN, reader.read_f32_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadF32LeMutSelf> readF32Le();

  /// Reads an 64-bit floating point type in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_f64(&mut self) -> io::Result<f64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read 64-bit floating point type from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
  /// ]);
  ///
  /// assert_eq!(f64::MIN, reader.read_f64().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadF64MutSelf> readF64();

  /// Reads an 64-bit floating point type in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_f64_le(&mut self) -> io::Result<f64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read 64-bit floating point type from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff
  /// ]);
  ///
  /// assert_eq!(f64::MIN, reader.read_f64_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadF64LeMutSelf> readF64Le();

  /// Reads an signed 128-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i128(&mut self) -> io::Result<i128>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 128-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0x80, 0, 0, 0, 0, 0, 0, 0,
  ///     0, 0, 0, 0, 0, 0, 0, 0
  /// ]);
  ///
  /// assert_eq!(i128::MIN, reader.read_i128().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI128MutSelf> readI128();

  /// Reads an signed 128-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i128_le(&mut self) -> io::Result<i128>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 128-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0x80, 0, 0, 0, 0, 0, 0, 0,
  ///     0, 0, 0, 0, 0, 0, 0, 0
  /// ]);
  ///
  /// assert_eq!(128, reader.read_i128_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI128LeMutSelf> readI128Le();

  /// Reads a signed 16-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i16(&mut self) -> io::Result<i16>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 16 bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x00, 0xc1, 0xff, 0x7c]);
  ///
  /// assert_eq!(193, reader.read_i16().await?);
  /// assert_eq!(-132, reader.read_i16().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI16MutSelf> readI16();

  /// Reads a signed 16-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i16_le(&mut self) -> io::Result<i16>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 16 bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x00, 0xc1, 0xff, 0x7c]);
  ///
  /// assert_eq!(-16128, reader.read_i16_le().await?);
  /// assert_eq!(31999, reader.read_i16_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI16LeMutSelf> readI16Le();

  /// Reads a signed 32-bit integer in big-endian order from the
  /// underlying reader.
  ///
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i32(&mut self) -> io::Result<i32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 32-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7a, 0x33]);
  ///
  /// assert_eq!(-34253, reader.read_i32().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI32MutSelf> readI32();

  /// Reads a signed 32-bit integer in little-endian order from the
  /// underlying reader.
  ///
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i32_le(&mut self) -> io::Result<i32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 32-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7a, 0x33]);
  ///
  /// assert_eq!(863698943, reader.read_i32_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI32LeMutSelf> readI32Le();

  /// Reads an signed 64-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i64(&mut self) -> io::Result<i64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 64-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0]);
  ///
  /// assert_eq!(i64::MIN, reader.read_i64().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI64MutSelf> readI64();

  /// Reads an signed 64-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i64_le(&mut self) -> io::Result<i64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read signed 64-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0]);
  ///
  /// assert_eq!(128, reader.read_i64_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI64LeMutSelf> readI64Le();

  /// Reads a signed 8 bit integer from the underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_i8(&mut self) -> io::Result<i8>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If this method is used as an event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no data were read.
  ///
  /// # Examples
  ///
  /// Read unsigned 8 bit integers from an `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x02, 0xfb]);
  ///
  /// assert_eq!(2, reader.read_i8().await?);
  /// assert_eq!(-5, reader.read_i8().await?);
  ///
  /// Ok(())
  /// # }
  /// ```
  Future<ReadI8MutSelf> readI8();

  /// Reads an unsigned 128-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u128(&mut self) -> io::Result<u128>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 128-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///         0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83
  /// ]);
  ///
  /// assert_eq!(16947640962301618749969007319746179, reader.read_u128().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU128MutSelf> readU128();

  /// Reads an unsigned 128-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u128_le(&mut self) -> io::Result<u128>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 128-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83
  /// ]);
  ///
  /// assert_eq!(174826588484952389081207917399662330624, reader.read_u128_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU128LeMutSelf> readU128Le();

  /// Reads an unsigned 16-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u16(&mut self) -> io::Result<u16>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 16 bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![2, 5, 3, 0]);
  ///
  /// assert_eq!(517, reader.read_u16().await?);
  /// assert_eq!(768, reader.read_u16().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU16MutSelf> readU16();

  /// Reads an unsigned 16-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u16_le(&mut self) -> io::Result<u16>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 16 bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![2, 5, 3, 0]);
  ///
  /// assert_eq!(1282, reader.read_u16_le().await?);
  /// assert_eq!(3, reader.read_u16_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU16LeMutSelf> readU16Le();

  /// Reads an unsigned 32-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u32(&mut self) -> io::Result<u32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 32-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x00, 0x00, 0x01, 0x0b]);
  ///
  /// assert_eq!(267, reader.read_u32().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU32MutSelf> readU32();

  /// Reads an unsigned 32-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u32_le(&mut self) -> io::Result<u32>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 32-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![0x00, 0x00, 0x01, 0x0b]);
  ///
  /// assert_eq!(184614912, reader.read_u32_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU32LeMutSelf> readU32Le();

  /// Reads an unsigned 64-bit integer in big-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u64(&mut self) -> io::Result<u64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 64-bit big-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83
  /// ]);
  ///
  /// assert_eq!(918733457491587, reader.read_u64().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU64MutSelf> readU64();

  /// Reads an unsigned 64-bit integer in little-endian order from the
  /// underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u64_le(&mut self) -> io::Result<u64>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is not cancellation safe. If the method is used as the
  /// event in a [`tokio::select!`](crate::select) statement and some
  /// other branch completes first, then some data may be lost.
  ///
  /// # Examples
  ///
  /// Read unsigned 64-bit little-endian integers from a `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83
  /// ]);
  ///
  /// assert_eq!(9477368352180732672, reader.read_u64_le().await?);
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU64LeMutSelf> readU64Le();

  /// Reads an unsigned 8 bit integer from the underlying reader.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn read_u8(&mut self) -> io::Result<u8>;
  /// ```
  ///
  /// It is recommended to use a buffered reader to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncReadExt::read_exact`].
  ///
  /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If this method is used as an event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no data were read.
  ///
  /// # Examples
  ///
  /// Read unsigned 8 bit integers from an `AsyncRead`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncReadExt};
  ///
  /// use std::io::Cursor;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut reader = Cursor::new(vec![2, 5]);
  ///
  /// assert_eq!(2, reader.read_u8().await?);
  /// assert_eq!(5, reader.read_u8().await?);
  ///
  /// Ok(())
  /// # }
  /// ```
  Future<ReadU8MutSelf> readU8();

  /// Creates an adaptor which reads at most `limit` bytes from it.
  ///
  /// This function returns a new instance of `AsyncRead` which will read
  /// at most `limit` bytes, after which it will always return EOF
  /// (`Ok(0)`). Any read errors will not count towards the number of
  /// bytes read and future calls to [`read()`] may succeed.
  ///
  /// [`read()`]: fn@crate::io::AsyncReadExt::read
  ///
  /// [read]: AsyncReadExt::read
  ///
  /// # Examples
  ///
  /// [`File`][crate::fs::File]s implement `Read`:
  ///
  /// ```no_run
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::io::{self, AsyncReadExt};
  /// use tokio::fs::File;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let f = File::open("foo.txt").await?;
  ///     let mut buffer = [0; 5];
  ///
  ///     // read at most five bytes
  ///     let mut handle = f.take(5);
  ///
  ///     handle.read(&mut buffer).await?;
  ///     Ok(())
  /// }
  /// # }
  /// ```
  Future<TakeSelf> take({required BigInt limit});
}

abstract class AsyncSeekExt {
  /// Creates a future which will rewind to the beginning of the stream.
  ///
  /// This is convenience method, equivalent to `self.seek(SeekFrom::Start(0))`.
  Future<SeekSelf> rewind();

  /// Creates a future which will seek an IO object, and then yield the
  /// new position in the object and the object itself.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn seek(&mut self, pos: SeekFrom) -> io::Result<u64>;
  /// ```
  ///
  /// In the case of an error the buffer and the object will be discarded, with
  /// the error yielded.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::fs::File;
  /// use tokio::io::{AsyncSeekExt, AsyncReadExt};
  ///
  /// use std::io::SeekFrom;
  ///
  /// # async fn dox() -> std::io::Result<()> {
  /// let mut file = File::open("foo.txt").await?;
  /// file.seek(SeekFrom::Start(6)).await?;
  ///
  /// let mut contents = vec![0u8; 10];
  /// file.read_exact(&mut contents).await?;
  /// # Ok(())
  /// # }
  /// # }
  /// ```
  Future<SeekSelf> seek({required SeekFrom pos});

  /// Creates a future which will return the current seek position from the
  /// start of the stream.
  ///
  /// This is equivalent to `self.seek(SeekFrom::Current(0))`.
  Future<SeekSelf> streamPosition();
}

abstract class AsyncWriteExt {
  /// Flushes this output stream, ensuring that all intermediately buffered
  /// contents reach their destination.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn flush(&mut self) -> io::Result<()>;
  /// ```
  ///
  /// # Errors
  ///
  /// It is considered an error if not all bytes could be written due to
  /// I/O errors or EOF being reached.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe.
  ///
  /// If `flush` is used as the event in a [`tokio::select!`](crate::select)
  /// statement and some other branch completes first, then the data in the
  /// buffered data in this `AsyncWrite` may have been partially flushed.
  /// However, it is guaranteed that the buffer is advanced by the amount of
  /// bytes that have been partially flushed.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::io::{self, BufWriter, AsyncWriteExt};
  /// use tokio::fs::File;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let f = File::create("foo.txt").await?;
  ///     let mut buffer = BufWriter::new(f);
  ///
  ///     buffer.write_all(b"some bytes").await?;
  ///     buffer.flush().await?;
  ///     Ok(())
  /// }
  /// # }
  /// ```
  Future<FlushSelf> flush();

  /// Shuts down the output stream, ensuring that the value can be dropped
  /// cleanly.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn shutdown(&mut self) -> io::Result<()>;
  /// ```
  ///
  /// Similar to [`flush`], all intermediately buffered is written to the
  /// underlying stream. Once the operation completes, the caller should
  /// no longer attempt to write to the stream. For example, the
  /// `TcpStream` implementation will issue a `shutdown(Write)` sys call.
  ///
  /// [`flush`]: fn@crate::io::AsyncWriteExt::flush
  ///
  /// # Examples
  ///
  /// ```no_run
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use tokio::io::{self, BufWriter, AsyncWriteExt};
  /// use tokio::fs::File;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let f = File::create("foo.txt").await?;
  ///     let mut buffer = BufWriter::new(f);
  ///
  ///     buffer.write_all(b"some bytes").await?;
  ///     buffer.shutdown().await?;
  ///     Ok(())
  /// }
  /// # }
  /// ```
  Future<ShutdownSelf> shutdown();

  /// Writes an 32-bit floating point type in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_f32(&mut self, n: f32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write 32-bit floating point type to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_f32(f32::MIN).await?;
  ///
  /// assert_eq!(writer, vec![0xff, 0x7f, 0xff, 0xff]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteF32MutSelf> writeF32({required double n});

  /// Writes an 32-bit floating point type in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_f32_le(&mut self, n: f32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write 32-bit floating point type to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_f32_le(f32::MIN).await?;
  ///
  /// assert_eq!(writer, vec![0xff, 0xff, 0x7f, 0xff]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteF32LeMutSelf> writeF32Le({required double n});

  /// Writes an 64-bit floating point type in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_f64(&mut self, n: f64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write 64-bit floating point type to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_f64(f64::MIN).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteF64MutSelf> writeF64({required double n});

  /// Writes an 64-bit floating point type in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_f64_le(&mut self, n: f64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write 64-bit floating point type to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_f64_le(f64::MIN).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteF64LeMutSelf> writeF64Le({required double n});

  /// Writes an signed 128-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i128(&mut self, n: i128) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 128-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i128(i128::MIN).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0x80, 0, 0, 0, 0, 0, 0, 0,
  ///     0, 0, 0, 0, 0, 0, 0, 0
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI128MutSelf> writeI128({required BigInt n});

  /// Writes an signed 128-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i128_le(&mut self, n: i128) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 128-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i128_le(i128::MIN).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0, 0, 0, 0, 0, 0, 0,
  ///     0, 0, 0, 0, 0, 0, 0, 0, 0x80
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI128LeMutSelf> writeI128Le({required BigInt n});

  /// Writes a signed 16-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i16(&mut self, n: i16) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 16-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i16(193).await?;
  /// writer.write_i16(-132).await?;
  ///
  /// assert_eq!(writer, b"\x00\xc1\xff\x7c");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI16MutSelf> writeI16({required int n});

  /// Writes a signed 16-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i16_le(&mut self, n: i16) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 16-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i16_le(193).await?;
  /// writer.write_i16_le(-132).await?;
  ///
  /// assert_eq!(writer, b"\xc1\x00\x7c\xff");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI16LeMutSelf> writeI16Le({required int n});

  /// Writes a signed 32-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i32(&mut self, n: i32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 32-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i32(267).await?;
  /// writer.write_i32(1205419366).await?;
  ///
  /// assert_eq!(writer, b"\x00\x00\x01\x0b\x47\xd9\x3d\x66");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI32MutSelf> writeI32({required int n});

  /// Writes a signed 32-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i32_le(&mut self, n: i32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 32-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i32_le(267).await?;
  /// writer.write_i32_le(1205419366).await?;
  ///
  /// assert_eq!(writer, b"\x0b\x01\x00\x00\x66\x3d\xd9\x47");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI32LeMutSelf> writeI32Le({required int n});

  /// Writes an signed 64-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i64(&mut self, n: i64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 64-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i64(i64::MIN).await?;
  /// writer.write_i64(i64::MAX).await?;
  ///
  /// assert_eq!(writer, b"\x80\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xff\xff\xff\xff\xff\xff");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI64MutSelf> writeI64({required PlatformInt64 n});

  /// Writes an signed 64-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i64_le(&mut self, n: i64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 64-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i64_le(i64::MIN).await?;
  /// writer.write_i64_le(i64::MAX).await?;
  ///
  /// assert_eq!(writer, b"\x00\x00\x00\x00\x00\x00\x00\x80\xff\xff\xff\xff\xff\xff\xff\x7f");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI64LeMutSelf> writeI64Le({required PlatformInt64 n});

  /// Writes a signed 8-bit integer to the underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_i8(&mut self, n: i8) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write signed 8 bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_i8(-2).await?;
  /// writer.write_i8(126).await?;
  ///
  /// assert_eq!(writer, b"\xFE\x7E");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteI8MutSelf> writeI8({required int n});

  /// Writes an unsigned 128-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u128(&mut self, n: u128) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 128-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u128(16947640962301618749969007319746179).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,
  ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU128MutSelf> writeU128({required BigInt n});

  /// Writes an unsigned 128-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u128_le(&mut self, n: u128) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 128-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u128_le(16947640962301618749969007319746179).await?;
  ///
  /// assert_eq!(writer, vec![
  ///     0x83, 0x86, 0x60, 0x4d, 0x95, 0x43, 0x03, 0x00,
  ///     0x83, 0x86, 0x60, 0x4d, 0x95, 0x43, 0x03, 0x00,
  /// ]);
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU128LeMutSelf> writeU128Le({required BigInt n});

  /// Writes an unsigned 16-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u16(&mut self, n: u16) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 16-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u16(517).await?;
  /// writer.write_u16(768).await?;
  ///
  /// assert_eq!(writer, b"\x02\x05\x03\x00");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU16MutSelf> writeU16({required int n});

  /// Writes an unsigned 16-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u16_le(&mut self, n: u16) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 16-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u16_le(517).await?;
  /// writer.write_u16_le(768).await?;
  ///
  /// assert_eq!(writer, b"\x05\x02\x00\x03");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU16LeMutSelf> writeU16Le({required int n});

  /// Writes an unsigned 32-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u32(&mut self, n: u32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 32-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u32(267).await?;
  /// writer.write_u32(1205419366).await?;
  ///
  /// assert_eq!(writer, b"\x00\x00\x01\x0b\x47\xd9\x3d\x66");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU32MutSelf> writeU32({required int n});

  /// Writes an unsigned 32-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u32_le(&mut self, n: u32) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 32-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u32_le(267).await?;
  /// writer.write_u32_le(1205419366).await?;
  ///
  /// assert_eq!(writer, b"\x0b\x01\x00\x00\x66\x3d\xd9\x47");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU32LeMutSelf> writeU32Le({required int n});

  /// Writes an unsigned 64-bit integer in big-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u64(&mut self, n: u64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 64-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u64(918733457491587).await?;
  /// writer.write_u64(143).await?;
  ///
  /// assert_eq!(writer, b"\x00\x03\x43\x95\x4d\x60\x86\x83\x00\x00\x00\x00\x00\x00\x00\x8f");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU64MutSelf> writeU64({required BigInt n});

  /// Writes an unsigned 64-bit integer in little-endian order to the
  /// underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u64_le(&mut self, n: u64) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 64-bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u64_le(918733457491587).await?;
  /// writer.write_u64_le(143).await?;
  ///
  /// assert_eq!(writer, b"\x83\x86\x60\x4d\x95\x43\x03\x00\x8f\x00\x00\x00\x00\x00\x00\x00");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU64LeMutSelf> writeU64Le({required BigInt n});

  /// Writes an unsigned 8-bit integer to the underlying writer.
  ///
  /// Equivalent to:
  ///
  /// ```ignore
  /// async fn write_u8(&mut self, n: u8) -> io::Result<()>;
  /// ```
  ///
  /// It is recommended to use a buffered writer to avoid excessive
  /// syscalls.
  ///
  /// # Errors
  ///
  /// This method returns the same errors as [`AsyncWriteExt::write_all`].
  ///
  /// [`AsyncWriteExt::write_all`]: AsyncWriteExt::write_all
  ///
  /// # Examples
  ///
  /// Write unsigned 8 bit integers to a `AsyncWrite`:
  ///
  /// ```rust
  /// use tokio::io::{self, AsyncWriteExt};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() -> io::Result<()> {
  /// let mut writer = Vec::new();
  ///
  /// writer.write_u8(2).await?;
  /// writer.write_u8(5).await?;
  ///
  /// assert_eq!(writer, b"\x02\x05");
  /// Ok(())
  /// # }
  /// ```
  Future<WriteU8MutSelf> writeU8({required int n});
}
