// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../io.dart';
import '../net.dart';
import '../signal/unix.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'tcp/split_owned.dart';
import 'unix.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OwnedReadHalf>>
abstract class OwnedReadHalf implements RustOpaqueInterface {
  /// Returns the local address that this stream is bound to.
  Future<SocketAddr> localAddr();

  /// Receives data on the socket from the remote address to which it is
  /// connected, without removing that data from the queue. On success,
  /// returns the number of bytes peeked.
  ///
  /// See the [`TcpStream::peek`] level documentation for more details.
  ///
  /// [`TcpStream::peek`]: TcpStream::peek
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use tokio::io::AsyncReadExt;
  /// use std::error::Error;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///     let (mut read_half, _) = stream.into_split();
  ///
  ///     let mut b1 = [0; 10];
  ///     let mut b2 = [0; 10];
  ///
  ///     // Peek at the data
  ///     let n = read_half.peek(&mut b1).await?;
  ///
  ///     // Read the data
  ///     assert_eq!(n, read_half.read(&mut b2[..n]).await?);
  ///     assert_eq!(&b1[..n], &b2[..n]);
  ///
  ///     Ok(())
  /// }
  /// ```
  ///
  /// The [`read`] method is defined on the [`AsyncReadExt`] trait.
  ///
  /// [`read`]: fn@crate::io::AsyncReadExt::read
  /// [`AsyncReadExt`]: trait@crate::io::AsyncReadExt
  Future<BigInt> peek({required U8 buf});

  /// Returns the remote address that this stream is connected to.
  Future<SocketAddr> peerAddr();

  /// Attempt to receive data on the socket, without removing that data from
  /// the queue, registering the current task for wakeup if data is not yet
  /// available.
  ///
  /// Note that on multiple calls to `poll_peek` or `poll_read`, only the
  /// `Waker` from the `Context` passed to the most recent call is scheduled
  /// to receive a wakeup.
  ///
  /// See the [`TcpStream::poll_peek`] level documentation for more details.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::io::{self, ReadBuf};
  /// use tokio::net::TcpStream;
  ///
  /// use std::future::poll_fn;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let stream = TcpStream::connect("127.0.0.1:8000").await?;
  ///     let (mut read_half, _) = stream.into_split();
  ///     let mut buf = [0; 10];
  ///     let mut buf = ReadBuf::new(&mut buf);
  ///
  ///     poll_fn(|cx| {
  ///         read_half.poll_peek(cx, &mut buf)
  ///     }).await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  ///
  /// [`TcpStream::poll_peek`]: TcpStream::poll_peek
  Future<PollResultUsize> pollPeek({required Context cx, required ReadBuf buf});

  /// Waits for the socket to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with `try_read()`.
  ///
  /// This function is also equivalent to [`TcpStream::ready`].
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with [`try_read()`]. It can be used instead
  /// of [`readable()`] to check the returned ready set for [`Ready::READABLE`]
  /// and [`Ready::READ_CLOSED`] events.
  ///
  /// The function may complete without the socket being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// This function is equivalent to [`TcpStream::ready`].
  ///
  /// [`try_read()`]: Self::try_read
  /// [`readable()`]: Self::readable
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read or write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<Ready> ready({required Interest interest});

  /// Attempts to put the two halves of a `TcpStream` back together and
  /// recover the original socket. Succeeds only if the two halves
  /// originated from the same call to [`into_split`].
  ///
  /// [`into_split`]: TcpStream::into_split()
  Future<TcpStream> reunite({required OwnedWriteHalf other});

  /// Tries to read data from the stream into the provided buffer, returning how
  /// many bytes were read.
  ///
  /// Receives any pending data from the socket but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read()` is non-blocking, the buffer does not have to be stored by
  /// the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`readable()`]: Self::readable()
  /// [`ready()`]: Self::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
  ///
  /// 1. The stream's read half is closed and will no longer yield data.
  /// 2. The specified buffer was 0 bytes in length.
  ///
  /// If the stream is not ready to read data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  Future<BigInt> tryRead({required U8 buf});

  /// Tries to read data from the stream into the provided buffers, returning
  /// how many bytes were read.
  ///
  /// Data is copied to fill each buffer in order, with the final buffer
  /// written to possibly being only partially filled. This method behaves
  /// equivalently to a single call to [`try_read()`] with concatenated
  /// buffers.
  ///
  /// Receives any pending data from the socket but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read_vectored()` is non-blocking, the buffer does not have to be
  /// stored by the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`try_read()`]: Self::try_read()
  /// [`readable()`]: Self::readable()
  /// [`ready()`]: Self::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. `Ok(0)` indicates the stream's read half is closed
  /// and will no longer yield data. If the stream is not ready to read data
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  Future<BigInt> tryReadVectored({required IoSliceMut bufs});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OwnedWriteHalf>>
abstract class OwnedWriteHalf implements RustOpaqueInterface {
  /// Returns the local address that this stream is bound to.
  Future<SocketAddr> localAddr();

  /// Returns the remote address that this stream is connected to.
  Future<SocketAddr> peerAddr();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with [`try_write()`]. It can be used instead
  /// of [`writable()`] to check the returned ready set for [`Ready::WRITABLE`]
  /// and [`Ready::WRITE_CLOSED`] events.
  ///
  /// The function may complete without the socket being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// This function is equivalent to [`TcpStream::ready`].
  ///
  /// [`try_write()`]: Self::try_write
  /// [`writable()`]: Self::writable
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read or write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<Ready> ready({required Interest interest});

  /// Attempts to put the two halves of a `TcpStream` back together and
  /// recover the original socket. Succeeds only if the two halves
  /// originated from the same call to [`into_split`].
  ///
  /// [`into_split`]: TcpStream::into_split()
  Future<TcpStream> reunite({required OwnedReadHalf other});

  /// Tries to write a buffer to the stream, returning how many bytes were
  /// written.
  ///
  /// The function will attempt to write the entire contents of `buf`, but
  /// only part of the buffer may be written.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the stream is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  Future<BigInt> tryWrite({required List<int> buf});

  /// Tries to write several buffers to the stream, returning how many bytes
  /// were written.
  ///
  /// Data is written from each buffer in order, with the final buffer read
  /// from possible being only partially consumed. This method behaves
  /// equivalently to a single call to [`try_write()`] with concatenated
  /// buffers.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// [`try_write()`]: Self::try_write()
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the stream is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  Future<BigInt> tryWriteVectored({required List<IoSlice> bufs});

  /// Waits for the socket to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
  /// paired with `try_write()`.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<void> writable();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReuniteError>>
abstract class ReuniteError implements RustOpaqueInterface {
  OwnedReadHalf get field0;

  OwnedWriteHalf get field1;

  set field0(OwnedReadHalf field0);

  set field1(OwnedWriteHalf field1);
}
