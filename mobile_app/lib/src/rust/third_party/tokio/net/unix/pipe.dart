// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../frb_generated.dart';
import '../../../../lib.dart';
import '../../io.dart';
import '../../process/sys.dart';
import '../../signal/unix.dart';
import '../../sync/broadcast.dart';
import '../../sync/broadcast/error.dart';
import '../../sync/mpsc/bounded.dart';
import '../../sync/mpsc/error.dart';
import '../../sync/oneshot.dart';
import '../../sync/watch.dart';
import '../tcp/split_owned.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `open_receiver`, `open_sender`, `try_read_buf`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `PipeEnd`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `as_fd`, `as_fd`, `as_raw_fd`, `as_raw_fd`, `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `is_write_vectored`, `poll_flush`, `poll_read`, `poll_shutdown`, `poll_write_vectored`, `poll_write`

/// Creates a new anonymous Unix pipe.
///
/// This function will open a new pipe and associate both pipe ends with the default
/// event loop.
///
/// If you need to create a pipe for communication with a spawned process, you can
/// use [`Stdio::piped()`] instead.
///
/// [`Stdio::piped()`]: std::process::Stdio::piped
///
/// # Errors
///
/// If creating a pipe fails, this function will return with the related OS error.
///
/// # Examples
///
/// Create a pipe and pass the writing end to a spawned process.
///
/// ```no_run
/// use tokio::net::unix::pipe;
/// use tokio::process::Command;
/// # use tokio::io::AsyncReadExt;
/// # use std::error::Error;
///
/// # async fn dox() -> Result<(), Box<dyn Error>> {
/// let (tx, mut rx) = pipe::pipe()?;
/// let mut buffer = String::new();
///
/// let status = Command::new("echo")
///     .arg("Hello, world!")
///     .stdout(tx.into_blocking_fd()?)
///     .status();
/// rx.read_to_string(&mut buffer).await?;
///
/// assert!(status.await?.success());
/// assert_eq!(buffer, "Hello, world!\n");
/// # Ok(())
/// # }
/// ```
///
/// # Panics
///
/// This function panics if it is not called from within a runtime with
/// IO enabled.
///
/// The runtime is usually set implicitly when this function is called
/// from a future driven by a tokio runtime, otherwise runtime can be set
/// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
Future<(Sender, Receiver)> pipe() =>
    RustLib.instance.api.tokioNetUnixPipePipe();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OpenOptions>>
abstract class OpenOptions implements RustOpaqueInterface {
  /// Sets the option for the append mode.
  ///
  /// This option, when true, means that writes will append to a file instead
  /// of overwriting previous contents.  Note that setting
  /// `.write(true).append(true)` has the same effect as setting only
  /// `.append(true)`.
  ///
  /// For most filesystems, the operating system guarantees that all writes are
  /// atomic: no writes get mangled because another process writes at the same
  /// time.
  ///
  /// One maybe obvious note when using append-mode: make sure that all data
  /// that belongs together is written to the file in one operation. This
  /// can be done by concatenating strings before passing them to [`write()`],
  /// or using a buffered writer (with a buffer of adequate size),
  /// and calling [`flush()`] when the message is complete.
  ///
  /// If a file is opened with both read and append access, beware that after
  /// opening, and after every write, the position for reading may be set at the
  /// end of the file. So, before writing, save the current position (using
  /// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.
  ///
  /// This is an async version of [`std::fs::OpenOptions::append`][std]
  ///
  /// [std]: std::fs::OpenOptions::append
  ///
  /// ## Note
  ///
  /// This function doesn't create the file if it doesn't exist. Use the [`create`]
  /// method to do so.
  ///
  /// [`write()`]: crate::io::AsyncWriteExt::write
  /// [`flush()`]: crate::io::AsyncWriteExt::flush
  /// [`seek`]: crate::io::AsyncSeekExt::seek
  /// [`SeekFrom`]: std::io::SeekFrom
  /// [`Current`]: std::io::SeekFrom::Current
  /// [`create`]: OpenOptions::create
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .append(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> append({required bool append});

  /// Sets the option for creating a new file.
  ///
  /// This option indicates whether a new file will be created if the file
  /// does not yet already exist.
  ///
  /// In order for the file to be created, [`write`] or [`append`] access must
  /// be used.
  ///
  /// This is an async version of [`std::fs::OpenOptions::create`][std]
  ///
  /// [std]: std::fs::OpenOptions::create
  /// [`write`]: OpenOptions::write
  /// [`append`]: OpenOptions::append
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .write(true)
  ///         .create(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> create({required bool create});

  /// Sets the option to always create a new file.
  ///
  /// This option indicates whether a new file will be created.  No file is
  /// allowed to exist at the target location, also no (dangling) symlink.
  ///
  /// This option is useful because it is atomic. Otherwise between checking
  /// whether a file exists and creating a new one, the file may have been
  /// created by another process (a TOCTOU race condition / attack).
  ///
  /// If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are
  /// ignored.
  ///
  /// The file must be opened with write or append access in order to create a
  /// new file.
  ///
  /// This is an async version of [`std::fs::OpenOptions::create_new`][std]
  ///
  /// [std]: std::fs::OpenOptions::create_new
  /// [`.create()`]: OpenOptions::create
  /// [`.truncate()`]: OpenOptions::truncate
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .write(true)
  ///         .create_new(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> createNew({required bool createNew});

  /// Passes custom flags to the `flags` argument of `open`.
  ///
  /// The bits that define the access mode are masked out with `O_ACCMODE`, to
  /// ensure they do not interfere with the access mode set by Rusts options.
  ///
  /// Custom flags can only set flags, not remove flags set by Rusts options.
  /// This options overwrites any previously set custom flags.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let mut options = OpenOptions::new();
  ///     options.write(true);
  ///     if cfg!(unix) {
  ///         options.custom_flags(libc::O_NOFOLLOW);
  ///     }
  ///     let file = options.open("foo.txt").await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> customFlags({required int flags});

  static Future<OpenOptions> default_() =>
      RustLib.instance.api.tokioNetUnixPipeOpenOptionsDefault();

  /// Sets the mode bits that a new file will be created with.
  ///
  /// If a new file is created as part of an `OpenOptions::open` call then this
  /// specified `mode` will be used as the permission bits for the new file.
  /// If no `mode` is set, the default of `0o666` will be used.
  /// The operating system masks out bits with the system's `umask`, to produce
  /// the final permissions.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let mut options = OpenOptions::new();
  ///     options.mode(0o644); // Give read/write for owner and read for others.
  ///     let file = options.open("foo.txt").await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> mode({required int mode});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a blank new set of options ready for configuration.
  ///
  /// All options are initially set to `false`.
  ///
  /// This is an async version of [`std::fs::OpenOptions::new`][std]
  ///
  /// [std]: std::fs::OpenOptions::new
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  ///
  /// let mut options = OpenOptions::new();
  /// let future = options.read(true).open("foo.txt");
  /// ```
  static Future<OpenOptions> newInstance() =>
      RustLib.instance.api.tokioNetUnixPipeOpenOptionsNew();

  /// Sets the option for read access.
  ///
  /// This option, when true, will indicate that the file should be
  /// `read`-able if opened.
  ///
  /// This is an async version of [`std::fs::OpenOptions::read`][std]
  ///
  /// [std]: std::fs::OpenOptions::read
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .read(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> read({required bool read});

  /// Sets the option for truncating a previous file.
  ///
  /// If a file is successfully opened with this option set it will truncate
  /// the file to 0 length if it already exists.
  ///
  /// The file must be opened with write access for truncate to work.
  ///
  /// This is an async version of [`std::fs::OpenOptions::truncate`][std]
  ///
  /// [std]: std::fs::OpenOptions::truncate
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .write(true)
  ///         .truncate(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> truncate({required bool truncate});

  /// Sets the option to skip the check for FIFO file type.
  ///
  /// By default, [`open_receiver`] and [`open_sender`] functions will check
  /// if the opened file is a FIFO file. Set this option to `true` if you are
  /// sure the file is a FIFO file.
  ///
  /// [`open_receiver`]: OpenOptions::open_receiver
  /// [`open_sender`]: OpenOptions::open_sender
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use nix::{unistd::mkfifo, sys::stat::Mode};
  /// # use std::error::Error;
  ///
  /// // Our program has exclusive access to this path.
  /// const FIFO_NAME: &str = "path/to/a/new/fifo";
  ///
  /// # async fn dox() -> Result<(), Box<dyn Error>> {
  /// mkfifo(FIFO_NAME, Mode::S_IRWXU)?;
  /// let rx = pipe::OpenOptions::new()
  ///     .unchecked(true)
  ///     .open_receiver(FIFO_NAME)?;
  /// # Ok(())
  /// # }
  /// ```
  Future<void> unchecked({required bool value});

  /// Sets the option for write access.
  ///
  /// This option, when true, will indicate that the file should be
  /// `write`-able if opened.
  ///
  /// This is an async version of [`std::fs::OpenOptions::write`][std]
  ///
  /// [std]: std::fs::OpenOptions::write
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::fs::OpenOptions;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let file = OpenOptions::new()
  ///         .write(true)
  ///         .open("foo.txt")
  ///         .await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> write({required bool write});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Poll < Result < () > >>>
abstract class PollResult implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver>>
abstract class Receiver implements RustOpaqueInterface {
  /// Creates a new `Receiver` from a [`File`].
  ///
  /// This function is intended to construct a pipe from a [`File`] representing
  /// a special FIFO file. It will check if the file is a pipe and has read access,
  /// set it in non-blocking mode and perform the conversion.
  ///
  /// # Errors
  ///
  /// Fails with `io::ErrorKind::InvalidInput` if the file is not a pipe or it
  /// does not have read access. Also fails with any standard OS error if it occurs.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Receiver> fromFile({required File file}) =>
      RustLib.instance.api.tokioNetUnixPipeReceiverFromFile(file: file);

  /// Creates a new `Receiver` from a [`File`] without checking pipe properties.
  ///
  /// This function is intended to construct a pipe from a File representing
  /// a special FIFO file. The conversion assumes nothing about the underlying
  /// file; it is left up to the user to make sure it is opened with read access,
  /// represents a pipe and is set in non-blocking mode.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::fs::OpenOptions;
  /// use std::os::unix::fs::{FileTypeExt, OpenOptionsExt};
  /// # use std::error::Error;
  ///
  /// const FIFO_NAME: &str = "path/to/a/fifo";
  ///
  /// # async fn dox() -> Result<(), Box<dyn Error>> {
  /// let file = OpenOptions::new()
  ///     .read(true)
  ///     .custom_flags(libc::O_NONBLOCK)
  ///     .open(FIFO_NAME)?;
  /// if file.metadata()?.file_type().is_fifo() {
  ///     let rx = pipe::Receiver::from_file_unchecked(file)?;
  ///     /* use the Receiver */
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Receiver> fromFileUnchecked({required File file}) =>
      RustLib.instance.api
          .tokioNetUnixPipeReceiverFromFileUnchecked(file: file);

  /// Creates a new `Receiver` from an [`OwnedFd`].
  ///
  /// This function is intended to construct a pipe from an [`OwnedFd`] representing
  /// an anonymous pipe or a special FIFO file. It will check if the file descriptor
  /// is a pipe and has read access, set it in non-blocking mode and perform the
  /// conversion.
  ///
  /// # Errors
  ///
  /// Fails with `io::ErrorKind::InvalidInput` if the file descriptor is not a pipe
  /// or it does not have read access. Also fails with any standard OS error if it
  /// occurs.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Receiver> fromOwnedFd({required OwnedFd ownedFd}) =>
      RustLib.instance.api
          .tokioNetUnixPipeReceiverFromOwnedFd(ownedFd: ownedFd);

  /// Creates a new `Receiver` from an [`OwnedFd`] without checking pipe properties.
  ///
  /// This function is intended to construct a pipe from an [`OwnedFd`] representing
  /// an anonymous pipe or a special FIFO file. The conversion assumes nothing about
  /// the underlying pipe; it is left up to the user to make sure that the file
  /// descriptor represents the reading end of a pipe and the pipe is set in
  /// non-blocking mode.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Receiver> fromOwnedFdUnchecked({required OwnedFd ownedFd}) =>
      RustLib.instance.api
          .tokioNetUnixPipeReceiverFromOwnedFdUnchecked(ownedFd: ownedFd);

  /// Converts the pipe into an [`OwnedFd`] in blocking mode.
  ///
  /// This function will deregister this pipe end from the event loop, set
  /// it in blocking mode and perform the conversion.
  Future<OwnedFd> intoBlockingFd();

  /// Converts the pipe into an [`OwnedFd`] in nonblocking mode.
  ///
  /// This function will deregister this pipe end from the event loop and
  /// perform the conversion. Returned file descriptor will be in nonblocking
  /// mode.
  Future<OwnedFd> intoNonblockingFd();

  /// Polls for read readiness.
  ///
  /// If the pipe is not currently ready for reading, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for reading, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_read_ready` or `poll_read`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup.
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`readable`] is not feasible. Where possible, using [`readable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// [`readable`]: Self::readable
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for reading.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for reading.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  Future<PollResult> pollReadReady({required Context cx});

  /// Waits for the pipe to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with [`try_read()`].
  ///
  /// [`try_read()`]: Self::try_read()
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a reading end of a fifo
  ///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
  ///
  ///     let mut msg = vec![0; 1024];
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         rx.readable().await?;
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match rx.try_read(&mut msg) {
  ///             Ok(n) => {
  ///                 msg.truncate(n);
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     println!("GOT = {:?}", msg);
  ///     Ok(())
  /// }
  /// ```
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function can be used instead of [`readable()`] to check the returned
  /// ready set for [`Ready::READABLE`] and [`Ready::READ_CLOSED`] events.
  ///
  /// The function may complete without the pipe being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// [`readable()`]: Self::readable
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<Ready> ready({required Interest interest});

  /// Tries to read data from the pipe into the provided buffer, returning how
  /// many bytes were read.
  ///
  /// Reads any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read()` is non-blocking, the buffer does not have to be stored by
  /// the async task and can exist entirely on the stack.
  ///
  /// Usually [`readable()`] is used with this function.
  ///
  /// [`readable()`]: Self::readable()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
  ///
  /// 1. The pipe's writing end is closed and will no longer write data.
  /// 2. The specified buffer was 0 bytes in length.
  ///
  /// If the pipe is not ready to read data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a reading end of a fifo
  ///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
  ///
  ///     let mut msg = vec![0; 1024];
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         rx.readable().await?;
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match rx.try_read(&mut msg) {
  ///             Ok(n) => {
  ///                 msg.truncate(n);
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     println!("GOT = {:?}", msg);
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryRead({required U8 buf});

  /// Tries to read data from the pipe into the provided buffers, returning
  /// how many bytes were read.
  ///
  /// Data is copied to fill each buffer in order, with the final buffer
  /// written to possibly being only partially filled. This method behaves
  /// equivalently to a single call to [`try_read()`] with concatenated
  /// buffers.
  ///
  /// Reads any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read_vectored()` is non-blocking, the buffer does not have to be
  /// stored by the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] is used with this function.
  ///
  /// [`try_read()`]: Self::try_read()
  /// [`readable()`]: Self::readable()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. `Ok(0)` indicates the pipe's writing end is
  /// closed and will no longer write data. If the pipe is not ready to read
  /// data `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a reading end of a fifo
  ///     let rx = pipe::OpenOptions::new().open_receiver("path/to/a/fifo")?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         rx.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf_a = [0; 512];
  ///         let mut buf_b = [0; 1024];
  ///         let mut bufs = [
  ///             io::IoSliceMut::new(&mut buf_a),
  ///             io::IoSliceMut::new(&mut buf_b),
  ///         ];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match rx.try_read_vectored(&mut bufs) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryReadVectored({required IoSliceMut bufs});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver < T >>>
abstract class ReceiverT implements RustOpaqueInterface {
  /// Blocking receive to call outside of asynchronous contexts.
  ///
  /// # Panics
  ///
  /// This function panics if called within an asynchronous execution
  /// context.
  ///
  /// # Examples
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use std::thread;
  /// use tokio::sync::broadcast;
  ///
  /// #[tokio::main]
  /// async fn main() {
  ///     let (tx, mut rx) = broadcast::channel(16);
  ///
  ///     let sync_code = thread::spawn(move || {
  ///         assert_eq!(rx.blocking_recv(), Ok(10));
  ///     });
  ///
  ///     let _ = tx.send(10);
  ///     sync_code.join().unwrap();
  /// }
  /// # }
  /// ```
  Future<T> blockingRecv();

  /// Variant of [`Self::recv_many`] for blocking contexts.
  ///
  /// The same conditions as in [`Self::blocking_recv`] apply.
  Future<BigInt> blockingRecvMany(
      {required VecT buffer, required BigInt limit});

  /// Returns a reference to the most recently sent value.
  ///
  /// This method does not mark the returned value as seen, so future calls to
  /// [`changed`] may return immediately even if you have already seen the
  /// value with a call to `borrow`.
  ///
  /// Outstanding borrows hold a read lock on the inner value. This means that
  /// long-lived borrows could cause the producer half to block. It is recommended
  /// to keep the borrow as short-lived as possible. Additionally, if you are
  /// running in an environment that allows `!Send` futures, you must ensure that
  /// the returned `Ref` type is never held alive across an `.await` point,
  /// otherwise, it can lead to a deadlock.
  ///
  /// The priority policy of the lock is dependent on the underlying lock
  /// implementation, and this type does not guarantee that any particular policy
  /// will be used. In particular, a producer which is waiting to acquire the lock
  /// in `send` might or might not block concurrent calls to `borrow`, e.g.:
  ///
  /// <details><summary>Potential deadlock example</summary>
  ///
  /// ```text
  /// // Task 1 (on thread A)    |  // Task 2 (on thread B)
  /// let _ref1 = rx.borrow();   |
  ///                            |  // will block
  ///                            |  let _ = tx.send(());
  /// // may deadlock            |
  /// let _ref2 = rx.borrow();   |
  /// ```
  /// </details>
  ///
  /// For more information on when to use this method versus
  /// [`borrow_and_update`], see [here](self#borrow_and_update-versus-borrow).
  ///
  /// [`changed`]: Receiver::changed
  /// [`borrow_and_update`]: Receiver::borrow_and_update
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// let (_, rx) = watch::channel("hello");
  /// assert_eq!(*rx.borrow(), "hello");
  /// ```
  Future<RefT> borrow();

  /// Returns a reference to the most recently sent value and marks that value
  /// as seen.
  ///
  /// This method marks the current value as seen. Subsequent calls to [`changed`]
  /// will not return immediately until the [`Sender`] has modified the shared
  /// value again.
  ///
  /// Outstanding borrows hold a read lock on the inner value. This means that
  /// long-lived borrows could cause the producer half to block. It is recommended
  /// to keep the borrow as short-lived as possible. Additionally, if you are
  /// running in an environment that allows `!Send` futures, you must ensure that
  /// the returned `Ref` type is never held alive across an `.await` point,
  /// otherwise, it can lead to a deadlock.
  ///
  /// The priority policy of the lock is dependent on the underlying lock
  /// implementation, and this type does not guarantee that any particular policy
  /// will be used. In particular, a producer which is waiting to acquire the lock
  /// in `send` might or might not block concurrent calls to `borrow`, e.g.:
  ///
  /// <details><summary>Potential deadlock example</summary>
  ///
  /// ```text
  /// // Task 1 (on thread A)                |  // Task 2 (on thread B)
  /// let _ref1 = rx1.borrow_and_update();   |
  ///                                        |  // will block
  ///                                        |  let _ = tx.send(());
  /// // may deadlock                        |
  /// let _ref2 = rx2.borrow_and_update();   |
  /// ```
  /// </details>
  ///
  /// For more information on when to use this method versus [`borrow`], see
  /// [here](self#borrow_and_update-versus-borrow).
  ///
  /// [`changed`]: Receiver::changed
  /// [`borrow`]: Receiver::borrow
  Future<RefT> borrowAndUpdate();

  /// Returns the current capacity of the channel.
  ///
  /// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving
  /// capacity with [`Sender::reserve`]. The capacity goes up when values are received.
  /// This is distinct from [`max_capacity`], which always returns buffer capacity initially
  /// specified when calling [`channel`].
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel::<()>(5);
  ///
  /// assert_eq!(rx.capacity(), 5);
  ///
  /// // Making a reservation drops the capacity by one.
  /// let permit = tx.reserve().await.unwrap();
  /// assert_eq!(rx.capacity(), 4);
  /// assert_eq!(rx.len(), 0);
  ///
  /// // Sending and receiving a value increases the capacity by one.
  /// permit.send(());
  /// assert_eq!(rx.len(), 1);
  /// rx.recv().await.unwrap();
  /// assert_eq!(rx.capacity(), 5);
  ///
  /// // Directly sending a message drops the capacity by one.
  /// tx.send(()).await.unwrap();
  /// assert_eq!(rx.capacity(), 4);
  /// assert_eq!(rx.len(), 1);
  ///
  /// // Receiving the message increases the capacity by one.
  /// rx.recv().await.unwrap();
  /// assert_eq!(rx.capacity(), 5);
  /// assert_eq!(rx.len(), 0);
  /// # }
  /// ```
  /// [`capacity`]: Receiver::capacity
  /// [`max_capacity`]: Receiver::max_capacity
  Future<BigInt> capacity();

  /// Waits for a change notification, then marks the current value as seen.
  ///
  /// If the current value in the channel has not yet been marked seen when
  /// this method is called, the method marks that value seen and returns
  /// immediately. If the newest value has already been marked seen, then the
  /// method sleeps until a new message is sent by a [`Sender`] connected to
  /// this `Receiver`, or until all [`Sender`]s are dropped.
  ///
  /// For more information, see
  /// [*Change notifications*](self#change-notifications) in the module-level documentation.
  ///
  /// # Errors
  ///
  /// Returns a [`RecvError`](error::RecvError) if the channel has been closed __AND__
  /// the current value is seen.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If you use it as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, then it is guaranteed that no values have been marked
  /// seen by this call to `changed`.
  ///
  /// [`Sender`]: struct@Sender
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = watch::channel("hello");
  ///
  /// tokio::spawn(async move {
  ///     tx.send("goodbye").unwrap();
  /// });
  ///
  /// assert!(rx.changed().await.is_ok());
  /// assert_eq!(*rx.borrow_and_update(), "goodbye");
  ///
  /// // The `tx` handle has been dropped
  /// assert!(rx.changed().await.is_err());
  /// # }
  /// ```
  Future<void> changed();

  /// Closes the receiving half of a channel without dropping it.
  ///
  /// This prevents any further messages from being sent on the channel while
  /// still enabling the receiver to drain messages that are buffered. Any
  /// outstanding [`Permit`] values will still be able to send messages.
  ///
  /// To guarantee that no messages are dropped, after calling `close()`,
  /// `recv()` must be called until `None` is returned. If there are
  /// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will
  /// not return `None` until those are released.
  ///
  /// [`Permit`]: Permit
  /// [`OwnedPermit`]: OwnedPermit
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(20);
  ///
  /// tokio::spawn(async move {
  ///     let mut i = 0;
  ///     while let Ok(permit) = tx.reserve().await {
  ///         permit.send(i);
  ///         i += 1;
  ///     }
  /// });
  ///
  /// rx.close();
  ///
  /// while let Some(msg) = rx.recv().await {
  ///     println!("got {}", msg);
  /// }
  ///
  /// // Channel closed and no messages are lost.
  /// # }
  /// ```
  Future<void> close();

  /// Checks if this channel contains a message that this receiver has not yet
  /// seen. The current value will not be marked as seen.
  ///
  /// Although this method is called `has_changed`, it does not check
  /// messages for equality, so this call will return true even if the current
  /// message is equal to the previous message.
  ///
  /// # Errors
  ///
  /// Returns a [`RecvError`](error::RecvError) if and only if the channel has been closed.
  ///
  /// # Examples
  ///
  /// ## Basic usage
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = watch::channel("hello");
  ///
  /// tx.send("goodbye").unwrap();
  ///
  /// assert!(rx.has_changed().unwrap());
  /// assert_eq!(*rx.borrow_and_update(), "goodbye");
  ///
  /// // The value has been marked as seen
  /// assert!(!rx.has_changed().unwrap());
  /// # }
  /// ```
  ///
  /// ## Closed channel example
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, rx) = watch::channel("hello");
  /// tx.send("goodbye").unwrap();
  ///
  /// drop(tx);
  ///
  /// // The channel is closed
  /// assert!(rx.has_changed().is_err());
  /// # }
  /// ```
  Future<bool> hasChanged();

  /// Checks if a channel is closed.
  ///
  /// This method returns `true` if the channel has been closed. The channel is closed
  /// when all [`Sender`] have been dropped.
  ///
  /// [`Sender`]: crate::sync::broadcast::Sender
  ///
  /// # Examples
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, rx) = broadcast::channel::<()>(10);
  /// assert!(!rx.is_closed());
  ///
  /// drop(tx);
  ///
  /// assert!(rx.is_closed());
  /// # }
  /// ```
  Future<bool> isClosed();

  /// Returns true if there aren't any messages in the channel that the [`Receiver`]
  /// has yet to receive.
  ///
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  ///
  /// assert!(rx1.is_empty());
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  ///
  /// assert!(!rx1.is_empty());
  /// assert_eq!(rx1.recv().await.unwrap(), 10);
  /// assert_eq!(rx1.recv().await.unwrap(), 20);
  /// assert!(rx1.is_empty());
  /// # }
  /// ```
  Future<bool> isEmpty();

  /// Checks if this receiver is terminated.
  ///
  /// This function returns true if this receiver has already yielded a [`Poll::Ready`] result.
  /// If so, this receiver should no longer be polled.
  ///
  /// # Examples
  ///
  /// Sending a value and polling it.
  ///
  /// ```
  /// use tokio::sync::oneshot;
  ///
  /// use std::task::Poll;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = oneshot::channel();
  ///
  /// // A receiver is not terminated when it is initialized.
  /// assert!(!rx.is_terminated());
  ///
  /// // A receiver is not terminated it is polled and is still pending.
  /// let poll = futures::poll!(&mut rx);
  /// assert_eq!(poll, Poll::Pending);
  /// assert!(!rx.is_terminated());
  ///
  /// // A receiver is not terminated if a value has been sent, but not yet read.
  /// tx.send(0).unwrap();
  /// assert!(!rx.is_terminated());
  ///
  /// // A receiver *is* terminated after it has been polled and yielded a value.
  /// assert_eq!((&mut rx).await, Ok(0));
  /// assert!(rx.is_terminated());
  /// # }
  /// ```
  ///
  /// Dropping the sender.
  ///
  /// ```
  /// use tokio::sync::oneshot;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = oneshot::channel::<()>();
  ///
  /// // A receiver is not immediately terminated when the sender is dropped.
  /// drop(tx);
  /// assert!(!rx.is_terminated());
  ///
  /// // A receiver *is* terminated after it has been polled and yielded an error.
  /// let _ = (&mut rx).await.unwrap_err();
  /// assert!(rx.is_terminated());
  /// # }
  /// ```
  Future<bool> isTerminated();

  /// Returns the number of messages that were sent into the channel and that
  /// this [`Receiver`] has yet to receive.
  ///
  /// If the returned value from `len` is larger than the next largest power of 2
  /// of the capacity of the channel any call to [`recv`] will return an
  /// `Err(RecvError::Lagged)` and any call to [`try_recv`] will return an
  /// `Err(TryRecvError::Lagged)`, e.g. if the capacity of the channel is 10,
  /// [`recv`] will start to return `Err(RecvError::Lagged)` once `len` returns
  /// values larger than 16.
  ///
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  /// [`recv`]: crate::sync::broadcast::Receiver::recv
  /// [`try_recv`]: crate::sync::broadcast::Receiver::try_recv
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  ///
  /// assert_eq!(rx1.len(), 2);
  /// assert_eq!(rx1.recv().await.unwrap(), 10);
  /// assert_eq!(rx1.len(), 1);
  /// assert_eq!(rx1.recv().await.unwrap(), 20);
  /// assert_eq!(rx1.len(), 0);
  /// # }
  /// ```
  Future<BigInt> len();

  /// Marks the state as changed.
  ///
  /// After invoking this method [`has_changed()`](Self::has_changed)
  /// returns `true` and [`changed()`](Self::changed) returns
  /// immediately, regardless of whether a new value has been sent.
  ///
  /// This is useful for triggering an initial change notification after
  /// subscribing to synchronize new receivers.
  Future<void> markChanged();

  /// Marks the state as unchanged.
  ///
  /// The current value will be considered seen by the receiver.
  ///
  /// This is useful if you are not interested in the current value
  /// visible in the receiver.
  Future<void> markUnchanged();

  /// Returns the maximum buffer capacity of the channel.
  ///
  /// The maximum capacity is the buffer capacity initially specified when calling
  /// [`channel`]. This is distinct from [`capacity`], which returns the *current*
  /// available buffer capacity: as messages are sent and received, the value
  /// returned by [`capacity`] will go up or down, whereas the value
  /// returned by [`max_capacity`] will remain constant.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, rx) = mpsc::channel::<()>(5);
  ///
  /// // both max capacity and capacity are the same at first
  /// assert_eq!(rx.max_capacity(), 5);
  /// assert_eq!(rx.capacity(), 5);
  ///
  /// // Making a reservation doesn't change the max capacity.
  /// let permit = tx.reserve().await.unwrap();
  /// assert_eq!(rx.max_capacity(), 5);
  /// // but drops the capacity by one
  /// assert_eq!(rx.capacity(), 4);
  /// # }
  /// ```
  /// [`capacity`]: Receiver::capacity
  /// [`max_capacity`]: Receiver::max_capacity
  Future<BigInt> maxCapacity();

  /// Polls to receive the next message on this channel.
  ///
  /// This method returns:
  ///
  ///  * `Poll::Pending` if no messages are available but the channel is not
  ///    closed, or if a spurious failure happens.
  ///  * `Poll::Ready(Some(message))` if a message is available.
  ///  * `Poll::Ready(None)` if the channel has been closed and all messages
  ///    sent before it was closed have been received.
  ///
  /// When the method returns `Poll::Pending`, the `Waker` in the provided
  /// `Context` is scheduled to receive a wakeup when a message is sent on any
  /// receiver, or when the channel is closed.  Note that on multiple calls to
  /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`
  /// passed to the most recent call is scheduled to receive a wakeup.
  ///
  /// If this method returns `Poll::Pending` due to a spurious failure, then
  /// the `Waker` will be notified when the situation causing the spurious
  /// failure has been resolved. Note that receiving such a wakeup does not
  /// guarantee that the next call will succeed â€” it could fail with another
  /// spurious failure.
  Future<PollOptionT> pollRecv({required Context cx});

  /// Polls to receive multiple messages on this channel, extending the provided buffer.
  ///
  /// This method returns:
  /// * `Poll::Pending` if no messages are available but the channel is not closed, or if a
  ///   spurious failure happens.
  /// * `Poll::Ready(count)` where `count` is the number of messages successfully received and
  ///   stored in `buffer`. This can be less than, or equal to, `limit`.
  /// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.
  ///
  /// When the method returns `Poll::Pending`, the `Waker` in the provided
  /// `Context` is scheduled to receive a wakeup when a message is sent on any
  /// receiver, or when the channel is closed.  Note that on multiple calls to
  /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`
  /// passed to the most recent call is scheduled to receive a wakeup.
  ///
  /// Note that this method does not guarantee that exactly `limit` messages
  /// are received. Rather, if at least one message is available, it returns
  /// as many messages as it can up to the given limit. This method returns
  /// zero only if the channel is closed (or if `limit` is zero).
  ///
  /// # Examples
  ///
  /// ```
  /// use std::task::{Context, Poll};
  /// use std::pin::Pin;
  /// use tokio::sync::mpsc;
  /// use futures::Future;
  ///
  /// struct MyReceiverFuture<'a> {
  ///     receiver: mpsc::Receiver<i32>,
  ///     buffer: &'a mut Vec<i32>,
  ///     limit: usize,
  /// }
  ///
  /// impl<'a> Future for MyReceiverFuture<'a> {
  ///     type Output = usize; // Number of messages received
  ///
  ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
  ///         let MyReceiverFuture { receiver, buffer, limit } = &mut *self;
  ///
  ///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied
  ///         match receiver.poll_recv_many(cx, *buffer, *limit) {
  ///             Poll::Pending => Poll::Pending,
  ///             Poll::Ready(count) => Poll::Ready(count),
  ///         }
  ///     }
  /// }
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, rx) = mpsc::channel(32);
  /// let mut buffer = Vec::new();
  ///
  /// let my_receiver_future = MyReceiverFuture {
  ///     receiver: rx,
  ///     buffer: &mut buffer,
  ///     limit: 3,
  /// };
  ///
  /// for i in 0..10 {
  ///     tx.send(i).await.unwrap();
  /// }
  ///
  /// let count = my_receiver_future.await;
  /// assert_eq!(count, 3);
  /// assert_eq!(buffer, vec![0,1,2])
  /// # }
  /// ```
  Future<PollUsize> pollRecvMany(
      {required Context cx, required VecT buffer, required BigInt limit});

  /// Receives the next value for this receiver.
  ///
  /// Each [`Receiver`] handle will receive a clone of all values sent
  /// **after** it has subscribed.
  ///
  /// `Err(RecvError::Closed)` is returned when all `Sender` halves have
  /// dropped, indicating that no further values can be sent on the channel.
  ///
  /// If the [`Receiver`] handle falls behind, once the channel is full, newly
  /// sent values will overwrite old values. At this point, a call to [`recv`]
  /// will return with `Err(RecvError::Lagged)` and the [`Receiver`]'s
  /// internal cursor is updated to point to the oldest value still held by
  /// the channel. A subsequent call to [`recv`] will return this value
  /// **unless** it has been since overwritten.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If `recv` is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no messages were received on this
  /// channel.
  ///
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  /// [`recv`]: crate::sync::broadcast::Receiver::recv
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  /// let mut rx2 = tx.subscribe();
  ///
  /// tokio::spawn(async move {
  ///     assert_eq!(rx1.recv().await.unwrap(), 10);
  ///     assert_eq!(rx1.recv().await.unwrap(), 20);
  /// });
  ///
  /// tokio::spawn(async move {
  ///     assert_eq!(rx2.recv().await.unwrap(), 10);
  ///     assert_eq!(rx2.recv().await.unwrap(), 20);
  /// });
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  /// # }
  /// ```
  ///
  /// Handling lag
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = broadcast::channel(2);
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  /// tx.send(30).unwrap();
  ///
  /// // The receiver lagged behind
  /// assert!(rx.recv().await.is_err());
  ///
  /// // At this point, we can abort or continue with lost messages
  ///
  /// assert_eq!(20, rx.recv().await.unwrap());
  /// assert_eq!(30, rx.recv().await.unwrap());
  /// # }
  /// ```
  Future<T> recv();

  /// Receives the next values for this receiver and extends `buffer`.
  ///
  /// This method extends `buffer` by no more than a fixed number of values
  /// as specified by `limit`. If `limit` is zero, the function immediately
  /// returns `0`. The return value is the number of values added to `buffer`.
  ///
  /// For `limit > 0`, if there are no messages in the channel's queue, but
  /// the channel has not yet been closed, this method will sleep until a
  /// message is sent or the channel is closed. Note that if [`close`] is
  /// called, but there are still outstanding [`Permits`] from before it was
  /// closed, the channel is not considered closed by `recv_many` until the
  /// permits are released.
  ///
  /// For non-zero values of `limit`, this method will never return `0` unless
  /// the channel has been closed and there are no remaining messages in the
  /// channel's queue. This indicates that no further values can ever be
  /// received from this `Receiver`. The channel is closed when all senders
  /// have been dropped, or when [`close`] is called.
  ///
  /// The capacity of `buffer` is increased as needed.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If `recv_many` is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no messages were received on this
  /// channel.
  ///
  /// [`close`]: Self::close
  /// [`Permits`]: struct@crate::sync::mpsc::Permit
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let mut buffer: Vec<&str> = Vec::with_capacity(2);
  /// let limit = 2;
  /// let (tx, mut rx) = mpsc::channel(100);
  /// let tx2 = tx.clone();
  /// tx2.send("first").await.unwrap();
  /// tx2.send("second").await.unwrap();
  /// tx2.send("third").await.unwrap();
  ///
  /// // Call `recv_many` to receive up to `limit` (2) values.
  /// assert_eq!(2, rx.recv_many(&mut buffer, limit).await);
  /// assert_eq!(vec!["first", "second"], buffer);
  ///
  /// // If the buffer is full, the next call to `recv_many`
  /// // reserves additional capacity.
  /// assert_eq!(1, rx.recv_many(&mut buffer, 1).await);
  ///
  /// tokio::spawn(async move {
  ///     tx.send("fourth").await.unwrap();
  /// });
  ///
  /// // 'tx' is dropped, but `recv_many`
  /// // is guaranteed not to return 0 as the channel
  /// // is not yet closed.
  /// assert_eq!(1, rx.recv_many(&mut buffer, 1).await);
  /// assert_eq!(vec!["first", "second", "third", "fourth"], buffer);
  ///
  /// // Once the last sender is dropped, the channel is
  /// // closed and `recv_many` returns 0, capacity unchanged.
  /// drop(tx2);
  /// assert_eq!(0, rx.recv_many(&mut buffer, limit).await);
  /// assert_eq!(vec!["first", "second", "third", "fourth"], buffer);
  /// # }
  /// ```
  Future<BigInt> recvMany({required VecT buffer, required BigInt limit});

  /// Re-subscribes to the channel starting from the current tail element.
  ///
  /// This [`Receiver`] handle will receive a clone of all values sent
  /// **after** it has resubscribed. This will not include elements that are
  /// in the queue of the current receiver. Consider the following example.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = broadcast::channel(2);
  ///
  /// tx.send(1).unwrap();
  /// let mut rx2 = rx.resubscribe();
  /// tx.send(2).unwrap();
  ///
  /// assert_eq!(rx2.recv().await.unwrap(), 2);
  /// assert_eq!(rx.recv().await.unwrap(), 1);
  /// # }
  /// ```
  Future<ReceiverT> resubscribe();

  /// Returns `true` if receivers belong to the same channel.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, rx) = broadcast::channel::<()>(16);
  /// let rx2 = tx.subscribe();
  ///
  /// assert!(rx.same_channel(&rx2));
  ///
  /// let (_tx3, rx3) = broadcast::channel::<()>(16);
  ///
  /// assert!(!rx3.same_channel(&rx2));
  /// # }
  /// ```
  Future<bool> sameChannel({required ReceiverT other});

  /// Returns the number of [`Sender`] handles.
  Future<BigInt> senderStrongCount();

  /// Returns the number of [`WeakSender`] handles.
  Future<BigInt> senderWeakCount();

  /// Attempts to return a pending value on this receiver without awaiting.
  ///
  /// This is useful for a flavor of "optimistic check" before deciding to
  /// await on a receiver.
  ///
  /// Compared with [`recv`], this function has three failure cases instead of two
  /// (one for closed, one for an empty buffer, one for a lagging receiver).
  ///
  /// `Err(TryRecvError::Closed)` is returned when all `Sender` halves have
  /// dropped, indicating that no further values can be sent on the channel.
  ///
  /// If the [`Receiver`] handle falls behind, once the channel is full, newly
  /// sent values will overwrite old values. At this point, a call to [`recv`]
  /// will return with `Err(TryRecvError::Lagged)` and the [`Receiver`]'s
  /// internal cursor is updated to point to the oldest value still held by
  /// the channel. A subsequent call to [`try_recv`] will return this value
  /// **unless** it has been since overwritten. If there are no values to
  /// receive, `Err(TryRecvError::Empty)` is returned.
  ///
  /// [`recv`]: crate::sync::broadcast::Receiver::recv
  /// [`try_recv`]: crate::sync::broadcast::Receiver::try_recv
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = broadcast::channel(16);
  ///
  /// assert!(rx.try_recv().is_err());
  ///
  /// tx.send(10).unwrap();
  ///
  /// let value = rx.try_recv().unwrap();
  /// assert_eq!(10, value);
  /// # }
  /// ```
  Future<T> tryRecv();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender>>
abstract class Sender implements RustOpaqueInterface {
  /// Creates a new `Sender` from a [`File`].
  ///
  /// This function is intended to construct a pipe from a [`File`] representing
  /// a special FIFO file. It will check if the file is a pipe and has write access,
  /// set it in non-blocking mode and perform the conversion.
  ///
  /// # Errors
  ///
  /// Fails with `io::ErrorKind::InvalidInput` if the file is not a pipe or it
  /// does not have write access. Also fails with any standard OS error if it occurs.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Sender> fromFile({required File file}) =>
      RustLib.instance.api.tokioNetUnixPipeSenderFromFile(file: file);

  /// Creates a new `Sender` from a [`File`] without checking pipe properties.
  ///
  /// This function is intended to construct a pipe from a File representing
  /// a special FIFO file. The conversion assumes nothing about the underlying
  /// file; it is left up to the user to make sure it is opened with write access,
  /// represents a pipe and is set in non-blocking mode.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::fs::OpenOptions;
  /// use std::os::unix::fs::{FileTypeExt, OpenOptionsExt};
  /// # use std::error::Error;
  ///
  /// const FIFO_NAME: &str = "path/to/a/fifo";
  ///
  /// # async fn dox() -> Result<(), Box<dyn Error>> {
  /// let file = OpenOptions::new()
  ///     .write(true)
  ///     .custom_flags(libc::O_NONBLOCK)
  ///     .open(FIFO_NAME)?;
  /// if file.metadata()?.file_type().is_fifo() {
  ///     let tx = pipe::Sender::from_file_unchecked(file)?;
  ///     /* use the Sender */
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Sender> fromFileUnchecked({required File file}) =>
      RustLib.instance.api.tokioNetUnixPipeSenderFromFileUnchecked(file: file);

  /// Creates a new `Sender` from an [`OwnedFd`].
  ///
  /// This function is intended to construct a pipe from an [`OwnedFd`] representing
  /// an anonymous pipe or a special FIFO file. It will check if the file descriptor
  /// is a pipe and has write access, set it in non-blocking mode and perform the
  /// conversion.
  ///
  /// # Errors
  ///
  /// Fails with `io::ErrorKind::InvalidInput` if the file descriptor is not a pipe
  /// or it does not have write access. Also fails with any standard OS error if it
  /// occurs.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Sender> fromOwnedFd({required OwnedFd ownedFd}) =>
      RustLib.instance.api.tokioNetUnixPipeSenderFromOwnedFd(ownedFd: ownedFd);

  /// Creates a new `Sender` from an [`OwnedFd`] without checking pipe properties.
  ///
  /// This function is intended to construct a pipe from an [`OwnedFd`] representing
  /// an anonymous pipe or a special FIFO file. The conversion assumes nothing about
  /// the underlying pipe; it is left up to the user to make sure that the file
  /// descriptor represents the writing end of a pipe and the pipe is set in
  /// non-blocking mode.
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<Sender> fromOwnedFdUnchecked({required OwnedFd ownedFd}) =>
      RustLib.instance.api
          .tokioNetUnixPipeSenderFromOwnedFdUnchecked(ownedFd: ownedFd);

  /// Converts the pipe into an [`OwnedFd`] in blocking mode.
  ///
  /// This function will deregister this pipe end from the event loop, set
  /// it in blocking mode and perform the conversion.
  Future<OwnedFd> intoBlockingFd();

  /// Converts the pipe into an [`OwnedFd`] in nonblocking mode.
  ///
  /// This function will deregister this pipe end from the event loop and
  /// perform the conversion. The returned file descriptor will be in nonblocking
  /// mode.
  Future<OwnedFd> intoNonblockingFd();

  /// Polls for write readiness.
  ///
  /// If the pipe is not currently ready for writing, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for writing, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup.
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`writable`] is not feasible. Where possible, using [`writable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// [`writable`]: Self::writable
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for writing.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for writing.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  Future<PollResult> pollWriteReady({required Context cx});

  /// Waits for any of the requested ready states.
  ///
  /// This function can be used instead of [`writable()`] to check the returned
  /// ready set for [`Ready::WRITABLE`] and [`Ready::WRITE_CLOSED`] events.
  ///
  /// The function may complete without the pipe being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// [`writable()`]: Self::writable
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  Future<Ready> ready({required Interest interest});

  /// Tries to write a buffer to the pipe, returning how many bytes were
  /// written.
  ///
  /// The function will attempt to write the entire contents of `buf`, but
  /// only part of the buffer may be written. If the length of `buf` is not
  /// greater than `PIPE_BUF` (an OS constant, 4096 under Linux), then the
  /// write is guaranteed to be atomic, i.e. either the entire content of
  /// `buf` will be written or this method will fail with `WouldBlock`. There
  /// is no such guarantee if `buf` is larger than `PIPE_BUF`.
  ///
  /// This function is usually paired with [`writable`].
  ///
  /// [`writable`]: Self::writable
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a writing end of a fifo
  ///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         tx.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match tx.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWrite({required List<int> buf});

  /// Tries to write several buffers to the pipe, returning how many bytes
  /// were written.
  ///
  /// Data is written from each buffer in order, with the final buffer read
  /// from possible being only partially consumed. This method behaves
  /// equivalently to a single call to [`try_write()`] with concatenated
  /// buffers.
  ///
  /// If the total length of buffers is not greater than `PIPE_BUF` (an OS
  /// constant, 4096 under Linux), then the write is guaranteed to be atomic,
  /// i.e. either the entire contents of buffers will be written or this
  /// method will fail with `WouldBlock`. There is no such guarantee if the
  /// total length of buffers is greater than `PIPE_BUF`.
  ///
  /// This function is usually paired with [`writable`].
  ///
  /// [`try_write()`]: Self::try_write()
  /// [`writable`]: Self::writable
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a writing end of a fifo
  ///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
  ///
  ///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         tx.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match tx.try_write_vectored(&bufs) {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWriteVectored({required List<IoSlice> buf});

  /// Waits for the pipe to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
  /// paired with [`try_write()`].
  ///
  /// [`try_write()`]: Self::try_write
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::unix::pipe;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Open a writing end of a fifo
  ///     let tx = pipe::OpenOptions::new().open_sender("path/to/a/fifo")?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         tx.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match tx.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> writable();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < T >>>
abstract class SenderT implements RustOpaqueInterface {
  /// Blocking send to call outside of asynchronous contexts.
  ///
  /// This method is intended for use cases where you are sending from
  /// synchronous code to asynchronous code, and will work even if the
  /// receiver is not using [`blocking_recv`] to receive the message.
  ///
  /// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv
  ///
  /// # Panics
  ///
  /// This function panics if called within an asynchronous execution
  /// context.
  ///
  /// # Examples
  ///
  /// ```
  /// # #[cfg(not(target_family = "wasm"))]
  /// # {
  /// use std::thread;
  /// use tokio::runtime::Runtime;
  /// use tokio::sync::mpsc;
  ///
  /// fn main() {
  ///     let (tx, mut rx) = mpsc::channel::<u8>(1);
  ///
  ///     let sync_code = thread::spawn(move || {
  ///         tx.blocking_send(10).unwrap();
  ///     });
  ///
  ///     Runtime::new().unwrap().block_on(async move {
  ///         assert_eq!(Some(10), rx.recv().await);
  ///     });
  ///     sync_code.join().unwrap()
  /// }
  /// # }
  /// ```
  Future<void> blockingSend({required T value});

  /// Returns a reference to the most recently sent value
  ///
  /// Outstanding borrows hold a read lock on the inner value. This means that
  /// long-lived borrows could cause the producer half to block. It is recommended
  /// to keep the borrow as short-lived as possible. Additionally, if you are
  /// running in an environment that allows `!Send` futures, you must ensure that
  /// the returned `Ref` type is never held alive across an `.await` point,
  /// otherwise, it can lead to a deadlock.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// let (tx, _) = watch::channel("hello");
  /// assert_eq!(*tx.borrow(), "hello");
  /// ```
  Future<RefT> borrow();

  /// Returns the current capacity of the channel.
  ///
  /// The capacity goes down when sending a value by calling [`send`] or by reserving capacity
  /// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].
  /// This is distinct from [`max_capacity`], which always returns buffer capacity initially
  /// specified when calling [`channel`]
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel::<()>(5);
  ///
  /// assert_eq!(tx.capacity(), 5);
  ///
  /// // Making a reservation drops the capacity by one.
  /// let permit = tx.reserve().await.unwrap();
  /// assert_eq!(tx.capacity(), 4);
  ///
  /// // Sending and receiving a value increases the capacity by one.
  /// permit.send(());
  /// rx.recv().await.unwrap();
  /// assert_eq!(tx.capacity(), 5);
  /// # }
  /// ```
  ///
  /// [`send`]: Sender::send
  /// [`reserve`]: Sender::reserve
  /// [`channel`]: channel
  /// [`max_capacity`]: Sender::max_capacity
  Future<BigInt> capacity();

  /// A future which completes when the number of [Receiver]s subscribed to this `Sender` reaches
  /// zero.
  ///
  /// # Examples
  ///
  /// ```
  /// use futures::FutureExt;
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel::<u32>(16);
  /// let mut rx2 = tx.subscribe();
  ///
  /// let _ = tx.send(10);
  ///
  /// assert_eq!(rx1.recv().await.unwrap(), 10);
  /// drop(rx1);
  /// assert!(tx.closed().now_or_never().is_none());
  ///
  /// assert_eq!(rx2.recv().await.unwrap(), 10);
  /// drop(rx2);
  /// assert!(tx.closed().now_or_never().is_some());
  /// # }
  /// ```
  Future<void> closed();

  static Future<SenderT> default_() =>
      RustLib.instance.api.tokioNetUnixPipeSenderTDefault();

  /// Converts the `Sender` to a [`WeakSender`] that does not count
  /// towards RAII semantics, i.e. if all `Sender` instances of the
  /// channel were dropped and only `WeakSender` instances remain,
  /// the channel is closed.
  Future<WeakSenderT> downgrade();

  /// Checks if the channel has been closed. This happens when the
  /// [`Receiver`] is dropped, or when the [`Receiver::close`] method is
  /// called.
  ///
  /// [`Receiver`]: crate::sync::mpsc::Receiver
  /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close
  ///
  /// ```
  /// let (tx, rx) = tokio::sync::mpsc::channel::<()>(42);
  /// assert!(!tx.is_closed());
  ///
  /// let tx2 = tx.clone();
  /// assert!(!tx2.is_closed());
  ///
  /// drop(rx);
  /// assert!(tx.is_closed());
  /// assert!(tx2.is_closed());
  /// ```
  Future<bool> isClosed();

  /// Returns true if there are no queued values.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  /// let mut rx2 = tx.subscribe();
  ///
  /// assert!(tx.is_empty());
  ///
  /// tx.send(10).unwrap();
  ///
  /// assert!(!tx.is_empty());
  ///
  /// rx1.recv().await.unwrap();
  ///
  /// // The queue is still not empty since rx2 hasn't seen the value.
  /// assert!(!tx.is_empty());
  ///
  /// rx2.recv().await.unwrap();
  ///
  /// assert!(tx.is_empty());
  /// # }
  /// ```
  Future<bool> isEmpty();

  /// Returns the number of queued values.
  ///
  /// A value is queued until it has either been seen by all receivers that were alive at the time
  /// it was sent, or has been evicted from the queue by subsequent sends that exceeded the
  /// queue's capacity.
  ///
  /// # Note
  ///
  /// In contrast to [`Receiver::len`], this method only reports queued values and not values that
  /// have been evicted from the queue before being seen by all receivers.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  /// let mut rx2 = tx.subscribe();
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  /// tx.send(30).unwrap();
  ///
  /// assert_eq!(tx.len(), 3);
  ///
  /// rx1.recv().await.unwrap();
  ///
  /// // The len is still 3 since rx2 hasn't seen the first value yet.
  /// assert_eq!(tx.len(), 3);
  ///
  /// rx2.recv().await.unwrap();
  ///
  /// assert_eq!(tx.len(), 2);
  /// # }
  /// ```
  Future<BigInt> len();

  /// Returns the maximum buffer capacity of the channel.
  ///
  /// The maximum capacity is the buffer capacity initially specified when calling
  /// [`channel`]. This is distinct from [`capacity`], which returns the *current*
  /// available buffer capacity: as messages are sent and received, the
  /// value returned by [`capacity`] will go up or down, whereas the value
  /// returned by [`max_capacity`] will remain constant.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, _rx) = mpsc::channel::<()>(5);
  ///
  /// // both max capacity and capacity are the same at first
  /// assert_eq!(tx.max_capacity(), 5);
  /// assert_eq!(tx.capacity(), 5);
  ///
  /// // Making a reservation doesn't change the max capacity.
  /// let permit = tx.reserve().await.unwrap();
  /// assert_eq!(tx.max_capacity(), 5);
  /// // but drops the capacity by one
  /// assert_eq!(tx.capacity(), 4);
  /// # }
  /// ```
  ///
  /// [`channel`]: channel
  /// [`max_capacity`]: Sender::max_capacity
  /// [`capacity`]: Sender::capacity
  Future<BigInt> maxCapacity();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates the sending-half of the [`broadcast`] channel.
  ///
  /// See the documentation of [`broadcast::channel`] for more information on this method.
  ///
  /// [`broadcast`]: crate::sync::broadcast
  /// [`broadcast::channel`]: crate::sync::broadcast::channel
  static Future<SenderT> newInstance({required BigInt capacity}) =>
      RustLib.instance.api.tokioNetUnixPipeSenderTNew(capacity: capacity);

  /// Checks whether the `oneshot` channel has been closed, and if not, schedules the
  /// `Waker` in the provided `Context` to receive a notification when the channel is
  /// closed.
  ///
  /// A [`Receiver`] is closed by either calling [`close`] explicitly, or when the
  /// [`Receiver`] value is dropped.
  ///
  /// Note that on multiple calls to poll, only the `Waker` from the `Context` passed
  /// to the most recent call will be scheduled to receive a wakeup.
  ///
  /// [`Receiver`]: struct@crate::sync::oneshot::Receiver
  /// [`close`]: fn@crate::sync::oneshot::Receiver::close
  ///
  /// # Return value
  ///
  /// This function returns:
  ///
  ///  * `Poll::Pending` if the channel is still open.
  ///  * `Poll::Ready(())` if the channel is closed.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::oneshot;
  ///
  /// use std::future::poll_fn;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (mut tx, mut rx) = oneshot::channel::<()>();
  ///
  /// tokio::spawn(async move {
  ///     rx.close();
  /// });
  ///
  /// poll_fn(|cx| tx.poll_closed(cx)).await;
  ///
  /// println!("the receiver dropped");
  /// # }
  /// ```
  Future<Poll> pollClosed({required Context cx});

  /// Returns the number of active receivers.
  ///
  /// An active receiver is a [`Receiver`] handle returned from [`channel`] or
  /// [`subscribe`]. These are the handles that will receive values sent on
  /// this [`Sender`].
  ///
  /// # Note
  ///
  /// It is not guaranteed that a sent message will reach this number of
  /// receivers. Active receivers may never call [`recv`] again before
  /// dropping.
  ///
  /// [`recv`]: crate::sync::broadcast::Receiver::recv
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  /// [`Sender`]: crate::sync::broadcast::Sender
  /// [`subscribe`]: crate::sync::broadcast::Sender::subscribe
  /// [`channel`]: crate::sync::broadcast::channel
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, _rx1) = broadcast::channel(16);
  ///
  /// assert_eq!(1, tx.receiver_count());
  ///
  /// let mut _rx2 = tx.subscribe();
  ///
  /// assert_eq!(2, tx.receiver_count());
  ///
  /// tx.send(10).unwrap();
  /// # }
  /// ```
  Future<BigInt> receiverCount();

  /// Waits for channel capacity. Once capacity to send one message is
  /// available, it is reserved for the caller.
  ///
  /// If the channel is full, the function waits for the number of unreceived
  /// messages to become less than the channel capacity. Capacity to send one
  /// message is reserved for the caller. A [`Permit`] is returned to track
  /// the reserved capacity. The [`send`] function on [`Permit`] consumes the
  /// reserved capacity.
  ///
  /// Dropping [`Permit`] without sending a message releases the capacity back
  /// to the channel.
  ///
  /// [`Permit`]: Permit
  /// [`send`]: Permit::send
  ///
  /// # Cancel safety
  ///
  /// This channel uses a queue to ensure that calls to `send` and `reserve`
  /// complete in the order they were requested.  Cancelling a call to
  /// `reserve` makes you lose your place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// // Reserve capacity
  /// let permit = tx.reserve().await.unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Sending on the permit succeeds
  /// permit.send(456);
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  /// # }
  /// ```
  Future<PermitT> reserve();

  /// Waits for channel capacity. Once capacity to send `n` messages is
  /// available, it is reserved for the caller.
  ///
  /// If the channel is full or if there are fewer than `n` permits available, the function waits
  /// for the number of unreceived messages to become `n` less than the channel capacity.
  /// Capacity to send `n` message is then reserved for the caller.
  ///
  /// A [`PermitIterator`] is returned to track the reserved capacity.
  /// You can call this [`Iterator`] until it is exhausted to
  /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to
  /// [`try_reserve_many`] except it waits for the slots to become available.
  ///
  /// If the channel is closed, the function returns a [`SendError`].
  ///
  /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining
  /// permits back to the channel.
  ///
  /// [`PermitIterator`]: PermitIterator
  /// [`Permit`]: Permit
  /// [`send`]: Permit::send
  /// [`try_reserve_many`]: Sender::try_reserve_many
  ///
  /// # Cancel safety
  ///
  /// This channel uses a queue to ensure that calls to `send` and `reserve_many`
  /// complete in the order they were requested. Cancelling a call to
  /// `reserve_many` makes you lose your place in the queue.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(2);
  ///
  /// // Reserve capacity
  /// let mut permit = tx.reserve_many(2).await.unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Sending with the permit iterator succeeds
  /// permit.next().unwrap().send(456);
  /// permit.next().unwrap().send(457);
  ///
  /// // The iterator should now be exhausted
  /// assert!(permit.next().is_none());
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  /// assert_eq!(rx.recv().await.unwrap(), 457);
  /// # }
  /// ```
  Future<PermitIteratorT> reserveMany({required BigInt n});

  /// Waits for channel capacity, moving the `Sender` and returning an owned
  /// permit. Once capacity to send one message is available, it is reserved
  /// for the caller.
  ///
  /// This moves the sender _by value_, and returns an owned permit that can
  /// be used to send a message into the channel. Unlike [`Sender::reserve`],
  /// this method may be used in cases where the permit must be valid for the
  /// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is
  /// essentially a reference count increment, comparable to [`Arc::clone`]),
  /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be
  /// moved, it can be cloned prior to calling `reserve_owned`.
  ///
  /// If the channel is full, the function waits for the number of unreceived
  /// messages to become less than the channel capacity. Capacity to send one
  /// message is reserved for the caller. An [`OwnedPermit`] is returned to
  /// track the reserved capacity. The [`send`] function on [`OwnedPermit`]
  /// consumes the reserved capacity.
  ///
  /// Dropping the [`OwnedPermit`] without sending a message releases the
  /// capacity back to the channel.
  ///
  /// # Cancel safety
  ///
  /// This channel uses a queue to ensure that calls to `send` and `reserve`
  /// complete in the order they were requested.  Cancelling a call to
  /// `reserve_owned` makes you lose your place in the queue.
  ///
  /// # Examples
  /// Sending a message using an [`OwnedPermit`]:
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// // Reserve capacity, moving the sender.
  /// let permit = tx.reserve_owned().await.unwrap();
  ///
  /// // Send a message, consuming the permit and returning
  /// // the moved sender.
  /// let tx = permit.send(123);
  ///
  /// // The value sent on the permit is received.
  /// assert_eq!(rx.recv().await.unwrap(), 123);
  ///
  /// // The sender can now be used again.
  /// tx.send(456).await.unwrap();
  /// # }
  /// ```
  ///
  /// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved
  /// by value, it can be inexpensively cloned before calling `reserve_owned`:
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// // Clone the sender and reserve capacity.
  /// let permit = tx.clone().reserve_owned().await.unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Sending on the permit succeeds.
  /// permit.send(456);
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  /// # }
  /// ```
  ///
  /// [`Sender::reserve`]: Sender::reserve
  /// [`OwnedPermit`]: OwnedPermit
  /// [`send`]: OwnedPermit::send
  /// [`Arc::clone`]: std::sync::Arc::clone
  Future<OwnedPermitT> reserveOwned();

  /// Returns `true` if senders belong to the same channel.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, _rx) = broadcast::channel::<()>(16);
  /// let tx2 = tx.clone();
  ///
  /// assert!(tx.same_channel(&tx2));
  ///
  /// let (tx3, _rx3) = broadcast::channel::<()>(16);
  ///
  /// assert!(!tx3.same_channel(&tx2));
  /// # }
  /// ```
  Future<bool> sameChannel({required SenderT other});

  /// Attempts to send a value to all active [`Receiver`] handles, returning
  /// it back if it could not be sent.
  ///
  /// A successful send occurs when there is at least one active [`Receiver`]
  /// handle. An unsuccessful send would be one where all associated
  /// [`Receiver`] handles have already been dropped.
  ///
  /// # Return
  ///
  /// On success, the number of subscribed [`Receiver`] handles is returned.
  /// This does not mean that this number of receivers will see the message as
  /// a receiver may drop or lag ([see lagging](self#lagging)) before receiving
  /// the message.
  ///
  /// # Note
  ///
  /// A return value of `Ok` **does not** mean that the sent value will be
  /// observed by all or any of the active [`Receiver`] handles. [`Receiver`]
  /// handles may be dropped before receiving the sent message.
  ///
  /// A return value of `Err` **does not** mean that future calls to `send`
  /// will fail. New [`Receiver`] handles may be created by calling
  /// [`subscribe`].
  ///
  /// [`Receiver`]: crate::sync::broadcast::Receiver
  /// [`subscribe`]: crate::sync::broadcast::Sender::subscribe
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx1) = broadcast::channel(16);
  /// let mut rx2 = tx.subscribe();
  ///
  /// tokio::spawn(async move {
  ///     assert_eq!(rx1.recv().await.unwrap(), 10);
  ///     assert_eq!(rx1.recv().await.unwrap(), 20);
  /// });
  ///
  /// tokio::spawn(async move {
  ///     assert_eq!(rx2.recv().await.unwrap(), 10);
  ///     assert_eq!(rx2.recv().await.unwrap(), 20);
  /// });
  ///
  /// tx.send(10).unwrap();
  /// tx.send(20).unwrap();
  /// # }
  /// ```
  Future<BigInt> send({required T value});

  /// Sends a new value via the channel, notifying all receivers and returning
  /// the previous value in the channel.
  ///
  /// This can be useful for reusing the buffers inside a watched value.
  /// Additionally, this method permits sending values even when there are no
  /// receivers.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// let (tx, _rx) = watch::channel(1);
  /// assert_eq!(tx.send_replace(2), 1);
  /// assert_eq!(tx.send_replace(3), 2);
  /// ```
  Future<T> sendReplace({required T value});

  /// Sends a value, waiting until there is capacity, but only for a limited time.
  ///
  /// Shares the same success and error conditions as [`send`], adding one more
  /// condition for an unsuccessful send, which is when the provided timeout has
  /// elapsed, and there is no capacity available.
  ///
  /// [`send`]: Sender::send
  ///
  /// # Errors
  ///
  /// If the receive half of the channel is closed, either due to [`close`]
  /// being called or the [`Receiver`] having been dropped,
  /// the function returns an error. The error includes the value passed to `send`.
  ///
  /// [`close`]: Receiver::close
  /// [`Receiver`]: Receiver
  ///
  /// # Panics
  ///
  /// This function panics if it is called outside the context of a Tokio
  /// runtime [with time enabled](crate::runtime::Builder::enable_time).
  ///
  /// # Examples
  ///
  /// In the following example, each call to `send_timeout` will block until the
  /// previously sent value was received, unless the timeout has elapsed.
  ///
  /// ```rust
  /// use tokio::sync::mpsc;
  /// use tokio::time::{sleep, Duration};
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// tokio::spawn(async move {
  ///     for i in 0..10 {
  ///         if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {
  ///             println!("send error: #{:?}", e);
  ///             return;
  ///         }
  ///     }
  /// });
  ///
  /// while let Some(i) = rx.recv().await {
  ///     println!("got = {}", i);
  ///     sleep(Duration::from_millis(200)).await;
  /// }
  /// # }
  /// ```
  Future<void> sendTimeout({required T value, required Duration timeout});

  /// Returns the number of senders that currently exist.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::watch;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx1, rx) = watch::channel("hello");
  ///
  /// assert_eq!(1, tx1.sender_count());
  ///
  /// let tx2 = tx1.clone();
  ///
  /// assert_eq!(2, tx1.sender_count());
  /// assert_eq!(2, tx2.sender_count());
  /// # }
  /// ```
  Future<BigInt> senderCount();

  /// Returns the number of [`Sender`] handles.
  Future<BigInt> strongCount();

  /// Creates a new [`Receiver`] handle that will receive values sent **after**
  /// this call to `subscribe`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::broadcast;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, _rx) = broadcast::channel(16);
  ///
  /// // Will not be seen
  /// tx.send(10).unwrap();
  ///
  /// let mut rx = tx.subscribe();
  ///
  /// tx.send(20).unwrap();
  ///
  /// let value = rx.recv().await.unwrap();
  /// assert_eq!(20, value);
  /// # }
  /// ```
  Future<ReceiverT> subscribe();

  /// Tries to acquire a slot in the channel without waiting for the slot to become
  /// available.
  ///
  /// If the channel is full this function will return [`TrySendError`], otherwise
  /// if there is a slot available it will return a [`Permit`] that will then allow you
  /// to [`send`] on the channel with a guaranteed slot. This function is similar to
  /// [`reserve`] except it does not await for the slot to become available.
  ///
  /// Dropping [`Permit`] without sending a message releases the capacity back
  /// to the channel.
  ///
  /// [`Permit`]: Permit
  /// [`send`]: Permit::send
  /// [`reserve`]: Sender::reserve
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// // Reserve capacity
  /// let permit = tx.try_reserve().unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Trying to reserve an additional slot on the `tx` will
  /// // fail because there is no capacity.
  /// assert!(tx.try_reserve().is_err());
  ///
  /// // Sending on the permit succeeds
  /// permit.send(456);
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  ///
  /// # }
  /// ```
  Future<PermitT> tryReserve();

  /// Tries to acquire `n` slots in the channel without waiting for the slot to become
  /// available.
  ///
  /// A [`PermitIterator`] is returned to track the reserved capacity.
  /// You can call this [`Iterator`] until it is exhausted to
  /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to
  /// [`reserve_many`] except it does not await for the slots to become available.
  ///
  /// If there are fewer than `n` permits available on the channel, then
  /// this function will return a [`TrySendError::Full`]. If the channel is closed
  /// this function will return a [`TrySendError::Closed`].
  ///
  /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining
  /// permits back to the channel.
  ///
  /// [`PermitIterator`]: PermitIterator
  /// [`send`]: Permit::send
  /// [`reserve_many`]: Sender::reserve_many
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(2);
  ///
  /// // Reserve capacity
  /// let mut permit = tx.try_reserve_many(2).unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Trying to reserve an additional slot on the `tx` will
  /// // fail because there is no capacity.
  /// assert!(tx.try_reserve().is_err());
  ///
  /// // Sending with the permit iterator succeeds
  /// permit.next().unwrap().send(456);
  /// permit.next().unwrap().send(457);
  ///
  /// // The iterator should now be exhausted
  /// assert!(permit.next().is_none());
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  /// assert_eq!(rx.recv().await.unwrap(), 457);
  ///
  /// // Trying to call try_reserve_many with 0 will return an empty iterator
  /// let mut permit = tx.try_reserve_many(0).unwrap();
  /// assert!(permit.next().is_none());
  ///
  /// // Trying to call try_reserve_many with a number greater than the channel
  /// // capacity will return an error
  /// let permit = tx.try_reserve_many(3);
  /// assert!(permit.is_err());
  ///
  /// // Trying to call try_reserve_many on a closed channel will return an error
  /// drop(rx);
  /// let permit = tx.try_reserve_many(1);
  /// assert!(permit.is_err());
  ///
  /// let permit = tx.try_reserve_many(0);
  /// assert!(permit.is_err());
  /// # }
  /// ```
  Future<PermitIteratorT> tryReserveMany({required BigInt n});

  /// Tries to acquire a slot in the channel without waiting for the slot to become
  /// available, returning an owned permit.
  ///
  /// This moves the sender _by value_, and returns an owned permit that can
  /// be used to send a message into the channel. Unlike [`Sender::try_reserve`],
  /// this method may be used in cases where the permit must be valid for the
  /// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is
  /// essentially a reference count increment, comparable to [`Arc::clone`]),
  /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be
  /// moved, it can be cloned prior to calling `try_reserve_owned`.
  ///
  /// If the channel is full this function will return a [`TrySendError`].
  /// Since the sender is taken by value, the `TrySendError` returned in this
  /// case contains the sender, so that it may be used again. Otherwise, if
  /// there is a slot available, this method will return an [`OwnedPermit`]
  /// that can then be used to [`send`] on the channel with a guaranteed slot.
  /// This function is similar to  [`reserve_owned`] except it does not await
  /// for the slot to become available.
  ///
  /// Dropping the [`OwnedPermit`] without sending a message releases the capacity back
  /// to the channel.
  ///
  /// [`OwnedPermit`]: OwnedPermit
  /// [`send`]: OwnedPermit::send
  /// [`reserve_owned`]: Sender::reserve_owned
  /// [`Arc::clone`]: std::sync::Arc::clone
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// let (tx, mut rx) = mpsc::channel(1);
  ///
  /// // Reserve capacity
  /// let permit = tx.clone().try_reserve_owned().unwrap();
  ///
  /// // Trying to send directly on the `tx` will fail due to no
  /// // available capacity.
  /// assert!(tx.try_send(123).is_err());
  ///
  /// // Trying to reserve an additional slot on the `tx` will
  /// // fail because there is no capacity.
  /// assert!(tx.try_reserve().is_err());
  ///
  /// // Sending on the permit succeeds
  /// permit.send(456);
  ///
  /// // The value sent on the permit is received
  /// assert_eq!(rx.recv().await.unwrap(), 456);
  ///
  /// # }
  /// ```
  Future<OwnedPermitT> tryReserveOwned();

  /// Attempts to immediately send a message on this `Sender`.
  ///
  /// This method differs from [`send`] by returning immediately if the channel's
  /// buffer is full or no receiver is waiting to acquire some data. Compared
  /// with [`send`], this function has two failure cases instead of one (one for
  /// disconnection, one for a full buffer).
  ///
  /// # Errors
  ///
  /// If the channel capacity has been reached, i.e., the channel has `n`
  /// buffered values where `n` is the argument passed to [`channel`], then an
  /// error is returned.
  ///
  /// If the receive half of the channel is closed, either due to [`close`]
  /// being called or the [`Receiver`] handle dropping, the function returns
  /// an error. The error includes the value passed to `send`.
  ///
  /// [`send`]: Sender::send
  /// [`channel`]: channel
  /// [`close`]: Receiver::close
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::sync::mpsc;
  ///
  /// # #[tokio::main(flavor = "current_thread")]
  /// # async fn main() {
  /// // Create a channel with buffer size 1
  /// let (tx1, mut rx) = mpsc::channel(1);
  /// let tx2 = tx1.clone();
  ///
  /// tokio::spawn(async move {
  ///     tx1.send(1).await.unwrap();
  ///     tx1.send(2).await.unwrap();
  ///     // task waits until the receiver receives a value.
  /// });
  ///
  /// tokio::spawn(async move {
  ///     // This will return an error and send
  ///     // no message if the buffer is full
  ///     let _ = tx2.try_send(3);
  /// });
  ///
  /// let mut msg;
  /// msg = rx.recv().await.unwrap();
  /// println!("message {} received", msg);
  ///
  /// msg = rx.recv().await.unwrap();
  /// println!("message {} received", msg);
  ///
  /// // Third message may have never been sent
  /// match rx.recv().await {
  ///     Some(msg) => println!("message {} received", msg),
  ///     None => println!("the third message was never sent"),
  /// }
  /// # }
  /// ```
  Future<void> trySend({required T message});

  /// Returns the number of [`WeakSender`] handles.
  Future<BigInt> weakCount();
}
