// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'process/sys.dart';

// These functions are ignored because they have generic arguments: `arg0`, `arg`, `args`, `current_dir`, `env_remove`, `env`, `envs`, `new`, `pre_exec`, `stderr`, `stdin`, `stdout`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChildDropGuard`, `FusedChild`, `SpawnedChild`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `drop`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `is_write_vectored`, `kill`, `poll_flush`, `poll_read`, `poll_read`, `poll_shutdown`, `poll_write_vectored`, `poll_write`, `poll`, `try_into`, `try_into`, `try_into`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `output`, `status`, `wait_with_output`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Child>>
abstract class Child implements RustOpaqueInterface {
  ChildStderr? get stderr;

  ChildStdin? get stdin;

  ChildStdout? get stdout;

  set stderr(ChildStderr? stderr);

  set stdin(ChildStdin? stdin);

  set stdout(ChildStdout? stdout);

  /// Returns the OS-assigned process identifier associated with this child
  /// while it is still running.
  ///
  /// Once the child has been polled to completion this will return `None`.
  /// This is done to avoid confusion on platforms like Unix where the OS
  /// identifier could be reused once the process has completed.
  Future<int?> id();

  /// Forces the child to exit.
  ///
  /// This is equivalent to sending a `SIGKILL` on unix platforms
  /// followed by [`wait`](Child::wait).
  ///
  /// Note: std version of [`Child::kill`](std::process::Child::kill) does not `wait`.
  /// For an equivalent of `Child::kill` in the standard library,
  /// use [`start_kill`](Child::start_kill).
  ///
  /// # Examples
  ///
  /// If the child has to be killed remotely, it is possible to do it using
  /// a combination of the select! macro and a `oneshot` channel. In the following
  /// example, the child will run until completion unless a message is sent on
  /// the `oneshot` channel. If that happens, the child is killed immediately
  /// using the `.kill()` method.
  ///
  /// ```no_run
  /// use tokio::process::Command;
  /// use tokio::sync::oneshot::channel;
  ///
  /// #[tokio::main]
  /// async fn main() {
  ///     let (send, recv) = channel::<()>();
  ///     let mut child = Command::new("sleep").arg("1").spawn().unwrap();
  ///     tokio::spawn(async move { send.send(()) });
  ///     tokio::select! {
  ///         _ = child.wait() => {}
  ///         _ = recv => child.kill().await.expect("kill failed"),
  ///     }
  /// }
  /// ```
  ///
  /// You can also interact with the child's standard I/O. For example, you can
  /// read its stdout while waiting for it to exit.
  ///
  /// ```no_run
  /// # use std::process::Stdio;
  /// #
  /// # use tokio::io::AsyncReadExt;
  /// # use tokio::process::Command;
  /// # use tokio::sync::oneshot::channel;
  ///
  /// #[tokio::main]
  /// async fn main() {
  ///     let (_tx, rx) = channel::<()>();
  ///
  ///     let mut child = Command::new("echo")
  ///         .arg("Hello World!")
  ///         .stdout(Stdio::piped())
  ///         .spawn()
  ///         .unwrap();
  ///
  ///     let mut stdout = child.stdout.take().expect("stdout is not captured");
  ///
  ///     let read_stdout = tokio::spawn(async move {
  ///         let mut buff = Vec::new();
  ///         let _ = stdout.read_to_end(&mut buff).await;
  ///
  ///         buff
  ///     });
  ///
  ///     tokio::select! {
  ///         _ = child.wait() => {}
  ///         _ = rx => { child.kill().await.expect("kill failed") },
  ///     }
  ///
  ///     let buff = read_stdout.await.unwrap();
  ///
  ///     assert_eq!(buff, b"Hello World!\n");
  /// }
  /// ```
  Future<void> kill();

  /// Attempts to force the child to exit, but does not wait for the request
  /// to take effect.
  ///
  /// On Unix platforms, this is the equivalent to sending a `SIGKILL`. Note
  /// that on Unix platforms it is possible for a zombie process to remain
  /// after a kill is sent; to avoid this, the caller should ensure that either
  /// `child.wait().await` or `child.try_wait()` is invoked successfully.
  Future<void> startKill();

  /// Attempts to collect the exit status of the child if it has already
  /// exited.
  ///
  /// This function will not block the calling thread and will only
  /// check to see if the child process has exited or not. If the child has
  /// exited then on Unix the process ID is reaped. This function is
  /// guaranteed to repeatedly return a successful exit status so long as the
  /// child has already exited.
  ///
  /// If the child has exited, then `Ok(Some(status))` is returned. If the
  /// exit status is not available at this time then `Ok(None)` is returned.
  /// If an error occurs, then that error is returned.
  ///
  /// Note that unlike `wait`, this function will not attempt to drop stdin,
  /// nor will it wake the current task if the child exits.
  Future<ExitStatus?> tryWait();

  /// Waits for the child to exit completely, returning the status that it
  /// exited with. This function will continue to have the same return value
  /// after it has been called at least once.
  ///
  /// The stdin handle to the child process, if any, will be closed
  /// before waiting. This helps avoid deadlock: it ensures that the
  /// child does not block waiting for input from the parent, while
  /// the parent waits for the child to exit.
  ///
  /// If the caller wishes to explicitly control when the child's stdin
  /// handle is closed, they may `.take()` it before calling `.wait()`:
  ///
  /// # Cancel safety
  ///
  /// This function is cancel safe.
  ///
  /// ```
  /// # #[cfg(not(unix))]fn main(){}
  /// # #[cfg(unix)]
  /// use tokio::io::AsyncWriteExt;
  /// # #[cfg(unix)]
  /// use tokio::process::Command;
  /// # #[cfg(unix)]
  /// use std::process::Stdio;
  ///
  /// # #[cfg(unix)]
  /// #[tokio::main]
  /// async fn main() {
  /// #   if cfg!(miri) { return; } // No `pidfd_spawnp` in miri.
  ///     let mut child = Command::new("cat")
  ///         .stdin(Stdio::piped())
  ///         .spawn()
  ///         .unwrap();
  ///
  ///     let mut stdin = child.stdin.take().unwrap();
  ///     tokio::spawn(async move {
  ///         // do something with stdin here...
  ///         stdin.write_all(b"hello world\n").await.unwrap();
  ///
  ///         // then drop when finished
  ///         drop(stdin);
  ///     });
  ///
  ///     // wait for the process to complete
  ///     let _ = child.wait().await;
  /// }
  /// ```
  Future<ExitStatus> wait();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStderr>>
abstract class ChildStderr implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStderr` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStderr> fromStd({required ChildStderr inner}) =>
      RustLib.instance.api.tokioProcessChildStderrFromStd(inner: inner);

  /// Convert into [`OwnedFd`].
  Future<OwnedFd> intoOwnedFd();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStdin>>
abstract class ChildStdin implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStdin` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStdin> fromStd({required ChildStdin inner}) =>
      RustLib.instance.api.tokioProcessChildStdinFromStd(inner: inner);

  /// Convert into [`OwnedFd`].
  Future<OwnedFd> intoOwnedFd();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStdout>>
abstract class ChildStdout implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStdout` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStdout> fromStd({required ChildStdout inner}) =>
      RustLib.instance.api.tokioProcessChildStdoutFromStd(inner: inner);

  /// Convert into [`OwnedFd`].
  Future<OwnedFd> intoOwnedFd();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Command>>
abstract class Command implements RustOpaqueInterface {
  /// Cheaply convert to a `&std::process::Command` for places where the type from the standard
  /// library is expected.
  Future<void> asStd();

  /// Cheaply convert to a `&mut std::process::Command` for places where the type from the
  /// standard library is expected.
  Future<void> asStdMut();

  /// Clears the entire environment map for the child process.
  ///
  /// # Examples
  ///
  /// Basic usage:
  ///
  /// ```no_run
  /// # async fn test() { // allow using await
  /// use tokio::process::Command;
  ///
  /// let output = Command::new("ls")
  ///         .env_clear()
  ///         .output().await.unwrap();
  /// # }
  /// ```
  Future<void> envClear();

  /// Returns the boolean value that was previously set by [`Command::kill_on_drop`].
  ///
  /// Note that if you have not previously called [`Command::kill_on_drop`], the
  /// default value of `false` will be returned here.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::process::Command;
  ///
  /// let mut cmd = Command::new("echo");
  /// assert!(!cmd.get_kill_on_drop());
  ///
  /// cmd.kill_on_drop(true);
  /// assert!(cmd.get_kill_on_drop());
  /// ```
  Future<bool> getKillOnDrop();

  /// Similar to `uid` but sets the group ID of the child process. This has
  /// the same semantics as the `uid` field.
  Future<void> gid({required int id});

  /// Cheaply convert into a `std::process::Command`.
  ///
  /// Note that Tokio specific options will be lost. Currently, this only applies to [`kill_on_drop`].
  ///
  /// [`kill_on_drop`]: Command::kill_on_drop
  Future<StdCommand> intoStd();

  /// Controls whether a `kill` operation should be invoked on a spawned child
  /// process when its corresponding `Child` handle is dropped.
  ///
  /// By default, this value is assumed to be `false`, meaning the next spawned
  /// process will not be killed on drop, similar to the behavior of the standard
  /// library.
  ///
  /// # Caveats
  ///
  /// On Unix platforms processes must be "reaped" by their parent process after
  /// they have exited in order to release all OS resources. A child process which
  /// has exited, but has not yet been reaped by its parent is considered a "zombie"
  /// process. Such processes continue to count against limits imposed by the system,
  /// and having too many zombie processes present can prevent additional processes
  /// from being spawned.
  ///
  /// Although issuing a `kill` signal to the child process is a synchronous
  /// operation, the resulting zombie process cannot be `.await`ed inside of the
  /// destructor to avoid blocking other tasks. The tokio runtime will, on a
  /// best-effort basis, attempt to reap and clean up such processes in the
  /// background, but no additional guarantees are made with regard to
  /// how quickly or how often this procedure will take place.
  ///
  /// If stronger guarantees are required, it is recommended to avoid dropping
  /// a [`Child`] handle where possible, and instead utilize `child.wait().await`
  /// or `child.kill().await` where possible.
  Future<void> killOnDrop({required bool killOnDrop});

  /// Sets the process group ID (PGID) of the child process. Equivalent to a
  /// `setpgid` call in the child process, but may be more efficient.
  ///
  /// Process groups determine which processes receive signals.
  ///
  /// # Examples
  ///
  /// Pressing Ctrl-C in a terminal will send `SIGINT` to all processes
  /// in the current foreground process group. By spawning the `sleep`
  /// subprocess in a new process group, it will not receive `SIGINT`
  /// from the terminal.
  ///
  /// The parent process could install a [signal handler] and manage the
  /// process on its own terms.
  ///
  /// A process group ID of 0 will use the process ID as the PGID.
  ///
  /// ```no_run
  /// # async fn test() { // allow using await
  /// use tokio::process::Command;
  ///
  /// let output = Command::new("sleep")
  ///     .arg("10")
  ///     .process_group(0)
  ///     .output()
  ///     .await
  ///     .unwrap();
  /// # }
  /// ```
  ///
  /// [signal handler]: crate::signal
  Future<void> processGroup({required int pgroup});

  /// Executes the command as a child process, returning a handle to it.
  ///
  /// By default, stdin, stdout and stderr are inherited from the parent.
  ///
  /// This method will spawn the child process synchronously and return a
  /// handle to a future-aware child process. The `Child` returned implements
  /// `Future` itself to acquire the `ExitStatus` of the child, and otherwise
  /// the `Child` has methods to acquire handles to the stdin, stdout, and
  /// stderr streams.
  ///
  /// All I/O this child does will be associated with the current default
  /// event loop.
  ///
  /// # Examples
  ///
  /// Basic usage:
  ///
  /// ```no_run
  /// use tokio::process::Command;
  ///
  /// async fn run_ls() -> std::process::ExitStatus {
  ///     Command::new("ls")
  ///         .spawn()
  ///         .expect("ls command failed to start")
  ///         .wait()
  ///         .await
  ///         .expect("ls command failed to run")
  /// }
  /// ```
  ///
  /// # Caveats
  ///
  /// ## Dropping/Cancellation
  ///
  /// Similar to the behavior to the standard library, and unlike the futures
  /// paradigm of dropping-implies-cancellation, a spawned process will, by
  /// default, continue to execute even after the `Child` handle has been dropped.
  ///
  /// The [`Command::kill_on_drop`] method can be used to modify this behavior
  /// and kill the child process if the `Child` wrapper is dropped before it
  /// has exited.
  ///
  /// ## Unix Processes
  ///
  /// On Unix platforms processes must be "reaped" by their parent process after
  /// they have exited in order to release all OS resources. A child process which
  /// has exited, but has not yet been reaped by its parent is considered a "zombie"
  /// process. Such processes continue to count against limits imposed by the system,
  /// and having too many zombie processes present can prevent additional processes
  /// from being spawned.
  ///
  /// The tokio runtime will, on a best-effort basis, attempt to reap and clean up
  /// any process which it has spawned. No additional guarantees are made with regard to
  /// how quickly or how often this procedure will take place.
  ///
  /// It is recommended to avoid dropping a [`Child`] process handle before it has been
  /// fully `await`ed if stricter cleanup guarantees are required.
  ///
  /// [`Command`]: crate::process::Command
  /// [`Command::kill_on_drop`]: crate::process::Command::kill_on_drop
  /// [`Child`]: crate::process::Child
  ///
  /// # Errors
  ///
  /// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`
  /// if the system process limit is reached (which includes other applications
  /// running on the system).
  Future<Child> spawn();

  /// Sets the child process's user ID. This translates to a
  /// `setuid` call in the child process. Failure in the `setuid`
  /// call will cause the spawn to fail.
  Future<void> uid({required int id});
}
